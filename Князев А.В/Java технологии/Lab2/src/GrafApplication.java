import java.awt.*;
import java.awt.event.*;

public class GrafApplication {
	public static void main(String[] args) {
		ќсновноеќкно gf = new ќсновноеќкно("√раф");
		gf.setSize(600, 400);
		gf.setVisible(true);
	}
}

class ѕараметры {
	int вершинаA, вершинаD;
	int реброB, реброC;
	boolean корректность=false;
	void проверить орректность(int n)
	{
		if(вершинаA>n||вершинаD>n||реброB>n||реброC>n) корректность=false;
	}
}

class ƒиалогѕараметры extends Dialog {
	ѕараметры params;
	TextField pt1, pt2, ln1, ln2;
	public ƒиалогѕараметры(final ѕараметры params, Frame parent, String title){
		super(parent,title,true);
		this.params=params;
		setLayout(new GridLayout(3,3,10,5));
		setSize(400,120);
		Button btOk=new Button("ќк"), btCancel=new Button("ќтмена");
		Label lbPoints=new Label("¬ершины:"), lbLine=new Label("–ебро между вершинами:");
		pt1=new TextField();
		pt2=new TextField();
		ln1=new TextField();
		ln2=new TextField();
		add(lbPoints);add(pt1);add(pt2);
		add(lbLine);add(ln1);add(ln2);
		add(btOk);add(btCancel);
		btOk.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent ev) throws NumberFormatException {
				params.вершинаA = Integer.parseInt(pt1.getText());
				params.вершинаD = Integer.parseInt(pt2.getText());
				params.реброB = Integer.parseInt(ln1.getText());
				params.реброC = Integer.parseInt(ln2.getText());
				params.корректность=true;
				dispose();
				setVisible(false);
			}
		});
		btCancel.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent ev){
				dispose();
				setVisible(false);
			}
		});
		
	}
}

class ќсновноеќкно extends Frame implements ActionListener, MouseListener, ComponentListener {
	ѕараметры параметры;
	√раф граф;
	’олст холст;
	int вершинаЌового–ебра=-1;
	Label статусна€—трока;
	
	public ќсновноеќкно(String title) {
		super(title);
		параметры = new ѕараметры();
		addWindowListener(new WindowAdapter(){
			public void windowClosing(WindowEvent we){
				System.exit(0);
			}
		});
		addMouseListener(this);
		addComponentListener(this);
		setLayout(new BorderLayout());
		статусна€—трока=new Label("«адайте граф");
		статусна€—трока.setBackground(new Color(242,242,242));
		add(статусна€—трока,BorderLayout.SOUTH);
		граф = new √раф();
		MenuBar mb = new MenuBar();
		Menu файл = new Menu("‘айл");
		MenuItem новый√раф = new MenuItem("Ќовый граф");
		файл.add(новый√раф);
		MenuItem выход = new MenuItem("¬ыход");
		файл.add(выход);
		mb.add(файл);
		
		Menu опции = new Menu("ќпции");
		MenuItem параметр = new MenuItem("ѕараметры...");
		опции.add(параметр);
		MenuItem задание = new MenuItem("«адание...");
		опции.add(задание);
		mb.add(опции);
		
		setMenuBar(mb);
		выход.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				System.exit(0);
			}
		});
		final ќсновноеќкно f=this;
		параметр.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				Dialog pd = new ƒиалогѕараметры(параметры, f,"ѕараметры...");
				pd.setVisible(true);
				параметры.проверить орректность(граф.количество¬ершин);
				f.repaint();
			}
		});
		задание.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				статусна€—трока.setText("Ќайти цикл, проход€щий через вершины a и d и ребро b c");
			}
		});
		новый√раф.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				граф.очистить();
	            параметры.корректность=false;
				f.repaint();
			}
		});
	}
	public void actionPerformed(ActionEvent ev) {
		repaint();
	}
	public void componentResized(ComponentEvent e) {
		repaint();
	}
	public void paint(Graphics g){
		if (граф.количество¬ершин==0) return;
		холст = new ’олст(граф.количество¬ершин, this.getWidth(), this.getHeight() - 70, g);

		double a=0;
		for(int j=0;j<граф.количество¬ершин;j++)
		 {
           for (int k=0;k<граф.количество¬ершин;k++)
           if(граф.есть–ебро(j,k))
               холст.соединить¬ершины(j,k);
           a+=холст.step;
		 }
		if(параметры.корректность)
		 {  
			g.setColor(Color.yellow);
			if(граф.поиск_в_глубину(холст,параметры.вершинаA,параметры.реброB,параметры.реброC,параметры.вершинаD))
				this.статусна€—трока.setText("÷икл найден.");
			else this.статусна€—трока.setText("Ќет таких циклов.");
			g.setColor(Color.black);
		 }
		for(int j=0;j<граф.количество¬ершин;j++)
           холст.нарисовать¬ершину(j);
	}
	
	public void mouseClicked(MouseEvent arg0) {}
	public void mouseEntered(MouseEvent arg0) {}
	public void mouseExited(MouseEvent arg0) {}
	public void mousePressed(MouseEvent e) {
		if (граф.количество¬ершин==0) { граф.нова€¬ершина(); this.repaint(); return; }
        int выделенна€¬ершина = холст.вершинаѕоXY(e.getX(), e.getY());
        if (выделенна€¬ершина == -1) { граф.нова€¬ершина(); this.repaint(); }
        вершинаЌового–ебра = выделенна€¬ершина;
	}
	public void mouseReleased(MouseEvent e) {
		if (граф.количество¬ершин == 0) { граф.нова€¬ершина(); this.repaint(); return; }
        int выделенна€¬ершина = холст.вершинаѕоXY(e.getX(), e.getY());
        if (выделенна€¬ершина != -1 && вершинаЌового–ебра != -1) граф.новое–ебро(выделенна€¬ершина, вершинаЌового–ебра);
        this.repaint();
        вершинаЌового–ебра=-1;
	}
	public void componentHidden(ComponentEvent arg0) {}
	public void componentMoved(ComponentEvent arg0) {}
	public void componentShown(ComponentEvent arg0) {}
}
class ’олст 
{
	private int cx,cy;//центр холста
    private int n,r,R;//количество вершин графа, радиус вершины, радиус окружности задающей центры вершин
    public double step;//шаг радиуса R дл€ перехода к следующей вершине
	private Graphics g;
	private final int st=40;//отступ сверху
	
    public ’олст(int n, int mx, int my, Graphics g)
    {
        this.n = n;
        this.cx = mx / 2;
        this.cy = my / 2;
        int rr=(cx<cy?cx:cy);
        int bb=(rr/n)>>1;
        this.R = (int)(rr / (1 + Math.sin(Math.PI / n)));
        this.r = rr - R - bb;
		if(r<0)r=-r;
        this.step = 2 * Math.PI / n;
        this.g = g;
    }
    private void лини€(int x,int y,int xx,int yy)
    {
		g.drawLine(x,st+y,xx,st+yy);
    }
    public void соединить¬ершины(int i,int j)
    {
        int x = (int)(cx + R * Math.cos(step * j)), y = (int)(cy + R * Math.sin(step * j));
        int xx = (int)(cx + R * Math.cos(step * i)), yy = (int)(cy + R * Math.sin(step * i));
        лини€(x,y,xx,yy);
    }
    public void нарисовать¬ершину(int j)
    {
            int x=(int)(cx+R*Math.cos(step*j)), y=(int)(st+cy+R*Math.sin(step*j));
			g.setColor(Color.white);
            g.fillOval(x-r,y-r,2*r,2*r);
			g.setColor(Color.black);
            g.drawOval(x-r,y-r,2*r,2*r);
			String s= String.valueOf(j);
			int dx=3*(j>9?2:1), dy=-4;
			g.drawString(s,x-dx,y-dy);
    }
    public int вершинаѕоXY(int X, int Y)
    {
    	int res = -1;
    	double a = 0;
        for (int j = 0; j < n; j++)
        {
            int x = (int)(cx + R * Math.cos(a)), y = (int)(st+cy + R * Math.sin(a));
            if ((X - x) * (X - x) + (Y - y) * (Y - y) <= r * r)
                res = j;
            a += step;
        }
        return res;
    }
}
class √раф
{
    private boolean[][] матрицаCмежности=new boolean[100][100];  //use: contact[max(i,j),min(i,j)]
    public int количество–ебер;
    
    public int количество¬ершин;
    public void очистить() {for(int i =0;i<100;++i) for(int j =0;j<100;++j) матрицаCмежности[i][j]=false; количество¬ершин=0;количество–ебер=0;}
	public √раф() { очистить(); }
    public void новое–ебро(int a, int b) { матрицаCмежности[a>b?a:b][a>b?b:a]=true;количество–ебер++; }
    public boolean есть–ебро(int a, int b){ return матрицаCмежности[a>b?a:b][a>b?b:a]; }
    public int нова€¬ершина() {return количество¬ершин++;}
    // Ќайти самый длинный цикл через вершины а d и ребро b c
    private int[] пройдено = new int[100];
    public boolean поиск_в_глубину(’олст холст,int a, int b, int c, int d)
    {
            int максимальна€_длина=0;
            for(int i=0;i<100;i++)
                    пройдено[i]=-1;
            int[] очередь = new int[100];
            пройдено[a]=-2;
            int текуща€_вершина=a;
            очередь[0]=a;
            int текуща€_длина=1;
            int следующа€_вершина=0;
            int[] цикл = new int[1];
			boolean ребро_пройдено=false;
			do
            {
                    if(следующа€_вершина<количество¬ершин)
                    for(;следующа€_вершина<количество¬ершин;следующа€_вершина++)
                    if(есть–ебро(текуща€_вершина,следующа€_вершина)) break;
                    if(следующа€_вершина<количество¬ершин)
                    {
                            if(пройдено[следующа€_вершина]==-1)
                            {
                                    // шаг вперед
                                    очередь[текуща€_длина++]=текуща€_вершина;
                                    пройдено[следующа€_вершина]=текуща€_вершина;
                                    текуща€_вершина=следующа€_вершина;
                                    следующа€_вершина=-1;
                                    if (текуща€_вершина == b && пройдено[c] == -1 && есть–ебро(b,c)) 
                                    { 
                                        ребро_пройдено = true; 
                                        очередь[текуща€_длина++] = текуща€_вершина; 
                                        пройдено[c] = текуща€_вершина; 
                                        текуща€_вершина = c; 
                                    }
                                    else
                                        if (текуща€_вершина == c && пройдено[b] == -1 && есть–ебро(c, b)) 
                                        { 
                                            ребро_пройдено = true; 
                                            очередь[текуща€_длина++] = текуща€_вершина; 
                                            пройдено[b] = текуща€_вершина; текуща€_вершина = b; 
                                        }
                            }
							if(следующа€_вершина==a&&пройдено[d]!=-1&&ребро_пройдено&&максимальна€_длина<текуща€_длина)
                            {
                                максимальна€_длина = текуща€_длина;
                                
                                цикл = new int[максимальна€_длина + 1];
                                int s=0;
								for(int l=текуща€_вершина;l!=-2;l=пройдено[l])
								{
                                    цикл[s] = l;
                                    s++;
								}
                                цикл[s] = текуща€_вершина;
							}
                            следующа€_вершина++;
                    }
                    else //ничего не найдено
                    {
                            // шаг назад
                            пройдено[текуща€_вершина]=-1;
                            следующа€_вершина=текуща€_вершина+1;
                            if(текуща€_вершина==c&&очередь[текуща€_длина-1]==b||текуща€_вершина==b&&очередь[текуща€_длина-1]==c)
								ребро_пройдено=false;
							текуща€_вершина=очередь[--текуща€_длина];
                    }
            }
            while (текуща€_длина>0);
            if (максимальна€_длина == 0) return false;
            for (int l = 0; l < максимальна€_длина; l++)
                холст.соединить¬ершины(цикл[l], цикл[l+1]);
            return true;
    }
}