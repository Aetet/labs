
                            ГЛАВА 17.
                   ИСПОЛЬЗУЕМ КОМАНДЫ ЯЗЫКА SQL

     "А теперь забудьте все, чему вас учили!". Рассмотрев команды
SQL - языка запросов, вы найдете, что в этой избитой фразе есть
доля истины. Язык SQL, используемый во многих СУБД, является
мощным, эффективным средством обработки баз данных. Сравните
приводимые ниже новые варианты программ с прежними и убедитесь в
этом сами.

               17.1. Применяем команду SELECT (SQL)

     Результатом большинства операций с БД является таблица: новая
БД, распечатка, двумерный массив, текстовый файл, экранная таблица и т.п.
Ранее вы узнали, как открывать БД, обеспечивать нужную упорядоченность,
привлекать данные вспомогательных БД, переключать поток вывода и пр.
Большие знания, усилия и тщательность требуются, чтобы оптимизировать
выполнение программ.
     Команда SELECT языка SQL определяет указанную выше обработку
баз данных с автоматической оптимизацией процесса, заменяя собой
несколько команд, начиная с USE. Это определение происходит на
логическом уровне, без лишней детализации. Поэтому данную команду
может использовать и начинающий, досконально изучивший примеры
применения. Начнем с примера и мы.
     Пример 17.1. Программу примера 16.2 заменяет следующая команда:
  SELECT Famil, KNaz, FNaz FROM Dipl c, Kafedr a, Faki b ;
  WHERE (c.NKaf=a.NKaf AND a.NFak=b.NFak) AND  Pr =.F. TO PRINTER.
(при переносе команды на новую строку добавляют ";" в конец предыдущей;
не забывайте оставлять пробел - слева от ";" или в начале новой строки
- во избежание "склеивания" слов).
   Запись "Dipl c, Kafedr a, Faki b" сопоставляет именам БД локальные
псевдонимы (имена) c,a,b, вне команды SELECT не имеющие силы.
Совпадающие имена полей различных (используемых в команде) БД
обязательно уточняются локальными псевдонимами или (в отсутствие
локального псевдонима) именами БД. Если локальный псевдоним вами
задан, то именно его надо использовать для уточнения имен полей.
Поскольку имена полей Famil, KNaz, FNaz, Pr уникальны, они даны без
квалификаторов, хотя запись "c.Famil, a.KNaz, b.FNaz" также допустима.
   "Англоязычным читателям" все уже должно быть ясно, а для остальных
- мы даем "перевод" записанной выше команды, формирующей таблицу
с указанными колонками (их совокупность обозначена как <Список полей>):
 ВЫБРАТЬ<Список полей> ИЗ<Список БД> ГДЕ<Условия связи БД и условие
фильтрации записей> НА ПРИНТЕР (для наглядности условия связи в
примере 17.1 заключены в скобки). Хотя указан вывод на принтер,
одновременно таблица выводится и на дисплей.
    Если бы мы удовольствовались фамилиями и номерами кафедр, а
таблицу выводили только на дисплей (это происходит по умолчанию), запись
команды упростилась бы:      SELECT Famil, NKaf FROM Dipl  WHERE Pr=.F.
Для записи таблицы как новой БД с именем _Dip команду расширяем:
   SELECT Famil, NKaf FROM Dipl  WHERE Pr=.F. INTO DBF _Dip .
Созданная БД автоматически открывается в текущей рабочей области.
    Если нужно, чтобы строки таблицы были упорядочены по кафедрам,
а в пределах одной кафедры - по фамилиям студентов, записываем команду
  SELECT Famil, NKaf FROM Dipl WHERE Pr=.F. ORDER BY NKaf,Famil .
    Пример 17.2. Найдем ежемесячную экономию стипендиального фонда
по каждой кафедре при отчислении неуспевающих дипломников. Придется
указать в <Списке полей> одну из "вертикальных" (применяемых к колонке) функций
- суммирование:  Sum(Stipa), где Stipa - поле БД с размером стипендий.
Мы указываем ее в списке выводимых полей.
В таблице для каждой кафедры с неуспевающими дипломниками нужна одна
строка с итогом суммирования. Такое группирование обеспечивает атрибут
GROUP BY NKaf. Строки мы упорядочим по номерам кафедр:
SELECT NKaf, Sum(Stipa) FROM Dipl WHERE Pr=.F. GROUP BY NKaf ORDER BY
NKaf.
     Итак, команда SELECT сама открывает БД, подбирает или создает
необходимые индексы, организует связь БД, фильтрует, группирует и
обрабатывает записи, закрывает БД, уничтожает временные файлы. При
ее выполнении автоматически используется технология Rushmore.
    БД-источники и новая БД, если она создается, остаются открытыми
после выполнения SELECT. Новая БД активна. Если программа продолжает
работу с этими БД после выполнения SELECT, проще всего закрыть все
файлы (CLOSE ALL) или все базы (CLOSE DATABASES), а необходимые
- вновь открыть. Тогда не придется разбираться с используемыми
рабочими областями.
    Мы рассмотрели случаи соединения исходных таблиц (БД) "по
горизонтали". Соединение "по вертикали" (UNION) рассмотрено в п. 17.3.
     Задание 17.1. В БД Kadr даны сведения о сотрудниках, в частности,
табельные номера, фамилии и даты зачисления в штат, а телефоны с
табельными номерами - в БД Telf. Вывести командой SELECT в алфавитном
порядке фамилии (а также телефоны) сотрудников, стаж работы которых
на предприятии сравняется с 20, 25, 30, 35 годами в указанном месяце
текущего года.

         17.2. Изучаем формы записи команды SELECT (SQL)

     Для дальнейшего изложения необходим термин "колонка",
относящийся к формируемой таблице, например NKaf, Sum(Stipa) - две
колонки (см. команду SELECT в примере 17.2). Кроме "вертикальных"
функций Sum, Avg (среднее арифметическое), Count (функция-счетчик),
Min, Max, колонки могут быть заданы выражениями с обычными, "не
вертикальными" функциями от полей БД, действующими в рамках отдельной
записи, и даже константами (см. пример 17.5), функциями пользователя.
В "вертикальных" выражениях можно указывать и несколько полей,
например:        Sum(Stipa)/5000, Max(Stipa)-Avg(Stipa) .   Примеры
"не вертикальных" выражений: Rtrim(Famil)+" "+ Imya, Str(Stipa,6).
     Обязательны лишь две первые составляющие команды SELECT (после
необязательного атрибута DISTINCT, предотвращающего вывод одинаковых
строк; атрибут ALL противоположного смысла действует по умолчанию):
        SELECT DISTINCT <Список колонок> FROM<Список БД>.
Порядок следующих составляющих команды не является жестким.
  В <Списке БД> необязательный локальный псевдоним БД ставят справа от
имени БД и отделяют от него одним или несколькими пробелами. Полная
запись элемента <Списка колонок> имеет вид
<Локальный псевдоним>.<Выражение, в частности, поле БД> AS<Имя колонки>.
Если <Список колонок> - это список всех полей указанных БД, его
показывают знаком "*".  Пример: SELECT * FROM Dipl WHERE Pr=.F. .
    Возможно упорядочение и группирование по колонкам-выражениям.
При этом допустимой формой указания колонки является имя этой колонки.
Кроме того, оно служит обозначением нового поля в БД - возможном
результате SELECT. В других случаях элемент AS<Имя колонки> не нужен.
По умолчанию имя колонки это
 - <имя поля БД>_<лат.буква>, например: NKaf_A, NKaf_B; буква
добавляется лишь при одинаковых именах полей разных БД, задающих колонки;
 - <имя "вертикальной" функции>_<имя поля>,  например: SUM_STIPA;
 - <имя "вертикальной" функции>_EXP_<порядковый номер>  (функция
применена не к отдельному полю, а к выражению); пример: SUM_EXP_2;
 - EXP_<порядковый номер колонки>  (колонка задана выражением).
Имя колонки определяет ее заголовок в таблице.
    Составляющая команды "Приемник таблицы".  Вариант "TO"<Приемник>.
Формы:TO PRINTER (см. пример в п. 17.1), TO FILE<Имя файла> ADDITIVE
(атрибут ADDITIVE означает, что таблица добавляется к прежнему
содержимому ASCII-файла, иначе файл перезаписывается). Параллельно
происходит выдача таблицы на экран, подавляемая, если нужно, опцией
NOCONSOLE.  Пример: TO PRINTER NOCONSOLE.  В любом случае выдачи на
экран допустимы опция PLAIN (заголовки колонок не выдаются) и опция
NOWAIT (не происходит паузы при заполнении экрана, идет "прокрутка").
Вариант "INTO<Приемник>"; таблица на экран не выдается. Формы:
а)INTO ARRAY <Имя массива>; массив подобен создаваемому в команде
COPY TO ARRAY;
б)INTO CURSOR<Имя КУРСОРА - временной базы>, КУРСОР может быть
источником данных для другой команды SELECT, его поля доступны лишь
для чтения, например, могут быть указаны в команде BROWSE; закрытие
КУРСОРА, например, вызванное завершением задачи, ведет к его удалению;
в)INTO TABLE<Имя БД> или INTO DBF<Имя БД>  (см. пример в п. 17.1).
В одной команде SELECT нельзя совмещать варианты TO и INTO.
    Составляющая WHERE<Условия связи БД и фильтрации> рассмотрена в
п. 17.1. Рассмотрим ограничения и возможности. Допускаются
макроподстановки. Условия связи БД соединяются между собой и с
условием фильтрации единственно возможной операцией AND (или .AND.).
В условиях фильтрации допускаются AND, OR, NOT. Их операнды должны
быть равенствами (неравенствами), поэтому, заменяя программу примера
16.2, мы вынужденно записали в команде равенство Pr =.F. В условии
фильтрации допустимы также сравнения вида
- <Выражение> LIKE <Шаблон>, например сравнение Memo-поля  Dosje:
Dosje LIKE "%повар%" (для вывода фамилий и "досье" всех бывших поваров);
в <Шаблоне> % обозначает любую последовательность символов, знак
подчеркивания - некоторый (любой) символ;
- <Выражение> BETWEEN <Минимальное значение>AND<Максимальное значение>;
значение .T. вырабатывается, если значение <Выражения> находится в
указанном диапазоне;
- <Выражение> IN (<Список константных выражений>); значение .T.
вырабатывается при совпадении значения <Выражения> с любым из значений
<Списка>. Пример: NOT Fak IN(" 1", " 3"); выделяются записи студентов,
обучающихся не на факультетах 1 и 3.
    Кроме того, в условии фильтрации могут применяться квантор
существования EXISTS и результаты выполнения подчиненных команд SELECT
(см. п.17.4).
    Составляющая ORDER BY <Список колонок или полей БД>. Элемент списка
должен сопровождаться атрибутом DESC (справа), если в данной колонке
(по данному полю) должен быть убывающий порядок. По умолчанию
предполагается ASC (упорядочение по возрастанию). Первый элемент
задает глобальный порядок, прочие - локальный (см. п. 3.9). В <Списке>
колонки задают или их именами, или порядковыми номерами. Самая левая
колонка имеет номер 1.
    Составляющая GROUP BY <Список имен колонок или полей БД>. Допустим
лишь один уровень группирования. Применяя КУРСОР и еще одну команду
SELECT, можно выполнить группирование строк на более высоком уровне и
т.д.(см. пример 17.4). Поля БД, не задающие колонки таблицы, также
могут управлять группированием (и упорядочением, но последнее не
оговорено в руководствах).
    Составляющая HAVING<Условие вывода группы> "работает" только в паре
с GROUP BY и записывается, если есть требование, которому должна
удовлетворять оценка группы, например ее размер.
    Пример 17.3. Условия примера 16.2. Для наложения "штрафных санкций"
выделяются кафедры, на которых не получили зачет по преддипломной практике
более 2 студентов. Печатается список этих кафедр (названия и число
вышеуказанных студентов на кафедре).
 SELECT KNaz, Count(*) FROM Dipl c, Kafedr a  GROUP BY c.NKaf ;
 WHERE c.NKaf=a.NKaf AND Pr =.F.  HAVING Count(*) > 2  TO PRINTER
    Настало время дать пример применения DISTINCT (см. описание начала
команды). Если просто нужно вывести номера (или названия) кафедр, на
которых хотя бы один дипломник не получил зачета по практике, можно
обойтись и без группирования, применяя DISTINCT:
 SELECT DISTINCT NKaf FROM Dipl  WHERE Pr =.F.  && Выводятся номера
 SELECT DISTINCT KNaz FROM Dipl c, Kafedr a;
    WHERE c.NKaf=a.NKaf  AND  Pr =.F.          && Выводятся названия
    Задание 17.2. Создайте БД Prim с полями Famil и Sport (условный
номер вида спорта, которому отдает предпочтение персона Famil).
Значения поля Sport сделайте повторяющимися. В БД Ras дайте словесное
название вида для каждого номера. 1.С помощью SELECT выведите названия
всех указанных в БД Prim видов спорта. Группирование не применять.
2. Выведите названия видов спорта, указанных в Prim более 5 раз.

            17.3. Изучаем примеры использования SELECT (SQL)

    Использование команд SQL избавляет пользователя от рутинных
"технических" моментов программирования, оставляя лишь главную цель:
научиться "видеть" свои задачи в терминах команд SQL. Для этого
следует изучить многочисленные примеры применения команд и
выполнить серию упражнений с ними, в частности, изменяя вход и
выход команд SELECT. Проверим свое понимание SELECT (SQL) на задаче
примера 16.1. Фактически для ее решения нам нужна команда
 SELECT DB1.Famil, DB2.Famil FROM DB1,DB2 WHERE DB1.Famil =<Фамилия> ;
                                          AND <Условие связи>,
где варьируемое <Условие связи> выражает соответствие исходной и
искомой (в DB2) личностей. Текст этого условия, как и <Фамилия>,
предварительно вводится, а в SELECT - используется макроподстановка.
Программа упрощается и к тому же дает не один, а все возможные
варианты ответа, например, указывает всех доноров с необходимой
пациенту <Фамилия> группой крови.
    Пример 17.4. Группирование на двух уровнях.
В дополнение к результатам примера 17.2 найдем ежемесячную экономию
стипендиального фонда по факультетам.
 SELECT NKaf, Sum(Stipa) FROM Dipl WHERE Pr =.F. GROUP BY Nkaf ;
 ORDER BY NKaf INTO CURSOR Cu     && Создается КУРСОР с 2 полями
 SELECT * FROM Cu           && Вывод на дисплей итогов по кафедрам
 SELECT NFak, Sum(Sum_Stipa) FROM Kafedr a, Cu WHERE a.NKaf=Cu.NKaf ;
 GROUP BY NFak          && Получение и вывод итогов по факультетам
    В последней команде SELECT использовано имя по умолчанию
Sum_Stipa колонки в КУРСОРЕ, но можно было в 1-й команде SELECT дать
Sum(Stipa) AS <Имя колонки>, а в 3-й команде SELECT записать
Sum(<Имя колонки>) вместо Sum(Sum_Stipa).
    Соединение таблиц "по вертикали". Атрибут UNION. Данный атрибут
связывает независимо выполняемые команды SELECT и по существу
представляет следующую операцию: в одной таблице размещаются строки,
выработанные всеми связанными командами. Это возможно, только если в
наборах одно и то же число колонок и тип значений в пределах каждой
составной колонки одинаков. Требование обоснованно: вспомним, что
"приемником" может быть БД. Заметим, что к именам и размерам полей
никаких требований не предъявляется.
     Пример 17.5. Имеются две БД: а) Licey - таблица обучаемых в
лицее при вузе, б) School - таблица школьников выпускного класса
подшефной школы, занимающихся в кружке при вузе. В БД Licey
(School) есть поле Pr, куда заносится значение .T. для тех
обучаемых, которые приняты в вуз по результатам выпускных экзаменов
лицея (экзаменов "Проверь себя"). Надо получить сводный список
принятых в вуз с указанием возле каждой фамилии (поле Famil) слова
"лицей" или "школа".
      SELECT Famil, "лицей" FROM Licey WHERE Pr =.T.  UNION  ;
      SELECT Famil, "школа" FROM School WHERE Pr =.T.
Мы впервые использовали колонку с константой. Команды независимы,
поэтому поля в них не уточняются. Нельзя было бы поменять местами
элементы <Списка колонок> в одной из команд: в составных колонках
оказались бы значения разного типа.
    Построенная таблица автоматически упорядочивается по <Списку
колонок>. В нашем случае это приводит к перемешиванию строк
школьников и "лицеистов": поле Famil главное при упорядочении.
Добъемся отдельного расположения наборов строк школьников и
"лицеистов", добавив  ORDER BY 2, 1 (указаны номера колонок).
Добавление производится в последнюю из связанных команд.
Если вы хотите поставить вперед школьников, запишите
ORDER BY 2 Desc, 1 (упорядочение по убыванию в колонке констант).
    В построенной таблице автоматически исключаются дубликаты
строк. Если в лицее и в школе обучаются два ИВАНОВА, дубликаты не
возникают, ибо "ИВАНОВ   лицей" и "ИВАНОВ   школа" - это разные
строки. Если дубликаты нужны, следует в команде после слова
UNION дописать атрибут ALL.
    В случае соединения нескольких команд можно использовать
скобки: SELECT ... UNION (SELECT ... UNION ALL SELECT ... ).
UNION может связывать команды, имеющие подзапросы, но не может
связывать подзапросы.
    Пример 17.6. Изменение структуры и содержания БД.
Имеется БД Gruppa с фамилиями студентов (поле Famil), датой (Data)
последней защиты лабораторных работ и количеством (Kol) защищенных
работ. Студенты, защитившие все 6 лабораторных работ до 21 декабря
1995 г., получают зачет-"автомат" и в новое поле Itogi заносится
значение "ЗАЧТЕНО". В записи прочих студентов заносится "СДАВАТЬ
ЗАЧЕТ".
 SELECT Famil, Kol, Data, Iif(Kol=6 .AND. Data < {12/21/95}, ;
    "ЗАЧТЕНО", "СДАВАТЬ ЗАЧЕТ") AS Itogi FROM Gruppa INTO DBF _Temp
 CLOSE DATABASES         && Для следующих команд требуется закрыть БД
 ERASE Gruppa.DBF
 RENAME _Temp.DBF TO Gruppa.DBF
 SELECT * FROM Gruppa   && Вывод на дисплей содержания обновленной БД
    Задание 17.3. Оформите и опробуйте новый вариант программы
примера 16.1, рассмотренный в начале п. 17.3, обеспечив запись
результатов в ASCII-файл, имя которого задается путем ввода.

            17.4. Используем подчиненные команды SELECT.
                        Функции пользователя

    Для случаев, когда запрос основывается на результатах других
запросов (подзапросов), типично их применение в составе условий
фильтрации. Удобной формой является запись подчиненной команды
SELECT как правого операнда равенства (неравенства) или операнда в
операции IN (см. п. 17.2). Такая команда, заключаемая в скобки (),
вывод не осуществляет, а представляет результат запроса. В ее списке
колонок - всего одна колонка.
    В следующих примерах будем ссылаться на БД Student с полями
TabN (табельный номер студента), Famil (фамилия с инициалами), Kurs
(курс обучения), Fak (факультет), SrB (средний балл студента), Bolt.
    Коррелированные выборки. Этот термин применяется в случае,
когда строки в таблицу выбираются по результатам выполнения
подчиненных команд SELECT, использующих ту же исходную БД (ей
следует дать различные псевдонимы в главной и подчиненных командах).
    Пример 17.7. Подзапрос с результатом-значением.
Для каждого курса каждого факультета выведем табельные номера и
фамилии студентов, средний балл SrB которых выше среднего
арифметического значений SrB для данного факультета.
 SELECT TabN, Famil, Fak, Kurs FROM Student a ORDER BY Fak, Kurs ;
  WHERE SrB >(SELECT Avg(SrB) FROM Student b WHERE a.Fak = b.Fak)
    Оцените, насколько упрощается программа по сравнению с
последовательным применением множества команд SELECT. Обратите
внимание на то, что в подчиненной команде группирования нет, ибо
для конкретного сравнения требуется одно значение подзапроса,
использующего необходимую фильтрацию.
    Квантор существования. Подвыражение условия фильтрации
           EXISTS (<Подчиненная команда SELECT>),
где EXISTS - так называемый квантор существования, дает значение .T.
лишь в случае непустой таблицы - результата подчиненной команды SELECT.
Чаще всего EXISTS используется с отрицанием NOT: NOT EXISTS.
Поскольку подчиненная команда вывод не выполняет, нет смысла в
детализации <Списка колонок>, записываем в ней после SELECT знак "*".
    Пример 17.8. Выведем упорядоченную по факультетам, а в рамках
факультета - по курсам  таблицу с полями Famil, Fak, Kurs, исключив
студентов платного обучения и студентов, пришедших в вуз после армии.
Списки этих студентов хранятся в БД Platn и PostAr соответственно.
В этих БД - одно поле TabN. Искомую таблицу выводит команда
 SELECT Famil, Fak, Kurs FROM Student a  ORDER BY Fak, Kurs ;
 WHERE NOT EXISTS (SELECT * FROM Platn b  WHERE a.TabN = b.TabN) ;
   AND NOT EXISTS (SELECT * FROM PostAr c  WHERE a.TabN = c.TabN) .
Обратите внимание на то, что БД, открытая в 1-й команде SELECT,
действует (как и псевдоним ее) в подчиненных командах SELECT. Хотя
число их не ограничено, допускается лишь один уровень подчинения.
    Подзапросы с множественным результатом. Варианты:  ALL
(замаскированная логика "И"), ANY или SOME (логика "ИЛИ"). Указанные слова
ставятся в условие после знака равенства (неравенства) до подзапроса.
    Пример 17.9. Найдем студентов, произносящих в минуту не меньше
слов, чем каждая из студенток (задача-шутка). Число слов представляет
поле Bolt. Все строки подзапроса (в нем фигурируют студентки) должны
находиться в заданном отношении со строкой студента для того, чтобы
она была выбрана:
       SELECT Famil FROM Student WHERE Pol ="М"  AND
       Bolt >= ALL (SELECT Bolt FROM Student WHERE Pol ="Ж")
Фамилии оставшихся студентов можно получить и без применения NOT к
указанному выше условию фильтрации:
       SELECT Famil FROM Student WHERE Pol ="М"  AND
       Bolt < ANY (SELECT Bolt FROM Student WHERE Pol ="Ж")
Здесь ANY обозначает достаточность и одной строки подзапроса,
находящейся в заданном отношении "меньше".
    Пользовательские функции (ПФ) в SELECT. Содержание колонки
формируемой таблицы можно определять сложным, даже условным (пример
17.6), выражением. При слишком сложных выражениях наглядность команды
теряется. Это одна из возможных причин вынесения вычислений в ПФ.
Они могут быть итерационными (выполняются в цикле); такие расчеты не
записываются в SELECT прямо.
    Пример 17.10. В БД Postav имеются поля Cena (цена единицы товара),
Name (его название), Kol (число единиц в партии товара). Выведем
таблицу с указанием стоимости партии каждого товара, вычисляемой
следующим образом:
 - если Kol в пределах сотни -  Cena*Kol;
 - если Kol в пределах тысячи (больше сотни) - 0.95*Cena*Kol;
 - если Kol в пределах 10000 (больше тысячи) - 0.95*0.95*Cena*Kol
и т.д. (цена единицы товара уменьшается в геометрической прогрессии).
  SELECT Name, Cena, Kol, F(Cena, Kol) FROM Postav
  FUNCTION F
  PARAM Cena, Kol, Z                        && Z - не параметр
   Z = Cena*Kol
   Kol = Kol/100
    DO WHILE Int(Kol) # 0
    Z = Z* 0.95
    Kol = Kol/10
    ENDDO
   RETURN Z
Существует и неитерационный вариант расчета стоимости партий.
   Сложные ПФ в команде SELECT замедляют работу, поэтому их
следует писать на Ассемблере или Си. Следует учитывать и
ограничения. Единственный путь передачи значений в ПФ - список
аргументов. Создаваемая в SELECT операционная среда БД "непрозрачна"
и ПФ, работающая с БД, практически не может на нее опираться.
Попытки управлять средой из ПФ - рискованны. Даже если методом
"проб и попыток" получен действующий вариант, он может стать
непригодным в следующей версии FOXPRO, ибо оптимизатор, от
которого зависит управление средой в SELECT, постоянно
совершенствуется.
    Задание 17.4. Воспользуйтесь БД Student и создайте БД Tel, в
которой даны телефоны некоторых студентов и их табельные номера.
Выведите фамилии студентов, не имеющих телефона, используя квантор
существования.

      17.5. Создаем, модифицируем и дополняем базы данных в SQL

    Команды SQL "избыточны" в языке FOXPRO, язык универсален и без них.
Такова и команда создания пустой БД, в которой определена ее структура:
          CREATE DBF <Имя БД> (<Список описаний полей>) ,
где <описание поля> имеет вид  <Имя поля> <Тип> (<Размер поля>,<Число
дробных разрядов>), где <Тип> - одна из букв  C,N,F,D,L,M (без кавычек),
отделяемая от имени пробелом. <Размер поля> не нужен в описании полей
типа D,L,M, а последний элемент задают лишь для чисел.
    Пример 17.11. Создаем БД Student (см. п. 17.3):
CREATE DBF Student(TabN C(4), Famil C(30), Kurs C(1), Fak C(2), SrB N(3,1),
Bolt N(3,0) ).    Оцените сами удобство данной команды.
    Вариант команды    CREATE DBF <Имя БД> FROM ARRAY<Имя массива>
использует массив в качестве описания структуры (см. Afields() в п. 3.1).
    Пример 17.12. Добавим в БД Student поле Proc - процент выполнения
графика (окончание программы сделайте по образцу примера 17.6):
  USE Student
  N = AFields(Stru)+1        && N - число полей БД, увеличенное на 1
  DECLARE Stru[N,4] && Массив описан вновь с увеличением числа строк
  Stru[4,1] = "Proc"
  Stru[4,2] = "N"
  Stru[4,3] = 2
  Stru[4,4] = 0               && Закончено описание нового поля Proc
  CREATE DBF _Temp FROM ARRAY Stru    && Открывается пустая БД _Temp
  APPEND FROM Student     && БД _Temp наполняется данными БД Student
* Удалите БД Student и переименуйте _Temp в Student, как в примере 17.6.

Гораздо "элегантнее" выполняет те же действия следующая команда SELECT:
        SELECT *, 00 AS Proc FROM Student INTO DBF _Temp .
Формат новой колонки (нового поля БД) и тип мы показали константой 00,
которая заносится в новое поле Proc всех записей БД _Temp.
Записав +00.000, мы "запасли" бы место для знака и 3 разрядов дроби.
При добавлении символьного поля нужно записать в SELECT колонку
Space(N), где N - размер поля, а для поля-даты - пустую дату { / / }.
    Пример 17.13. На основе структуры БД Kadr создадим пустую БД
NewKadr,добавив поля дат InDate, OutDate и символьное поле CvetGlaz
размером 15:
  SELECT *, {//} AS InDate, {//} AS OutDate, Space(15) AS CvetGlaz;
  FROM Kadr WHERE .F.      && Значение .F. запрещает выбирать записи
    Пример 17.14. Создадим пустую БД на основе структур баз BD1,BD2:
  SELECT * FROM BD1,BD2 WHERE .F.   && Не возбраняется добавлять поля
   Примечание. Если в исходных БД имеются поля с одинаковыми
названиями <Имя>, в новой БД возникнут поля с именами <Имя>_A, <Имя>_B.
Добиться включения одного из них можно лишь явной записью списка
колонок. Альтернатива: мсключить в БД лишние поля и убрать лишнее
окончание имени позднее через интерфейс.
    Если необходимо усечение структуры БД, в SELECT перечисляются
остающиеся поля (и добавляются колонки, если нужны новые поля). Этот
вариант проще программы, использующей CREATE DBF. Следовательно,
вторая ее разновидность практической ценности не имеет.
    Дополнение БД новой (непустой) записью выполняет команда
  INSERT INTO <Имя БД>(<Список полей>) VALUES(<Список выражений -
  значений полей>) .   Неуказанные поля не заполняются значениями.
Вариант команды         INSERT INTO <Имя БД> FROM <Источник>,
где <Источник> - это ARRAY<Имя массива>  или  MEMVAR (см. п. 15.5),
заполняет новую запись значениями, взятыми из массива или (MEMVAR) из
переменных, одноименных с полями БД. Если для какого-либо поля такой
переменной нет, оно не заполняется.
    Дополняемая БД открывается, если ранее не была открыта, и остается
активной после выполнения команды INSERT INTO.
    Задание 17.5. С помощью SELECT создайте БД, в структуру которой
первоначально войдут все поля указанных вами двух БД, а исключение
полей, определенных вами как "ненужные", выполните через системное
меню (элемент Delete в окне Modify structure, выполняемый нажатием
Ctrl+D в момент, когда маркер наведен на исключаемое поле).
Дополните БД новыми записями с помощью INSERT INTO.

                     ЗАКЛЮЧЕНИЕ К ГЛАВЕ 17

     Используя команду SELECT для выборки и обработки данных, вы
сократите свои программы, ускорите их работу и, что немаловажно,
будете делать меньше технических ошибок. В FOXPRO для формирования
запросов в интерактивном режиме предусмотрено специальное средство
RQBE, вызываемое с помощью пункта Create подменю File.
