                           ГЛАВА 23

                   РАБОТАЕМ В ЛОКАЛЬНОЙ СЕТИ

  Казалось бы, совместное использование баз данных и
периферии - несложная вещь. Однако, когда пользователи
используют общие ресурсы, количество переходит в качество, обычно
- худшее. Но интеграция данных и сети - неумолимое требование времени.
    Даже две программы, корректные при единоличном владении ресурсами,
при выполнении в режиме разделения ресурсов могут создать проблемы.
В данной главе рассматривается существо этих проблем и языковое 
обеспечение работы в сети. Рассматривается простая сеть ПЭВМ.

        23.1. Знакомимся с локальной сетью ПЭВМ и терминами

    Локальная сеть позволяет двум или большему числу пользователей
совместно использовать данные, диски и иные периферийные устройства.
Соединение ПЭВМ в сеть требует установки сетевого программного
обеспечения и оборудования: одна плата в каждой ПЭВМ и соединительный 
кабель. Для использования FOXPRO в сети требуется сетевая версия 
FOXPRO - FOXPRO/LAN.
    В простой сети один главный компьютер (Сервер либо Файл-сервер) 
содержит на винчестере сетевое программное обеспечение и файлы, 
используемые в режиме разделения ("разделяемые"): в простой сети 
двум и более пользователям разрешено открывать один и тот же файл 
на Сервере (Файл-сервере) для работы с других ПЭВМ сети, называемых 
рабочими станциями. Однако, разделение файлов не всегда приемлемо, и 
поэтому предусмотрен также монопольный режим использования файла.
Представьте попеременное использование записей разделяемой БД Student, 
в которых указан курс обучения, программой, вырабатывающей для каждого 
курса отдельные результаты, и программой, изменяющей значения поля 
"Курс" в связи с переводом студентов на новый курс. Нелепость такого 
"разделения БД" очевидна. Далее речь идет о разделяемых БД.
    БД можно открыть в монопольном режиме, если она не открыта ни на 
одной другой рабочей станции. Хотя конкурируют и временами конфликтуют 
не сами пользователи, а использующие разделяемый файл процессы, 
порождаемые пользовательскими программами, изложение упрощается, если 
упоминаются пользователи. Пользователь,который открыл БД в монопольном
режиме, единолично владеет ею, и пока он не закроет БД, никто другой
доступа к ней не получит. Этот самый "эгоистичный" вариант ограничения
доступа называют полным блокированием. Если файл открыт в режиме 
разделения, никто не может установить монопольный режим, но один из 
пользователей файла может его захватить (блокировать), после чего другим 
пользователям его записи становятся доступны лишь в режиме чтения. 
Различайте блокирование и полное блокирование. 
    Блокировать можно и весь файл, и отдельные записи; сделать это 
могут несколько пользователей (каждый захватывает свою "долю"). 
Пользователь, выполнивший блокирование, называется владельцем блокирования. 
Разблокирование - это отмена блокирования. Запись перед ее изменением 
блокируют, ибо нет более страшной картины, чем одновременное изменение 
записи несколькими пользователями. После изменения запись нужно разблокировать.
    Пользователю, надолго монополизирующему или блокирующему БД, 
рекомендуют снимать копию БД и делать с ней все, что заблагорассудится, 
с перерывами на чаепитие, оставив исходную БД в распоряжении других 
пользователей. При необходимости перенести в нее изменения поможет 
команда UPDATE. 
    Представьте иную ситуацию: БД заблокирована пользователем, 
прочие или работают с ней в режиме чтения, или ожидают разблокирования. 
Если бы пользователь удовлетворился захватом не всей БД, а отдельных 
записей, возможно, не пришлось бы ждать другим. Представьте далее, что 
для завершения работы с БД первому пользователю нужен доступ к другой 
БД, но кто-то "пожадничал" и открыл ее в монопольном режиме. Теперь 
приходится ждать и ему (а с ним и другим). Чтобы "сгустить краски", 
добавим, что второму владельцу блокирования для завершения работы с 
БД, требуется доступ к первой БД с целью изменения записей. Но первая 
БД захвачена. Тупик. Вот что получается, когда слишком рьяно "тянут 
одеяло на себя" или изображают "собаку на сене", владея блокировкой, 
но используя БД лишь частично. Тупики - одна из проблем работы в сети.
   Итак, при интенсивной работе с разделяемыми БД монопольный режим 
должен использоваться только в виде исключения. Чтобы сократить общие 
(и собственные) потери времени, пользователям сети следует: 
а)не захватывать данные на более длительный период, чем объективно 
необходимо; например, не нужно полагаться на автоматическое
разблокирование данных по окончании решения задачи;
  б) открывать БД в режиме разделения, если изменению данных 
предшествует иное их использование, а захват БД осуществлять позднее;
  в) стремиться к полной или временной замене каждого захвата БД 
захватом отдельных записей или - в FOXPRO - групп записей;
  г) немедленно отменять все свои блокирования, если неуспешна попытка
очередного блокирования и осознана бесполезность дальнейшего ожидания;
  д) исследовать вероятность тупиков и обдумывать меры их предотвращения.
Последнее делается в кругу пользователей с участием администратора БД.
  Отменить блокирование может только владелец. Отмена может не быть
явной: в базе данных новое блокирование отменяет действие предыдущего.
Исключение (в последних версиях СУБД) сделано для группового блокирования
записей, когда возможно сохранение предыдущего блокирования записей.
Допустим, мы блокируем запись, а затем - всю БД. После отмены блокирования
данной БД в ней не будет ни одной блокированной записи. 
   Таким образом, пользователь сети может
 - открывать файл БД либо в режиме разделения, либо в монопольном режиме;
 - выполнять блокирование БД, отдельных записей и групп записей; 
блокированные записи и базы доступны по чтению и любому другому 
пользователю;
 - отменять блокирования, которыми владеет;
 - проверять текущий статус блокирования БД или записи БД;
 - проверять успешность выполнения команд USE и APPEND BLANK, примененных
к разделяемой БД (в CLIPPER используется функция NetErr(), возвращающая .F. 
при успехе, в FOXPRO необходим перехват прерывания для обработки ошибки).
   Пользователь, не приобщенный к сети, может оставаться наивным до
самой старости и не учитывать существование сети, ибо по умолчанию СУБД 
открывает БД в монопольном режиме: действует установка SET EXCLUSIVE ON.

          23.2. Выполняем блокирование и разблокирование

    Чтобы открыть БД в монопольном режиме, в команде USE записывают
атрибут EXCLUSIVE, атрибут SHARED назначает режим разделения БД. В
отсутствие данных атрибутов все зависит от глобальной установки: при
установке SET EXCLUSIVE ON все БД открываются в монопольном режиме, а
если действует SET EXCLUSIVE OFF - в режиме разделения. Новая глобальная
установка не может изменить статус ранее открытых БД. Итак, атрибуты
команды USE имеют большую силу, чем глобальная установка. Команда
SET EXCLUSIVE оставлена в языке для совместимости с предыдущими
версиями, но не рекомендуется к использованию, ибо глобальная установка 
- грубое средство управления доступом к данным.
    Функция Flock() пытается блокировать БД, открытую в режиме 
разделения, а Rlock() (другое имя Lock()) - ее текущую запись. Обе 
функции в случае успеха возвращают .T. и отменяют предыдущее блокирование 
в данной БД (если оно было). Для их применения к открытой, но неактивной 
БД в FOXPRO записывают аргумент - алиас БД, а в CLIPPER - уточняют 
алиасом обращение к функции, например: AA->(Lock()). Последнее делают, 
например, при блокировании связанной записи "дочерней БД", ибо 
блокирование "материнской" записи не влечет блокирования "дочерней".
Flock(), использованная, когда нет открытой БД, возвращает .F. .
    Командой UNLOCK пользователь выполняет разблокирование в активной 
БД, а командой UNLOCK ALL - отменяет все свои блокирования, например, 
блокирования записей в "материнской" и во всех "дочерних" БД. Монопольный 
режим не может быть отменен командой UNLOCK. В FOXPRO команду UNLOCK 
можно дополнять атрибутом IN <Обл> (см. п.16.1), т.е. применять к любой 
открытой БД. В CLIPPER для этой цели используют функцию DBUnlock(), 
уточненную алиасом. 
    Функцией Rlock() блокируют одиночную запись перед ее изменением
командами @ ... GET, DELETE, RECALL, REPLACE или путем присваивания
значения полю. Функцию Flock() применяют перед тем, как подвергнуть
аналогичному изменению множество записей. Правда, версия CLIPPER 5.2
и FOXPRO предлагают альтернативу - блокирование группы записей (п. 23.4).
   Для выполнения в разделяемой БД команд PACK, REINDEX, ZAP, MODIFY
 STRUCTURE (FOXPRO), INSERT и INSERT BLANK (FOXPRO) ее надо открыть в
 монопольном режиме, если же БД открыта в режиме разделения, попытка
 выполнить эти команды вызывает сообщение об ошибке.
    Пример 23.1. Примеры блокирования БД в системе CLIPPER
 USE Student EXCLUSIVE
 IF NetErr()         && NetErr возвращает .F. при успешном открытии БД
 @ 24,0 SAY "Придите в следующий раз"                    && --Шутка--
  ELSE
  PACK   && БД успешно открыта и теперь все ждут окончания упаковки БД
  USE                                                && БД закрывается
  ENDIF
 USE Student SHARED        && БД открывается вновь в режиме разделения
  IF .NOT. NetErr() .AND. Flock()           && Попытка блокирования БД
  DELETE FOR Kurs=6  && Если БД захвачена, удаляются записи дипломников
  UNLOCK
  SET INDEX TO IndFam              && Открывается индекс по ключу Famil      
  SEEK "БЕДНЯКОВА"                               && Поиск нужной записи
    IF Found() 
    ELSEIF Rlock() && Только если запись найдена, делается блокирование
     REPLACE Famil WITH "СКОРОБОГАТОВА"
     UNLOCK                    && Запись безотлагательно разблокируется
    ELSE
     @ 24,0 SAY "Изменение фамилии не состоялось; запись занята"
    ENDIF
  ELSE
   USE I:\RabBD            && Для редактирования открывается рабочая БД
   Browse()               && В FOXPRO мы бы использовали команду BROWSE
  ENDIF
   Проанализируем программу. В "шутке" есть серьезный момент: упаковку БД
обычно не делают, когда разделяемые БД используются интенсивно. Полное 
блокирование (монопольный режим) отменяют закрытием БД. После этого ее 
вновь открыли для удаления записей дипломников. Эта работа не срочная; 
если захватить БД не удалось, выполняется следующая работа - замена 
значения поля Famil в одной из записей. Здесь нельзя было объединить 
Found() и Rlock() в одно логическое выражение из-за риска блокирования 
"посторонней" записи (когда Found()=.F.). В принципе Rlock() отменяет 
предыдущее блокирование, однако выше записана команда UNLOCK. Правильно, 
должна быть безусловная отмена блокирования. Ничего - по воле случая! 
   Данный пользователь при неудаче работает с "личной собственностью"
- временной БД RabBD. Чтобы избежать внешних воздействий на такие БД
(например, из-за совпадения имен БД), их хранят на логическом диске 
(здесь - I:), закрытом от посторонних, лучше - в личной директории.
   Задание 23.2. Запишите последовательность действий, производимых в
разделяемой БД и требующих а)монопольного режима; б) блокирования
всей БД; в) блокирования отдельных записей. Производите своевременное
разблокирование.

                   23.3. Выполняем команды в сети

     Кроме указанных выше команд, требующих монополизации БД, 
ряд команд автоматически открывает создаваемые БД в монопольном
режиме (см. табл. 23.1, левая колонка), тогда как ряд других -
открывают имеющиеся БД или файлы в режиме разделения (табл. 23.1,
правая колонка). Речь идет о БД и файлах, имена которых обозначены
в табл. 23.1. После выполнения команды (исключая команду CREATE) БД
закрывается.

                                                  Таблица 23.1
---------------------------------------------------------------------
   Команды, открывающие файл            Команды, открывающие файл
   в монопольном режиме                 в режиме разделения
----------------------------------------------------------------------
 COPY STRUCTURE TO <Имя БД>               APPEND FROM <Имя файла>
 COPY TO <Имя файла>                      CREATE ... FROM <Имя файла>                 
 CREATE <Имя файла>                       LABEL FORM <Имя файла>
 INDEX ON ... TO <Имя файла>              REPORT FORM <Имя файла>
 JOIN ... TO <Имя файла>                  RESTORE FROM <Имя файла>
 SAVE TO <Имя файла>                      TYPE <Имя файла>
 SET ALTERNATE TO <Имя файла>             UPDATE ... FROM <Имя БД>
 SORT ... TO <Имя БД>
 TOTAL ... TO <Имя БД>
-----------------------------------------------------------------------
   Например, вы наверняка не захотели бы, чтобы в ALTERNATE-файл
записывалась посторонняя информация, не имеющая отношения к вашему
диалогу с ЭВМ (пример с монопольным режимом). С другой стороны, было 
бы неразумно лишать пользователей возможности черпать информацию из 
общего источника (режим разделения). Существует другой аспект
проблемы. Возьмем команду REPORT FORM. Если при выводе отчета одним
пользователем другой изменит хотя бы одну запись активной БД,  
используемой как основа отчета, может быть потеряна его
точность, поскольку БД примет некоторое промежуточное состояние.
В FOXPRO имеется установка SET LOCK ON, обеспечивающая автоматическое
блокирование БД, указанных в командах массовой обработки записей
(по умолчанию действует установка SET LOCK OFF). Для других
пользователей доступ к этим БД по чтению - сохраняется. Еще один
пример - сортировка БД. Представьте, что в ее процессе "посторонний"
изменил поле - ключ сортировки хотя бы в одной записи. С большой
степенью вероятности порядок следования записей будет нарушен.
   При автоматическом открытии БД могут быть те же проблемы, что и 
при попытке открыть командой USE базу, которая блокирована. Причины 
неуспешных попыток отражены в табл. 23.2.
                                                       Таблица 23.2
-----------------------------------------------------------------------
 Команда                   Причина  неуспешного  выполнения
-----------------------------------------------------------------------
 USE <БД> SHARED     БД захвачена другим пользователем 
                     (USE <БД> EXCLUSIVE)
 USE <БД> EXCLUSIVE  БД уже открыта и используется
 APPEND BLANK        БД блокирована (Flock() или USE <БД> EXCLUSIVE)
                     или команда APPEND BLANK уже выполняется другим
-----------------------------------------------------------------------
   В примере 23.1 показано, как действовать в CLIPPER, чтобы неуспешная
попытка открытия БД не стала причиной сообщений об ошибке и прерывания 
программы. В CLIPPER имеется блок NetErr. Применим его в случае APPEND
BLANK, отводя 5 секунд для попыток добавления записи в активную БД:
      .   .   .
      T = 5
      APPEND BLANK
      DO WHILE NetErr() .AND. T>0
       Inkey(.5)                           && Эадержка в 1/2 секунды
       T = T -.5
       APPEND BLANK
      ENDDO  && Окончательный итог отражает последнее значение NetErr()
Добавленная запись автоматически остается блокированной и это разумное 
решение, ибо, как правило, ее сразу заполняют, т.е. изменяют значения 
полей.
   Обработка сетевых ошибок в FOXPRO рассмотрена в п. 23.5.
   Имеется ограничение на место задания индексов разделяемой БД. Их не
следует задавать в команде USE - только в команде SET INDEX TO. Дело в 
том, что выполняясь, команда  USE <БД> INDEX <Список индексов>  вызовет 
ошибку, если БД монопольно владеет другой пользователь. Указывая индексы 
в SET INDEX TO, сначала проверяем, состоялось ли открытие БД (см. 
пример 23.1).
    Задание 23.3. Запишите блок вывода отчета по форме "ITOGI" на
основе БД Student, позаботившись о защите БД от записи в нее новых
данных другими пользователями.

        23.4. Осуществляем блокирование группы записей

    В FOXPRO предусмотрена команда SET MULTILOCK <Ключ>, где <Ключ> -
это ON или OFF, включающая (ON) и выключающая (OFF) режим блокирования
множества записей. В режиме "ON" можно использовать функцию Rlock()
(или Lock()) с расширенным синтаксисом:
   Rlock("<Список номеров блокируемых записей>",<Область>),
где опция <Область> -это номер рабочей области или алиас. Например,
для блокирования 3-й, 7-й, 8-й, 9-й записи активной БД записываем
Rlock("3,7,8,9"). Список номеров может быть также значением 
символьных переменной, элемента массива, поля БД. Функция Rlock()
возвращает значение .T. только в том случае, если удалось
блокировать все указанные записи. Блокирования, которые она смогла
выполнить, сохраняются, равно как и блокирования записей, сделанные
до нее.
   Иногда удобнее блокировать группу записей, используя Rlock()
отдельно для каждой записи. Команда SET MULTILOCK всегда снимает
существующие блокирования записей, т.е. перед нею не надо 
выполнять UNLOCK. Число одновременно блокированных записей
ограничивается объемом памяти на сервере. Если подмножество
блокируемых записей велико, блокируют обычно всю БД функцией Flock().
   В версии CLIPPER 5.2 также предусмотрено блокирование групп
записей, используется функция DBRlock(). Текущий список 
блокированных записей возвращает функция DBRLOCKLIST(). Специальные 
режимы блокирования, имеющиеся в FOXPRO, не предусмотрены. Взамен - 
остроумное решение: DBRLock() без аргумента снимает в базе все 
блокирования записей и блокирует текущую запись; DBRlock() с 
аргументом (номер записи) блокирует указанную (хотя бы и текущую - 
укажите Recno()как номер записи) запись и добавляет к списку 
блокированных записей. Функция DBAppend(.T.) снимает блокирования 
записей, добавляет в БД и блокирует пустую запись, DBAppend(.F.), 
добавляя запись, лишь присоединяет  ее к списку блокированных записей. 
Функция DBRUnlock() без аргумента снимает все блокирования записей, 
а если указать аргумент - номер записи, разблокируется только она одна.
    Задание 23.4. Запишите и опробуйте на ПЭВМ 2 варианта программы
блокирования группы записей активной БД: со списком номеров записей
в функции Rlock() и без этого списка.

        23.5. Обрабатываем ошибки при использовании БД в сети

    Применительно к CLIPPER можно говорить про обработку отказов при
блокировании, но в FOXPRO попытка "недозволенного" доступа к 
блокированной БД (код ошибки 108) или блокированной записи (код
ошибки 109) обрабатывается именно как ошибка. Надо иметь в виду,
что эти попытки могут происходить в интерактивном режиме, при
использовании окна команд FOXPRO, т.е. не обязательно в программе.
Для обработки ошибок нужен ERROR-блок, вызываемый командой ON ERROR
(см. п. 22.5). Функции Flock(), Rlock() (Lock()) сами ошибки не
вызывают, ошибки выдаются, когда, не обращая внимания на их
отрицательный результат (.F.), пытаются изменить объект, захваченный
другим. 
  Пример 23.2. Процедура ErrEx обработки ошибок в сети (ERROR-блок).

  PROCEDURE ErrEx
   Er = ERROR()
   DO CASE
    CASE Er = 108 OR Er = 109  && Случай обращения к блокированной БД
     ON KEY LABEL F8 DO Nowait            && или блокированной записи
     DO Ermsg WITH Iif(Er=108,"База","Запись")+" блокирована соседом"
     DO Delay                  && Случайная задержка в пределах 5 с.
     RELEASE WINDOW Ermsg              && Уничтожение окна сообщения
     ON KEY LABEL F8                 && Отмена клавишного назначения
     RETRY                    && Возврат к команде, вызвавшей ошибку
    CASE Er =  ...                  && Случай ошибки с другим кодом
       .  .  .                  && Обработка ошибок с другими кодами
   ENDCASE
PROCEDURE Ermsg
 PARAM Msg
 IF NOT Wexist("Ermsg")                && Проверка существования окна
   DEFINE WINDOW Ermsg FROM 10,5 TO 15,75 TITLE "О Ш И Б К А"
 ENDIF
 ACTIVATE WINDOW Ermsg SAME
 @ 2,3 SAY Msg
 @ 4,3 SAY "Для возврата в главный блок нажмите F8"
   PROCEDURE Delay   && Реализуется задержка случайной длительности
    PRIVATE tfin                           && (в пределах 5 секунд)
    tfin = Seconds() + Rand()*5
    DO WHILE Seconds() < tfin
    ENDDO
PROCEDURE Nowait
 ON KEY LABEL F8
 RELEASE WINDOW Ermsg
 RETURN TO MASTER                           && Возврат в главный блок 
    Применение блока ErrEx рассмотрим на примере 23.1. Предварительно,
например, через окно команд надо выполнить команду ON ERROR DO ErrEx.
В FOXPRO начало программы значительно сократится (ветвление убираем):
   USE Student EXCLUSIVE        && Вызов ERROR-блока происходит здесь
   PACK
   USE
Пока не произойдет захвата БД, блок ErrEx будет возвращать управление
на команду  USE Student EXCLUSIVE. Если по прошествии времени 
пользователь, отчаявшись, нажмет F8, управление получит команда PACK
и также выдаст ошибку, обработка которой в тексте блока ErrEx не показана.
Далее управление получит USE - она не вызовет каких-либо действий, а
затем делается попытка открыть БД в режиме разделения и блокировать ее:

   USE Student SHARED          && Вызов ERROR-блока происходит здесь
   IF Flock()
     .  .  .
   Снова возможны многократные попытки открыть БД. Если будет нажата 
F8 (базу так и не открыли), Flock() возвратит .F. и следующая работа 
также будет пропущена. В завершение программы будет использоваться
команда BROWSE. Читателю предлагается проверить полученную FOXPRO-
программу.
   Задание 23.5. Действуя с 2 рабочих станций, промоделируйте захват,
а затем - полное блокирование БД Student с 1-й станции. На 2-й станции
запустите программу примера 23.1 с учетом необходимых изменений.
Изучите обработку ошибок блоком ErrEx в различных ситуациях
блокирования.

       23.6. Выполняем захват базы данных или записи
            в условиях конкуренции. Транзакции

    В п. 23.5 на примере блока ErrEx показано, как осуществить
многократные попытки получмть доступ к БД. В FOXPRO есть особая
команда  SET REPROCESS TO <ВырN> SECONDS, позволяющая задать
число <ВырN> попыток или время, в течение которого они будут
предприниматься (если справа от <ВырN> слово SECONDS, <ВырN>
обозначает число секунд). Диапазон значений <ВырN> - от 1 до 32000.
Успех попытки или нажатие Esc отменяют дальнейшие попытки. В ходе
выполнения команда выводит на дисплей сообщение о выполняемых
попытках блокирования. Успешная попытка приводит к исчезновению
сообщения.
     Если попытки блокирования осуществлялись функцией Flock()
или Rlock() (Lock()), их значение .T. отразит конечный успех.
Если нажата Esc или все попытки исчерпаны без результата,
значением функции является .F. .
    ERROR-блок имеет приоритет в том смысле, что отказ в
открытии БД немедленно вызывает выполнение ERROR-блока (без
повторения автоматических попыток открытия БД). Функции блокирования 
не вызывают ERROR-блок.
    Команда SET REPROCESS имеет вариант SET REPROCESS TO AUTOMATIC
(или SET REPROCESS TO 0), снимающий ограничение на число попыток.
Клавиша Esc попрежнему осуществляет их отмену. В варианте
SET REPROCESS TO -1 ("максималистском") блокируются действие Esc
и выход на ERROR-блок. Если при этом варианте команды попытки будут 
безуспешны, придется перезагружать ПЭВМ.
   Минусом команды является единое решение для всей программы.
В CLIPPER предлагается набор из 4 функций, образующих файл
LOCKS.PRG, который надо подключать командой SET PROCEDURE TO.
Функции RecLock(<ВырN>) и FilLock(<ВырN>) в течение <ВырN>
секунд выполняют попытки захвата записи или файла БД
соответственно. Функция NetUse("<Имя БД>",<Режим>, <ВырN>) в
течение <ВырN> секунд пытается открыть файл <Имя БД> в
монопольном режиме (<Режим> = .T.) или режиме разделения
(<Режим>) = .F.). Наконец, функция AddRec(<ВырN>) в течение
<ВырN> секунд пытается добавить пустую запись в активную БД.
   Итак, неудачу (отказ) в открытии БД, блокировании БД или записи 
БД пытаются преодолеть повторением попыток открытия (блокирования) в 
течение некоторого времени или до внешнего прерывания (Esc). При 
"полной неудаче" можно переключиться на обработку других данных, а 
затем вновь попытаться получить желанный объект. Наиболее просто 
это осуществить в децентрализованных FOXPRO-программах, основой 
которых является меню с подключенными к нему блоками, если в них 
предусмотрена реакция на отказы.
    Транзакции. Все решалось бы проще, не будь транзакций -
логических единиц работы, выполнение которых даже на 99 %
равносильно невыполнению. Представьте две БД: "Продажи"
и "Покупатели", в которых покупатели обозначены кодом
покупателя. Если мы заменяем некоторый код покупателя, то
сделать это должны в каждой БД. Допустим, это сделано лишь в
одной из них, а другая - была захвачена извне и возник тупик.
Данные потеряли целостность.
    Существуют два подхода к транзакциям. Первый: сначала
получить все необходимые блокирования (в нашем примере -
блокировать обе БД) и лишь затем выполнять обработку.
Второй: разметить в программе участки, соответствующие
транзакциям; при невозможности завершить начатую транзакцию
производить "откат" к началу участка и аннулировать эффект
начатой транзакции. Заметим, что выделение транзакций
необходимо и для процедур восстановления после аварийного
прекращения работы программы.
    Задание 23.6. Опробуйте различные варианты команды
REPROCESS TO на модели, рассмотренной в задании 23.5.

                   ЗАКЛЮЧЕНИЕ К ГЛАВЕ 23

    Незнание законов не освобождает от ответственности. Хотя
бы поэтому данную главу надо было прочесть тем, кто собирается
работать в сети ПЭВМ. Кроме знания, нужна этика. С этикой
"пещерного человека" можно работать на ПЭВМ в одиночку, но не
в сети. Для более детального рассмотрения сетевых проблем,
например, проблемы транзакций, обращайтесь к [4, 8] и другим
источникам.
