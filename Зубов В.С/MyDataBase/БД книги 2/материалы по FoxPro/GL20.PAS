                            ГЛАВА 20.
             СОВЕРШЕНСТВУЕМ ИНТЕРФЕЙС ПОЛЬЗОВАТЕЛЯ

    Две предыдущие главы создали предпосылки для рассмотрения типовых
средств интерфейса, на разработку которого нередко тратится большая
часть времени программиста. Рассматриваемые в данной главе решения
"в стиле WINDOWS" позволяют интегрировать в единый просто управляемый
интерфейс объекты разного назначения: кнопки 4 типов, вертикальные
меню, области редактирования, BROWSE-таблицы. При этом не исключаются
сложные логические связи между объектами, их перестройка и перенастройка.

                20.1. Назначаем командные клавиши

    В удобном для пользователя интерфейсе, кроме системы окон и 
меню, бывают задействованы клавиши-команды. Их нажатие влечет
выполнение закрепленных за ними команд, обычно это обращения к блокам
выполнения типичных операций. Назначение клавиш показывают в 
отдельной строке (или строках) экрана (окна) - клавишном табло.
Например, такой строкой может быть <ВырC> в опциях TITLE<ВырC> и
FOOTER<ВырC>. Клавишу пробела будем обозначать как Space.
    Команды ON KEY, ON ESCAPE. Команда  ON KEY <Команда>  назначает
выполнение <Команды> при нажатии любой клавиши. ON ESCAPE <Команда>
назначает <Команду> "персонально" клавише Esc, если действует
установка SET ESCAPE ON (установка по умолчанию). Отмену этих
назначений производят команды ON KEY, ON ESCAPE без аргументов.
Новое назначение отменяет предыдущее.
    Команда  ON KEY =<ВырN> <Команда>  назначает <Команду> клавише
с INKEY-кодом (см. п.1.8, приложение 4), равным <ВырN>. Действует
лишь одно такое назначение - последнее, т.е. активна одна клавиша.
    "Неразборчивость" команды ON KEY легко поправима. Пусть это
будет команда ON KEY Do Proc. Процедуру Proc строим по схеме
   PROCEDURE Proc
   Key = LastKey()
   DO CASE
      CASE Key = <INKEY-код1>
     <Действия, предусматриваемые для клавиши с INKEY-кодом1>
      CASE Key = <INKEY-код2>
     <Действия, предусматриваемые для клавиши с INKEY-кодом2>
        .  .  .
   ENDCASE
    Команда ON KEY LABEL. Она записывается следующим образом:
ON KEY LABEL <Имя клавиши> <Команда>.  В отличие от вышерассмотренных
команд командами ON KEY LABEL можно активировать несколько клавиш
с различным действием. Имя клавиши, например PGUP, CTRL+END, ALT+E, 
совпадает с принятыми обозначениями. Регистр букв безразличен.
Любая кнопка мыши обозначается MOUSE, левая (правая) кнопка -
LEFTMOUSE (RIGHTMOUSE). Пример: ON KEY LABEL CTRL+X DO XXX.  В табл. 
20.1 даны обозначения клавиш, отличные от изображенных на них символов.
                                                       Таблица 20.1    
----------------------------------------------------------------------
   К л а в и ш а       И м я           К л а в и ш а      И м я
----------------------------------------------------------------------
 Стрелка влево       LEFTARROW        Shift+Tab          BACKTAB
 Стрелка вправо      RIGHTARROW           {              LBRACE
 Стрелка вверх       UPARROW              }              RBRACE
 Стрелка вниз        DNARROW          Пробел             SPACEBAR
----------------------------------------------------------------------
    Назначенные клавиши действуют не только в состоянии ожидания.
 Случайное их нажатие может прервать какой-либо процесс и вызвать
 неуместное выполнение назначенной команды, например, вызов
 вспомогательного блока. Чтобы этого не происходило, следует
 своевременно отменять их назначения.
    Отмена клавишных назначений. Стек назначений. "Индивидуальную"
отмену реализует команда ON KEY LABEL <Имя клавиши>. Чтобы разом
отменить все назначения, используют команду ON KEY (см. выше).
Отмену назначений рекомендуется осуществлять при том объекте, к
которому они "приписаны". Например, при выходе из окна нужно
выполнять соответствующий блок выхода, в начале которого - отмена
назначений клавиш. Команда  PUSH KEY CLEAR  запоминает в стеке
текущие назначения. Если указан атрибут CLEAR, то одновременно
они отменяются. Восстановление назначений, хранимых в стеке, 
выполняет команда POP KEY ALL. Если дан атрибут ALL, восстановлению
предшествует отмена всех текущих назначений. Стек (именно стек)
используется потому, что блок может вызвать поблок, а подблок -
другой подблок, и в каждом из них - свои назначения клавиш.
Хранимые в стеке назначения извлекаются в порядке, обратном
запоминанию, что соответствует порядку возврата из блока в блок.
    Пример 20.1. 
  <Назначение клавиш в главном блоке>
    .  .  .
  DO Proc1                                && Вызов процедуры Proc1
    .  .  .     && Здесь вновь действуют назначения главного блока
  PROCEDURE Proc1
   PARAM <Параметры>
   PUSH KEY CLEAR               && Отмена назначений главного блока  
   <Назначение клавиш, действующих в Proc1>
    .  .  .
   DO Proc2
    .  .  .
   ON KEY     && Окончательная отмена назначений, сделанных в Proc1        
    .  .  .
   POP KEY              && Восстановление назначений главного блока
  RETURN                         && Возврат в главный блок из Proc1
  PROCEDURE Proc2
   PARAM <Параметры>
   PUSH KEY CLEAR           && Отмена назначений, сделанных в Proc1
   <Назначение клавиш, действующих в Proc2>
    .  .  .
   ON KEY                       && Отмена текущих назначений клавиш
    .  .  .
   POP KEY          && Восстановление назначений, сделанных в Proc1
  RETURN                                    && Возврат в блок Proc1

    Данный простой пример служит иллюстрацией следующих идей: 
 "ответственность" за восстановление клавишных назначений несет 
 блок, который их на время отменял. Он должен отменять собственные
 назначения (своевременно). Если они действуют до конца его работы,
 команды ON KEY, POP KEY можно заменить одной: POP KEY ALL.
    Отмена и восстановление отдельного назначения клавиши. Функция
ON ('KEY',<Имя клавиши>) возвращает символьную строку - запись
назначенной команды. Ее можно запомнить, затем отменить назначение,
а там, где данное назначение надо восстановить, применить команду  
ON KEY LABEL с макроподстановкой.
    Использование функции READKEY() при редактировании. Функция
READKEY() возвращает число, используемое для опознания клавиши,
нажатой при выходе из команд  APPEND, BROWSE, CREATE, EDIT (CHANGE),
INSERT, MODIFY и READ. Напоминаем, что выход из READ может произойти
по клавише "стрелка вверх" ("стрелка вниз") при попытке покинуть первое
(последнее) GET-поле. Тот же эффект вызовет клавиша PgUp (PgDn).
В таблице 20.2 показаны всевозможные клавиши выхода и для каждой
даны 2 числа: числитель представляет число, возвращаемое, если
изменений данных не было, знаменатель - если они произошли.
                                                 Таблица 20.2
-----------------------------------------------------------------
 Клавиша выхода     Код возврата   Клавиша выхода    Код возврата
----------------------------------------------------------------
<-, Ctrl+H, Ctrl+S      0/256            Esc            12/268
  ->, Ctrl+L            1/257      Ctrl+W, Ctrl+End        270
      Home              2/258           Enter           15/271
      End               3/259       Опция TIMEOUT       20/276
      Tab               5/261         Ctrl+Home         33/289
      PgUp              6/262         Ctrl+PgUp         34/290
      PgDn              7/263         Ctrl+PgDn         35/291
      Ctrl+<-           8/264             F1            36/292
-----------------------------------------------------------------
    Рассмотрим простой учебный пример применения Readkey().
    Пример 20.2. В зависимости от содержания текущей записи ее
данные обрабатываются блоком Obr или она помечается на удаление,
или в ней очищается поле Pr. Для выполнения действия будем
покидать окно редактирования, завершая READ клавишами Ctrl+Home
(переход к блоку Obr), Ctrl+PgUp (пометка на удаление), Ctrl+PgDn
(очистка поля Pr в записи), Enter (переход к очередной записи),
End (завершение всего процесса). Необходим цикл, включающий команду 
BROWSE.
 USE Student
 DO WHILE .T.
   BROWSE NOWAIT ;
 TITLE "Ctrl+Home-обработка,Ctrl+PgUp-удаление,Ctrl+PgDn-очистка Pr"
   READ
   Key = Readkey()
   DO CASE
      CASE Key = 15 .OR. Key = 271             && Для клавиши Enter
      SKIP
      CASE Key = 33 .OR. Key = 289          && Для клавиш Ctrl+Home
      DO Obr
      CASE Key = 34 .OR. Key = 290          && Для клавиш Ctrl+PgUp
      DELETE
      CASE Key = 35 .OR. Key = 291          && Для клавиш Ctrl+PgDn
      REPLACE Pr WITH Space(5)
      CASE Key = 3 .OR. Key = 259                && Для клавиши End
      EXIT                                                 && Выход из цикла
   ENDCASE
  ENDDO
  USE                        && Закрытие базы и удаление BROWSE-окна
     PROCEDURE Obr
     ? Famil                                   && Имитация обработки
    
     Задание 20.1. Реализуйте заново пример 20.2, используя функцию
LastKey() вместо ReadKey(). Значения INKEY-кодов даны в Приложении 3.

           20.2. Изучаем средства интерфейса в стиле WINDOWS

     GET-команды позволяют создавать так называемые WINDOWS-объекты:
кнопки-переключатели, невидимые, текстовые и селективные кнопки,
радио-кнопки, меню-списки, скрытые POPUP-меню. Рассмотрим используемые
в них опции GET-команд.
    Опция DEFAULT <Выр> создает и инициализирует GET-переменную (не
являющуюся элементом массива, полем БД) с числовым или символьным
значением <Выр>, если она не была создана ранее. Еще большие
возможности для символьной GET-переменной создает функция M в GET-
шаблоне. Она имеет вид  M <Список строк>. В GET-поле предъявляется
1-я строка из списка, если GET-переменная ранее не получила значения. 
Нажимая клавишу пробела, можно "прокрутить" <Список строк> в GET-поле. 
Остановив выбор, вы нажимаете Enter, и видимая строка становится значением
GET-переменной. Пример: @ 3,3 GET Sezon PICTURE "@M Зима,Весна,Лето,Осень".
    В опции VALID предусмотрено использование как <ВырL>, так и
<ВырN>, причем значение <ВырN>, равное 0, препятствует выходу из GET-поля.
Если <ВырN> - функция пользователя, она должна не только возвращать 0
в случае обнаружения ошибки, но и сообщать о ней, ибо автоматическая
выдача сообщения не предусмотрена. Значение <ВырN>, большее (меньшее)
нуля, означает продвижение на <ВырN> GET-полей вперед (назад) по
отношению к данному GET-полю. Выход за рамки последовательности
GET-полей означает завершение работы READ. Отдельно изображаемые
элементы (кнопки, пункты меню) WINDOWS-объектов рассматриваются как
отдельные GET-поля.
    Опция SIZE <ВырN1>, <ВырN2>, <ВырN3> создает нестандартное GET-поле
- "окошко" высотой <ВырN1> и шириной <ВырN2> (число строк и число
столбцов). <ВырN1> запрещено опускать, даже если высота жестко задана
в системе: записывают любое число. <ВырN3> задает промежуток между
элементами составных WINDOWS-объектов, например, кнопками. По умолчанию
в вертикальном измерении он равен 0, а в горизонтальном - 1.
    Опция DISABLE (ENABLE) запрещает (разрешает) доступ к GET-полю,
например к WINDOWS-объекту, пока не будет дана команда 
SHOW GET <Переменная> ENABLE (SHOW GET <Переменная> DISABLE). Таким
образом, работая с одним WINDOWS-объектом, вы можете управлять
доступностью других с помощью функций пользователя, содержащих
указанные команды.
    Ниже повсеместно используется опция PICTURE (сокращение - PICT),
но вместо нее или наряду с нею можно использовать и опцию FUNCTION.
    Вид WINDOWS-объекта задают символами-определителями в самом начале 
GET-шаблона (в опции PICTURE после знака @). В таблице 20.3 даны
символы-определители и ключи-опции, идущие за ними. Имеются следующие
ключи: T (N) - выбор в WINDOWS-объекте завершает (не завершает)
работу команды READ; H (V) - элементы размещаются по горизонтали (по
вертикали). Ключи N, V обычно действуют по умолчанию, однако для
большей наглядности будем их записывать. Возможны комбинации ключей:
TH, NV и т.п. Следующими в GET-шаблоне, после обязательного пробела, идут
строки-приглашения (если они используются). Приглашения разделяются
знаком ";". В них могут быть "горячие" буквы, их обозначают знаками 
\< слева от буквы. Знаками \\ (слева) обозначают приглашения, которые 
не могут быть выбраны.
                                                    Таблица 20.3
-------------------------------------------------------------------
           WINDOWS-объект            Определитель  Допускаются ...
-------------------------------------------------------------------
Кнопка-переключатель (Check Boxes)       *С       N,T; \<, \\
Невидимые кнопки (Invisible Buttons)     *I       H,V; N,T; \\
Текстовые кнопки (Push Buttons)          *        H,V; N,T; \<, \\
Селективные кнопки (Radio Buttons)       *R       H,V; N,T; \<, \\
Скрытое POPUP-меню (Popups)              ^        N,T; \<, \, \\
Списки меню (Lists)                      &        N,T
-------------------------------------------------------------------
    Осуществляя в WINDOWS-объекте выбор, пользователь воздействует
на значение GET-переменной и, напротив, исходное ее значение 
определяет начальное визуальное состояние WINDOWS-объекта.
Значение GET-переменной используется для управления (обработки),
например в структуре DO CASE, либо ниже команды READ (если выбор
заканчивает работу READ), либо в пользовательской функции опции
VALID. Условимся выделять опции, обязательные в определяемом объекте.
    Кнопка-переключатель (Check Boxes) на экране выглядит как
    [X] <Приглашение>          или        [ ] <Приглашение>
(слева показано ее включенное состояние, ибо X - символ-подтверждение).
<Приглашение> не обязательно. Кнопку создает команда
        @ Y,X GET <Переменная> PICT<ВырC> <Опции> ,
Исходное состояние кнопки зависит от значения <Переменной>, которая
может быть числовой (0 или 1) или логической. Значения 1, .T. 
соответствуют включенному состоянию. Нажатия клавиши Enter или Space,
кнопки мыши, "горячей" буквы приглашения переключают кнопку в
противоположное состояние: X заменяется пробелом и наоборот.
Если переключать кнопку не нужно, на очередной GET-объект переходят
с помощью клавиши управления курсором или мыши.
     Пример 20.3. Создадим кнопку  [ ] НАПРАВЛЕНИЕ НА ЗАЧЕТ ВЫДАНО .
@ 5,8 GET Napr PICT '@*CT  \<НАПРАВЛЕНИЕ НА ЗАЧЕТ ВЫДАНО' DEFAULT 0
 READ               && Без команды READ активизации кнопки не будет
    Невидимые кнопки (Invisible Buttons) создает команда
@ Y,X GET<Переменная> PICT<ВырC> SIZE<ВырN1>,<ВырN2>,<ВырN3> <Опции>,  
определяющая одну или несколько областей экрана (кнопок) 
размером <ВырN1> x <ВырN2> (по умолчанию размер кнопки 0 х 0). 
Текущая область выделена цветом. При переходе к очередной кнопке (с 
помощью клавиши управления курсором или мыши) этот цветовой маркер 
перемещается, "накрывая" следующую область. До выполнения команды 
READ на эти области можно наложить тексты и их ограничить. И напротив, 
для имеющегося рисунка, схемы, пиктограммы можно сделать подходящие 
описания областей (кнопок), чтобы выбор тех или иных действий стал 
нагляднее.
    У невидимых кнопок "невидимые приглашения": в GET-шаблоне
изображаются лишь разделители ";". По их числу определяется число
кнопок. Их надо отделять пробелом от символа-определителя *I (от
букв-ключей, если они есть). Пример: PICT "@*IH ;;\\". Показано
создание линейки из трех кнопок, причем последняя недоступна.
Для запрещения доступа ко второй кнопке знаки \\ нужно было бы
поставить между знаками ";".
    Фиксируя выбор кнопки, нажимают Space (маркер на ней остается)
или Enter (маркер переходит на следующую кнопку), при этом GET-
переменная получает значение номера выбранной кнопки.
    Пример 20.4. Выведем линейку из 4 кнопок, имеющих размер 3 х 5,
изобразив на них цифры 2, 3, 4, 5. Выбор первой кнопки запретим.
Переходы между кнопками "зациклим" (опция CYCLE в команде READ).

* Блок Cena имитирует обработку выбора
* Для выхода из READ нажимайте клавишу Esc
@ 5,3 GET k PICT "@*IH \\;;;" SIZE 3,5,3 DEFAULT 1 ; &&"1"- значение k
            VALID Cena()  MESSAGE "НАЗНАЧЬ СЕБЕ ОЦЕНКУ"
@ 6,5 SAY "2       3       4       5"   && Надписи в областях кнопок
@ 5,3 TO 7,7                                && Обрамление 1-й кнопки
@ 5,11 TO 7,15                              && и всех
@ 5,19 TO 7,23                              && следующих
@ 5,27 TO 7,31                              && кнопок
  READ CYCLE
  FUNCTION Cena
   @ 9,0                                       && Очистка 9-й строки
   @ 9,1 SAY "ПОЛУЧАЙ"
   DO CASE
      CASE k=2                                        && Выбрана "3"
      @ 9,10 SAY "ПЯТЕРКУ"
      CASE k=3                                        && Выбрана "4"
      @ 9,18 SAY "ЧЕТВЕРКУ"                           
      CASE k=4                                        && Выбрана "5"
      @ 9,26 SAY "ТРОЙКУ"
   ENDCASE
  RETURN           && Отсутствие выражения равносильно возврату .T.
    Чтобы сделать невидимые кнопки разного размера и произвольного
положения, их задают отдельными GET-командами. "Сквозную нумерацию"
описанных таким образом кнопок обеспечивает программист.
    Следующие две GET-команды определяют две колонки кнопок (оформление
не показываем). Чтобы имитировать их сквозную нумерацию, в блок F
обработки выбора вторая GET-команда передает номер k, увеличенный
на число кнопок левого столбца:
  @ 5,3 GET k PICT "@*I ;;" SIZE 3,5,1  DEFAULT 1  VALID F(k)
  @ 5,9 GET k PICT "@*I \\;;" SIZE 3,8,1  DEFAULT 1  VALID F(k+3)
Первая кнопка 2 столбца сделана недоступной для выбора. Чтобы
сделать одну из кнопок кнопкой выхода из READ, ее нужно определять
отдельной GET-командой, указав в GET-шаблоне ключ T: PICT "@*IT".
    Задание 20.2. Постройте пиктограмму - домик с трубой, окнами,
дверью, опишите невидимые кнопки, области которых совпадают с "трубой",
"окном", "дверью", и запишите программу, выводящую слова "труба",
"окно", "дверь" при выборе соответствующих кнопок. Проще всего
пиктограмму изобразить в конструкции TEXT ... ENDTEXT, используя
символы псевдографики.

           20.3. Используем команды READ CYCLE, SHOW GETS.
                   Текстовые и селективные кнопки

    Опция CYCLE в команде READ препятствует выходу из команды, когда
обработан последний (первый) GET-объект и задано перемещение к GET-
объекту с несуществующим большим (меньшим) номером. Происходит
переход к первому (последнему) GET-объекту. Это позволяет осуществлять
обработку многих записей БД или многих элементов массива без внешнего
цикла. Нужно лишь позаботиться о фактическом переходе к очередной
записи (новому элементу) и обновлении GET-полей. Последнее выполняется
командой SHOW GETS для GET-объектов активной команды READ, находящихся
в указанном окне или во всех задействованных ею окнах.
    GET-команды - определения текстовых и селективных кнопок во 
многом сходны. Например, GET-переменная может быть как символьной, 
так и числовой. В 1-м случае выбор кнопки ведет к занесению в GET-
переменную текста приглашения, а во 2-м - номера выбранной кнопки. 
Выбор кнопки производят клавишей Space или Enter (см. выбор невидимой 
кнопки в п. 20.2). Первоначально маркер находится на 1-й кнопке.
    Опция SIZE (см. п.20.2) необязательна, ибо высота кнопки - 1, 
а длина определяется длиной приглашения. С помощью опции SIZE можно 
задать большую длину, например "подравнять" кнопки, и увеличить 
промежутки между ними.
    С текстовыми ("триггерными") кнопками вы знакомы по системным
меню: таковы кнопки <OK>, <Cancel>. Их ограничивают угловые скобки.
Пример указания кнопок: PICT "@*H OK;Cancel". Если бы они были 
селективными, нужно было бы лишь вставить символ R после знака *.
    Особенности текстовых кнопок. В отличие от селективных кнопок 
по умолчанию действует ключ T, т.е. выбор кнопки завершает работу 
READ. Одна из кнопок может быть Escape-кнопкой, выбираемой 
клавишей Esc. Ее приглашение надо начинать знаками \?.  Также 
единственной может быть скобка по умолчанию (начальные знаки ее 
приглашения \!), выбираемая клавишами Ctrl+Enter. Она выделяется 
двойными угловыми скобками.
    Пример 20.5. Построим следующее меню с Escape-кнопкой <ВЫХОД>:
  <СОЗДАНИЕ МАССИВА>  <ОБРАБОТКА>  <<ВЫВОД МАССИВА>>  <ВЫХОД>

@ 5,9 GET k DEFAULT 1  VALID F() ;  && Блок F в примере не показан
   PICT "@* \<СОЗДАНИЕ МАССИВА;\<ОБРАБОТКА;\!ВЫВОД МАССИВА\?ВЫХОД"
READ
    Для двух первых кнопок назначены "горячие" буквы С, О, третья
- сделана кнопкой по умолчанию. Кнопка <ВЫХОД> здесь означает
отмену действий, ибо выход из READ произойдет при нажатии любой
кнопки (при этом будет выполнен блок F обработки выбора). Если 
предполагается поочередное использование нескольких кнопок, то
"долгоиграющее" меню создается с ключом N, а возможность выхода из 
READ обеспечивают клавиши (табл. 20.2) или команда в блоке F.
    Селективные (радио-) кнопки изображаются в виде  
 ( )<ПРИГЛАШЕНИЕ>,  причем <Приглашение> не обязательно. Может быть 
"нажатой" лишь одна из них (как и клавиша автомобильного 
радиоприемника - отсюда и название "радио-кнопки"). "Нажатие", т.е.
выбор кнопки отображается появлением точки в ее изображении (т.е. в 
скобках). Отмечена точкой может быть лишь одна кнопка, а первоначально
отмечена кнопка, номер или приглашение которой совпадает с исходным
значением GET-переменной. Если присутствие точки нежелательно, 
задавайте нулевое исходное значение. По умолчанию действует ключ N.
    Пример 20.6. Создадим линейку кнопок ( )2  ( )3  ( )4  ( )5
с целью занесения выбранной в ней оценки как экзаменационной в
текущую запись студента. Фамилия студента высвечивается в том же
окне (экране). Для продвижения по БД будем использовать текстовые
кнопки <Вперед>, <Назад>. Общее число полученных двоек, троек,
четверок, пятерок будет занесено в элементы M[1],M[2],M[3],M[4]
соответственно.
SET TALK OFF
DECLARE M[4]
M = 0                                    && Установка счетчиков в 0
USE Student
ACCEPT "Введите имя поля БД " TO Name  && Имя поля для хранения оценки
CLEAR
@ 3,15 SAY "ПРЕДМЕТ:  "+ Name    && Имя поля обозначает дисциплину   
@ 5,10 SAY "Фамилия и.о.:  " GET Famil WHEN .F.
@ 7,10 SAY "Оценка: " GET k PICT "@*RH 2 ;3 ;4 ;5 " DEFAULT 0 VALID F()
@ 9,25 GET L PICT "@*NV \<Вперед;\<Назад;\<Конец" DEFAULT 1 VALID G()
READ CYCLE
? M[1],M[2],M[3],M[4]   && Вывод числа двоек, троек, четверок, пятерок
 FUNCTION F
 REPLACE &Name WITH k+1                   ПРЕДМЕТ:  PHYSICS
 M[k] = M[k] + 1                  
 RETURN 5-k                        Фамилия и.о.  Бендер-Задунайский О.Э.
 FUNCTION G                        Оценка:  ( ) 2  (.) 3  ( ) 4  ( ) 5
   DO CASE                                    
   CASE L=1                                     <Вперед>
   SKIP                                         <Назад> 
   CASE L=2                                     <Конец>
   SKIP -1
   CASE L=3                                     && Для кнопки "Конец"
   CLEAR READ                         && Выход из неявного цикла READ
  ENDCASE 
  k = 0                       && Подготовка к показу следующей записи
  SHOW GETS       && Обновление GET-полей при переходе к новой записи    
 RETURN 3
     Программа требует пояснений. Предусловие .F. запрещает вход
курсора в поле Famil - нам там делать нечего. После выбора оценки 
маркер пришлось бы перемещать, пропуская оставшиеся селективные кнопки.
Мы избежали этого, указав переход в GET-поле "Вперед" с помощью
возвращаемого значения блока F (оно на 1 больше числа пропускаемых 
полей). Аналогичный прием применен при выборе текстовой кнопки: с
помощью значения 3, возвращаемого функцией G, указан переход к 3-му
GET-полю относительно текущего. В отсутствие опции CYCLE произошел бы
выход из READ, а в данном случае мы попадаем на поле Famil
(пропускаемое) или сразу на кнопку "2". 
     Чтобы не высвечивать точку ( ), пока не выставлена оценка, в
опции DEFAULT задана "нулевая" кнопка. Однако при переходе к записи
следующего студента эта точка не исчезнет, если мы не позаботимся о 
нулевом значении k в блоке G.
     Специальная команда CLEAR READ реализует выход из неявного цикла
READ, когда L = 3, т.е. выбрана кнопка <Конец>.
     Задание 20.3. Запишите программу с определениями селективных
кнопок "Понедельник", "Вторник", "Среда", "Четверг","Пятница" и
текстовых кнопок <1 смена>, <2 смена> (всего используйте 2
GET-команды). Программа после пометки селективной кнопки и выбора
текстовой должна выполнить "обработку": вывод текстов приглашений
этих 2 кнопок.


       20.4. Используем скрытые POPUP-меню и списки-меню.
                    Области редактирования

    POPUP-меню называется скрытым, если лишь один его пункт
предъявлен на экране, в "окошке". Когда требуется, меню раскрывают
полностью, наводя на него курсор и нажимая Enter или Space. Пункты
меню могут быть заданы как приглашения в опции PICT (см. выше).
    Необычно "поведение" GET-переменной, которая может быть числовой 
или символьной. Ее исходное значение задает номер пункта (число)
или текст пункта (символьное значение), предъявляемого в "окошке".
Если такого текста нет в списке пунктов, он добавляется в меню как
последний (временный) пункт. Для раскрытия меню нажимают Enter или
Space. Когда в раскрытом меню произведен выбор, GET-переменная 
принимает значение (номер или текст) выбранного пункта, который
остается на экране (в "окошке").
    Скрытое POPUP-меню формируется командой
@ Y,X GET<Переменная> PICT<ВырC> FROM<Массив> RANGE<ВырN1>,<ВырN2> <Опции>
Команда формирования списка-меню, кроме иного символа-определителя,
может содержать дополнительно опцию POPUP <Имя POPUP-меню>.
    Пример 20.7. 
  k = "Залкинд Е.Е."             && Ниже формируется скрытое меню
  @ 6,8 GET k PICT "@^ Галкин А.А.;Малкин Б.Б.;Палкин В.В.;Чалкин Д.Д."
  READ
    В "окошке" появится текст "Залкинд Е.Е.", рассматриваемый как
последний пункт меню, основное содержание которого - в опции PICT.
Опция SIZE не обязательна, ибо высота <ВырN1> игнорируется, а
ширина <ВырN2> определяется по умолчанию самым длинным пунктом.
    Пункты скрытого меню и списка-меню могут быть заданы в массиве. 
Это более гибкий вариант, так как и пункты, и их число можно изменять. 
В опции RANGE <ВырN1> указывает элемент, с которого начинается меню, а
<ВырN2> обозначает число используемых элементов. По умолчанию
одномерный массив используется полностью, а в двумерном - используется
1-й столбец. Для двумерного массива <ВырN1> записывают как приведенный
индекс (см. п. 15.5) элемента. В этом случае используется столбец
массива с указанным элементом.
    Обратимся к примеру 20.6 с целью модернизации программы.
Запишем двумерный массив, в первом столбце которого названия
числовых полей БД, а во втором - названия соответствующих предметов:
             Physi          ФИЗИКА
             Chemi          ХИМИЯ
             Matem          МАТЕМАТИКА.
Будем выводить в скрытое меню 2-й столбец, а элементы 1-го - 
использовать в макроподстановке команды REPLACE (см. программу 
примера 20.6). Теперь пользователь избавлен от необходимости 
ввода, интерфейс стал нагляднее, а однострочное меню не 
загромождает экран.
DECLARE M[5], A[3,2]
M = 0
A[1] = "Physi"             && Здесь вместо приведенного индекса можно
A[2] = "ФИЗИКА"                && использовать номер строки и столбца
A[3] = "Chemi"
A[4] = "ХИМИЯ"
A[5] = "Matem"
A[6] = "МАТЕМАТИКА"
SET TALK OFF
CLEAR
USE Student
@ 1,55 GET i PICT "@^" FROM A RANGE 2 DEFAULT 1  && Приведенный индекс 2
READ
@ 3,15 SAY "ПРЕДМЕТ:  "+ A[i,2]
@ 5,10 SAY "Фамилия и.о.:  " GET Famil WHEN .F.
@ 7,10 SAY "Оценка: " GET k PICT "@*RH 2 ;3 ;4 ;5 " DEFAULT 0 VALID F()
@ 9,25 GET L PICT "@*NV \<Вперед;\<Назад;\<Конец" DEFAULT 1 VALID G()
READ CYCLE
? M[1],M[2],M[3],M[4]   && Вывод числа двоек, троек, четверок, пятерок
 FUNCTION F
 REPLACE &A[i,1] WITH k+1  && Занесение оценки в поле с именем &A[i,1]
 M[k] = M[k] + 1
 RETURN 5-k   && Блок G нами не показан, ибо он не претерпел изменений

    Списки-меню. Эти меню предъявляются на экран или путем активации
GET-командой ранее описанного POPUP-меню, или путем вывода списка
пунктов из указанного массива. Достаточно в последней программе
заменить в GET-шаблоне символ ^ на символ & и вместо скрытого меню
получится список-меню. В принципе, GET-шаблон не обязателен, но
только в нем можно указать ключ T.
    Как и в скрытых меню, тип исходного значения GET-переменной
определяет характер возвращаемого значения: номер выбранного пункта
или текст пункта. Если исходное значение не соответствует ни одному
пункту меню, при активации меню выделения пункта маркером нет.
    В случае активации POPUP-меню опция   SIZE <ВырN1>,<ВырN2>
задает размеры области экрана, отводимой для меню (при использовании
массива "работает" лишь значение <ВырN2>, определяя ширину области).
Две строки и два столбца занимает рамка. Координаты и размер POPUP-
меню, заданные в GET-команде имеют преимущество перед соответствующими
опциями команды DEFINE POPUP.
   Подобная активация POPUP-меню органично встраивает меню в общий
интерфейс (где могут быть и другие POPUP-меню), управляемый с помощью
READ. Активируемое меню рассматривается как один GET-объект.
   Пример 20.8. Создадим в левом верхнем углу экрана список-меню из
имен БД, хранимых в текущей директории, ограничив окно 15 строками.
Для выбора действия с БД применим текстовые кнопки.

DECLARE A[3]
A[1] = "EditBD"                          && Имя блока редактирования
A[2] = "CopyBD"                          && Имя блока копирования
A[3] = "IndBD"                           && Имя блока индексирования
DEFINE POPUP BD PROMPT FILES LIKE *.DBF MARGIN    && Меню из имен БД
CLEAR
@ 0,2 SAY "Список баз данных"
@ 1,2 GET k POPUP BD SIZE 15,10 DEFAULT ""   && Активируем POPUP-меню
@ 4,30 GET j PICT "@* \<РЕДАКТИРОВАНИЕ;\<КОПИРОВАНИЕ;\<ИНДЕКСИРОВАНИЕ" ;
  DEFAULT 1  VALID F()
READ
RELEASE POPUPS BD
  FUNCTION F   && Блок активации выбранной БД и запуска подпрограммы
  USE(k)
  DO &A[j]
  RETURN
PROCEDURE EditBD                              && Процедура-"заглушка"
? "Редактируем БД"
PROCEDURE CopyBD                              && Процедура-"заглушка"
? "Копируем БД"
PROCEDURE IndBD                               && Процедура-"заглушка"
? "Индексируем БД"

    Области редактирования. Создание выделенной цветом области экрана 
для редактирования MEMO-поля или символьных полей БД, элементов 
массива, переменных реализует команда, использующая такие же опции, 
как и GET-команды, активируемая, как и они, командой READ:
  @ Y,X EDIT <Переменная>   SIZE <ВырN1>,<ВырN2>, <ВырN3>   <Опции>,
где <Переменная> обозначает редактируемый объект, <ВырN1>,<ВырN2> -
высоту и ширину области, необязательное выражение <ВырN3> - число 
символов от начала текста, которые разрешается редактировать.
    Опция TAB записывается в команде, если нажатие клавиши Tab должно
вставлять в текст символ табуляции (по умолчанию этого не происходит).
    Для выхода из редактирования с сохранением изменений нажимают
Tab или, если указана опция TAB, Ctrl+Tab. При нажатии Esc изменения
не сохраняются, кроме одного случая: при выходе из редактирования
MEMO-поля VALID-контроль сообщает об ошибке, а вы нажимаете Esc, 
игнорируя предупреждение.
    <Переменная> рассматривается как GET-объект, она должна получить 
значение до команды EDIT или ее значение указывают в опции DEFAULT. 
Например, если <Переменная> прежде не существовала и текст ее заранее 
не известен, можно записать опцию DEFAULT Space(1). 
    Длина текста может превосходить величину <ВырN1>*<ВырN2>:
используется вертикальная прокрутка. Переход на новую строку при
наборе текста выполняется автоматически, хотя это можно сделать и
клавишей Enter. Не забывайте команду SET MEMOWIDTH TO. По умолчанию
текст выровнен по левому краю. Для выравнивания по правому краю
записывают опцию FUNCTION "J", а для центрированного расположения
текста в строках - FUNCTION "I".
   В EDIT-области работает текстовый редактор, по умолчанию действует
режим вставки; клавиша Ins активна. Опция SCROLL имеет тот же смысл, 
что и в команде DEFINE POPUP (см. п. 19.4), опция NOMODIFY разрешает 
только просмотр текста. Опции DISABLE, MESSAGE, ERROR, COLOR, WHEN, 
VALID - такие же, как в GET-командах.
    Задание 20.4. Запишите программу с GET-командой создания меню,
пункты которого определены массивом, EDIT-командой для редактирования
текста выбранного пункта, командой READ CYCLE и VALID-функцией 
пользователя, подключенной к EDIT и содержащей команду SHOW GETS (для 
обновления строк меню на экране).

      20.5. Знакомимся с интерфейсом, управляемым событиями

    Систему, использующую GET-команды, команды BROWSE, SHOW GETS
(GET), READ с расширенным синтаксисом, назовем расширенной GET-
системой. Развитый интерфейс реагирует на успех (неуспех) выполняемых
пользователем действий, существование условий их реализации, выбор
того или иного варианта работы и т.п. При этом может быть запрещен
(разрешен) доступ к тем или иным элементам (кнопкам, пунктам
меню) и объектам, изменяться цветовое оформление, расположение окон,
количество и содержание приглашений и т.д.
    В отсутствие расширенной GET-системы интерфейс, управляемый
событиями, реализуется с помощью программных циклов, "улавливающих
эти события". Получаются громоздкие программы с запутанной логикой,
трудные для понимания и отладки. Благодаря функциям пользователя
в GET-системе реализация интерфейса упрощается.
    Рекомендуется "охватывать" одной командой READ совместно
используемые окна, активируя их по следующей схеме:
    ACTIVATE WINDOW <1 окно>
    <SAY- и GET-команды "в стиле WINDOWS">
    ACTIVATE WINDOW <2 окно>
    <SAY- и GET-команды "в стиле WINDOWS">
        .    .    .
    READ <Опции, например CYCLE>.
Это одно "измерение" интерфейса, второе - глубина вложения READ:
функции пользователя, вызываемые в GET-системе, в свою очередь
могут содержать GET-системы (говорят о вложении команд READ).
Допускается максимум 5 уровней вложения READ. Функция RDLEVEL()
возвращает номер текущего уровня (нумерация - с 1); 0 означает
отсутствие активных READ.
    Все GET-объекты, "обслуживаемые" одной командой READ, включая
EDIT-области, нумеруются (с 1) в порядке порождения безотносительно 
к размещению в окнах. При этом обособленные элементы типа кнопок 
получают индивидуальные номера, даже если созданы одной GET-командой.
Номер первого (или единственного), объекта порожденного GET-
командой, возвращает функция OBJNUM(<GET-переменная>, <ВырN>);
необязательное <ВырN> обозначает уровень READ, отличный от 
текущего. Значением системной переменной _CUROBJ является номер
текущего объекта. И напротив, изменяя _CUROBJ, мы провоцируем
переход к соответствующему объекту.
    Отслеживать события и воздействовать на интерфейс можно
"грубыми" и "тонкими" средствами. Начнем с первых. В команде
READ можно указывать WHEN- и VALID-условия. Если значение
WHEN-условия равно .F., команда READ пропускается, т.е. GET-система
не активируется. Это может быть, например, вложенная команда
READ, "услуги" которой пока не понадобились. VALID-условие
проверяется при попытке выхода из READ. Если его значение .T.,
происходит выход, в противном случае курсор остается в GET-системе,
пока не будут выполнены действия, обеспечивающие значение .T..
Возможность "силового решения" есть всегда: его обеспечивают
команда CLEAR READ и клавиши (табл. 20.2).
    Вариант VALID<ВырN> предполагает хитроумное использование
GET-объектов: если <ВырN> совпадает с номером одного из них,
происходит возврат к этому GET-объекту, иначе - выход из READ. Как
и в других случаях, опции WHEN и VALID могут быть уловкой для
выполнения предварительной и заключительной обработки, ибо
<ВырN> или условие <ВырL> могут быть обращением к функции. 
Для отдельных окон, "охваченных" READ, аналогичную роль
играют опции ACTIVATE <ВырL> и DEACTIVATE <ВырL> команды READ,
используемые соответственно при входе в окно (и в начале
работы READ), при выходе из него. Вы знаете, что и в GET-
командах имеются опции WHEN и VALID.
    Обновление объектов на экране и изменение режима доступа
(разрешен, запрещен) обеспечивает команда SHOW GETS - "грубый
инструмент". Она распространяет действие на все объекты или
находящиеся в <Окне>, если задана ее опция WINDOW <Окно>.
Запрещение (разрешение) дальнейшего доступа к объектам с целью 
редактирования или применения в управлении (кнопки) обеспечивает
опция DISABLE (ENABLE) этой команды. Это новое состояние может быть
временным. Обновление объектов может выполняться стандартным образом
или быть "оригинальным" (соответственно указывают ONLY или OFF).
Последнее обеспечивается за счет функции пользователя,
указываемой в опции SHOW <ВырL> команды READ, а используемой
по команде SHOW GETS. В отсутствие ONLY и OFF  используется как
обновление по умолчанию, так и функция пользователя (если она
задана в опции SHOW команды READ).
    При желании командой SHOW GETS можно изменять и цветовое
оформление объектов, указывая опцию COLOR. Если опцией
LEVEL<ВырN> указан уровень команды READ, будут обработаны
объекты не текущего, а заданного уровня команды READ. 
    Те же опции, кроме WINDOW, OFF, ONLY, имеют команды,
являющиеся "тонким инструментом" и влияющие на состояние
отдельного объекта:
SHOW OBJECT <ВырN>, где <ВырN> - номер GET-объекта,  и
SHOW GET <GET-переменная>, <ВырN>, где необязательное <ВырN>
указывает относительный номер объекта, если соответствующая
GET-команда породила не единственный объект. Дополнительная опция
PROMPT<ВырC> позволяет заменить текст приглашения кнопки новым
текстом <ВырC>.
    Порядок активации GET-объектов. По умолчанию GET-объекты
активируются в порядке возрастания номеров за исключением объектов
  а) запрещенных опцией DISABLE в GET-команде или в SHOW GETS;
  б) запрещенных символами \\ в приглашении (запрещенные кнопки);
  в) имеющих значение .F. WHEN-условия GET-команды;
  г) пропускаемых при "скачкообразном" увеличении номера
очередного объекта опцией VALID, как в примере 20.6.
    Кроме того, опцией OBJECT<ВырN> команды READ можно задать
номер <ВырN> первого активируемого объекта, а опцией VALID
GET-команды и команды READ - возврат к объекту с меньшим номером.
   Перемещения в GET-системе. Для завершения работы с GET-объектом
или его пропуска, можно нажать, кроме Enter, клавишу "стрелка вниз"
или Tab, что обеспечит движение в сторону больших номеров. Клавиши
"стрелка вверх", Shift-Tab служат для движения в обратную сторону.
При этом физическое положение GET-полей не имеет значения,
например, "стрелкой вниз" вы переходите в GET-поле, реально
размещенное выше. Опция CYCLE команды READ (см. п. 20.3) обеспечивает
"круговой" переход от объекта с наибольшим номером к первому
и наоборот, препятствуя выходу из READ при перемещении по объектам.
   Активация окна является зависимой: ее автоматически вызывает
активация любого объекта этого окна, а переход к объекту другого
окна вызовет деактивацию текущего. При этом соответственно
срабатывают функции, указанные в опциях ACTIVATE, DEACTIVATE
команды READ. Для отслеживания оконных переходов используют
оконные функции (см. гл. 18).  
    Мышь позволяет произвольно переходить из окна в
окно и активировать объекты в любом порядке. Объект выбирают
щелчком мыши после наведения ее маркера на GET-поле. Если важна
последовательность активации, можно опцией NOMOUSE запретить
выбор объектов мышью; перемещения с помощью мыши в GET-поле
при этом не запрещены.
    Интерактивный доступ можно ограничить окнами, "охваченными"
READ, указав опцию MODAL. Активация прочих окон блокируется.
Смягчение этого запрета обеспечивает опция команды READ
   WITH <Список доступных окон, кроме "охваченных" READ>
(в этом случае MODAL не указывают). Хотя BROWSE-таблицы не являются
GET-объектами, включение их в общий интерфейс бывает необходимо.
Это делают по схеме
       <Определения окон>
        USE <БД1>
        BROWSE WINDOW<Окно1> NOWAIT  ...
        USE <БД2>
        BROWSE WINDOW<Окно2> NOWAIT  ...
              .   .   .
        <SAY- и GET-команды>
        READ WITH <Окно1>,<Окно2>, ...
   Опцию WITH указывают, только если нужно ограничить множество
доступных окон, ибо BROWSE-окна доступны и по умолчанию, когда
активна READ.
    Задание 20.5. После изучения примера 20.6, усложняя базу
данных и программу (расширяя возможности), добавляя окна и
управляющие элементы, опробуйте команды и опции, рассмотренные
выше. Используйте мышь.

              20.6. Пример построения интерфейса     

     Рассмотрим простейшую справочную систему для поездной бригады,
позволяющую наблюдать план любого вагона, где отражены занятые и
свободные места, заносить (и исключать) в базу сведения о пассажирах,
вести учет действующих мест (например, если разбито окно в купе,
места исключаются). Место обозначается составным номером: первые
2 цифры - номер вагона, последние - собственно номер места.
    Окно Vagon, куда выводится план вагона, отражает содержание
БД Pass, в которой 5 полей:

      Поле     Имя поля    Тип              Содержание
       1       Famil        C     Фамилия пассажира или "пусто"
       2       Mest         C     Занимаемое место
       3       Stat         C     Станция назначения или "пусто"
       4       X            N     Координата места на плане
       5       Y            N     Координата места на плане

    Если место свободно, оно показано зеленым квадратом с номером
места, иначе - синим. Положение квадрата определяют координаты X,Y.
Значения первых 3 полей предъявляются в BROWSE-окне Pass.
    Для каждого типа вагона в БД Plan предусмотрена запись с
единственным MEMO-полем Plan, например, 1-я запись содержит план
купейного вагона (К), 2-я - план плацкартного (П) и т.д. Состав
поезда отражает строка S, например "1П;2П;3П;4К;5К; ... ;15П", где
буквы обозначают тип, а цифры - номера вагонов.
    Для выбора вагона и вывода его плана используется скрытое меню
ВАГОН. Его пункты заданы строкой S, в которую добавлен пункт "КОНЕЦ",
выбираемый для завершения работы. Ниже показана схема купейного вагона.





В ней номера в верхнем ряду обозначают верхние полки, в следующем -
нижние. На номера накладываются невидимые кнопки (для раскраски мест и
фиксации текущего места). Окрашена бывает лишь одна невидимая кнопка
из совместно созданных. Чтобы закрасить все, создадим их отдельными
выполнениями GET-команды в цикле. Для наглядности нами прорисованы
контуры кнопок, отсутствующие в плане.
    Проследим работу приводимой ниже программы, в которой действует
двухуровневая GET-система: на первом уровне - меню ВАГОН, на втором
- множество кнопок-мест, BROWSE-окно Pass и кнопка возврата в меню
ВАГОН. После открытия БД и описания окон создается скрытое меню
ВАГОН. Нужно предъявить пользователю интерфейс в целом на примере
1 вагона. Требуется дважды нажать Enter. Эти нажатия имитирует
команда KEYBOARD, а "отрабатывает" - команда READ. Первое нажатие
раскрывает меню, а второе - осуществляет выбор в нем. При этом
включается блок Vg, получающий как параметр подстроку "1П". Он
анализирует тип вагона, считывает в окно Vagon соответствующий
план и выполняет в БД Pass первой записи, соответствующей данному
вагону. Затем в цикле SCAN просматриваются все записи для данного
вагона. Команда GET использует координаты X,Y из записи для
порождения кнопки, состояние поля Famil - для ее раскраски, а
если запись помечена на удаление (недействующее место), кнопка
делается недоступной (символы " \\" в GET-шаблоне). После цикла
команда READ CYCLE второго уровня активирует первую доступную
кнопку, при этом включается блок Kto, куда передается номер d
вагона и номер места. Последний совпадает со значением _CUROBJ,
т.е. с номером GET-объекта, кнопки, но требуется текстовая форма,
состоящая из 2 символов.
    Блок Kto выводит BROWSE-окно (неактивное), причем в верхней
строке показывается номер текущего места и сведения о пассажире,
если место занято. Это обеспечено командами SEEK d+m и BROWSE.
Нажимая Enter или клавиши управления курсором, пользователь
перемещается по плану и, соответственно, перемещаются строки в
окне BROWSE. Через кнопку по умолчанию (см. п. 20.3) <<ПЕРЕХОД
К ДРУГОМУ ВАГОНУ>> можно вернуться на 1-й уровень GET-системы,
чтобы выбрать иной вагон и т.д. Это все, что нужно бригадиру поезда.
Проводнику в трех случаях приходится активировать окно Pass:
а) при занесении фамилии нового пассажира и станции назначения;
б) при стирании данных о пассажире; г) для пометки недействующего
места или снятия пометки. Окно Pass активируется (деактивируется)
нажатием CTRL+F1. Стирание поля выполняют клавиши CTRL+Y,
пометку на удаление (снятие пометки) - клавиши CTRL+T. Когда
измененная запись покидается, команда BROWSE включает функцию F,
выполняющую обновление соответствующей кнопки: изменяется ее
цвет.
    При возврате в окно Vagon активируется кнопка по умолчанию -
возврат на 1-й уровень GET-системы. В этом есть резон: не все
изменения статуса мест вагона оперативно находят отражение в окне
и повторный выбор того же вагона оказывается кстати. При возврате
в окно Vagon с помощью мыши, вы можете активировать любую кнопку.
Кнопка по умолчанию необязательна: нажимая Esc, пользователь
также возвращается на 1-й уровень, но если замешкается и Esc
сработает дважды, программа "скоропостижно" закончит работу.
"Легитимное" завершение деятельности пользователь осуществляет,
выбирая пункт "Выход" меню ВАГОН.

s="1П;2П;3П;4П;5К;6К;8К;9К;10К;11К;12П;13П;14П;15П;ВЫХОД"
SET TALK OFF
SET MEMOWIDTH TO 57
SET COLOR OF SCHEME 17 TO,,,,,W+*/G,,,W+/G
SET COLOR OF SCHEME 18 TO,,,,,W+*/B,,,W+/B
CLEAR
USE Pass
IF .NOT. File("Pass.IDX")
INDEX ON Mest TO Pass
ELSE
SET INDEX TO Pass
ENDIF
USE Vagon IN b
DEFINE WINDOW Pass FROM 1,18 TO 11,62
DEFINE WINDOW Vagon FROM 14,10 TO 23,69 TITLE "ПЛАН ВАГОНА" ;
 FOOTER "ДЛЯ ИЗМЕНЕНИЙ В ОКНЕ PASS  НАЖМИТЕ CTRL+F1"  COLOR SCHEME 10 
@ 5,0 SAY "ВАГОН:" GET k PICT "@^ "+ S VALID Vg(k) ; 
  DEFAULT Left(S,At(";",S)-1)   MESSAGE""
@ 12,18 SAY "      ВОЗВРАТ К ПЛАНУ ВАГОНА - CTRL+F1       " COLOR N/BG
KEYBOARD Chr(13)+Chr(13)         && Имитация 2 нажатий клавиши Enter
READ CYCLE
  FUNCTION Kto
  PARAM d,m
  SEEK d+m
  BROWSE WINDOW Pass NOWAIT COLOR SCHEME 10  TITLE "МЕСТА ВАГОНА "+d ;
   FIELD U=Right(Mest,2):H="Место":P="9999", Famil:H="   Фамилия":14,;
   Stat:H="    Станция":20  VALID F()
  FUNCTION F
     SHOW OBJECT _CUROBJ  COLOR SCHEME Iif(Empty(a.Famil),17,18)
  FUNCTION Vg
  PARAM i
  ACTIVATE WINDOW Vagon
  IF k="ВЫХОД"
  CLEAR ALL
  CLEAR
  CANCEL
  ENDIF
  @ 2,0 CLEAR
  GO Iif(Right(i,1)="K",1,2) IN b
  ?? b.PLAN   && Вывод в окно Vagon схемы, соответствующей типу вагона
  d= PAdl(Ltrim(Str(Val(i))),2,"0")         && Выделение номера вагона
  SEEK d                  && Поиск первой записи для выбранного вагона
  IF Recno() > Reccount()
   @ 0,30 SAY "В БАЗЕ НЕТ ТАКОГО ВАГОНА !" COLOR W+/R*
  ELSE
   SCAN WHILE a.Mest = d
  @ a.Y,a.X GET Z PICT "@*I"+Iif(Deleted()," \\","") SIZE 1,2 DEFAULT 1;  
    When Kto(d,Padl(Ltrim(Str(_CUROBJ)),2,"0")) ;
    COLOR SCHEME Iif(Empty(a.Famil),17,18)
   ENDSCAN
  @ 0,2 SAY " МЕСТО СВОБОДНО     " COLOR W+/G     && Образец закраски
  @ 1,2 SAY " МЕСТО С ПАССАЖИРОМ " COLOR W+/B     && Образец закраски
  @ 0,30 GET j PICT "@*\! ПЕРЕХОД К ДРУГОМУ ВАГОНУ" ;
    MESSAGE "ДВАЖДЫ НАЖМИТЕ ENTER ДЛЯ АКТИВАЦИИ МЕНЮ <<ВАГОН>>" ;
   COLOR ,,,,,W+*/GR,,,W+/N DEFAULT 1
   READ CYCLE
  ENDIF
    Создание баз данных. В БД Plan единственное поле Plan. Заполнение
этих MEMO-полей проще всего производить в Edit-области, ширина
которой соответствует ширине плана вагона и должна быть предварительно
указана в команде SET MEMOWIDTH TO. Итак, полагаем БД Plan созданной.
     БД Pass в исходном состоянии должна содержать столько записей,
сколько мест в поезде, причем поля Mest, X, Y должны быть заполнены.
Это большая рутинная работа, которую легко автоматизировать: выберем
в меню вагон для вывода плана в EDIT-область (см.п. 20.4). Будем
поочередно подводить курсор под каждый номер в плане и запускать блок
YX, использующий текущие оконные координаты Row(), Col() курсора.
Они нужны, во-первых, для заполнения полей Y,X очередной записи.
Во-вторых, они позволяют выделить в MEMO-поле Plan подстроку - номер
места, под которым стоит курсор. Присоединив слева номер вагона,
блок YX заносит значение в поле Mest. Этот номер стирается во
избежание повторного выбора. Поскольку портить план мы не должны,
в команде EDIT предусматривается опция NOMODIFY и изменения
происходят в копии плана. Во избежание повторного выбора вагона
соответствующий пункт меню должен становиться недоступным.
    Для вызова блока YX мы предусмотрим клавишу, например F5.
Ее придется нажать более 1000 раз. Проявим смекалку и здесь.
Число записей для однотипных вагонов одинаково и отличаются они
лишь старшей частью поля Mest. Сделаем так, чтобы нажатие F5
формировало записи для всех однотипных вагонов. Это несложно.
Разработать блок YX, используя как подспорье программу PLAN.PRG,
приведенную на с. 281 в [7], предлагается читателю.
    Задание 20.6. Разработайте интерфейс, используемый в процессе
заполнения БД Pass, который описан выше.

                       ЗАКЛЮЧЕНИЕ К ГЛАВЕ 20

    В данной главе рассмотрены "полуфабрикаты" - различные
функциональные средства интерфейса, которые понадобятся для
создания экрана приложения. Простые выбор объектов экрана и
управление ими обеспечивают "максимально дружественный"
пользовательский интерфейс. В п. 21.5 мы рассмотрим средства,
"дружественные" разработчику экрана, позволяющие создавать образ
экрана почти без программирования. Освоиться с ними вам помогут
представления, полученные при чтении настоящей главы.
