                          В В Е Д Е Н И Е

                     Реляционная модель данных

     В системе "Пользователь - данные - ЭВМ" действуют внешняя,
концептуальная и внутренняя модели данных (МД) и определены отображения
"внешняя МД -> концептуальная МД", "концептуальная МД -> внутренняя МД".
Внутренняя, приближенная к технической среде МД включает метод доступа
к данным и другие детали. Внутренняя МД может изменяться, например,
вследствие изменения типа ЭВМ, тогда изменяется и отображение 
концептуальной МД.
     Внешняя МД обращена к пользователю, абстрагируется от особенностей
реализации данных на физическом уровне, описывается зачастую в терминах
исследуемой предметной области. Внешняя МД может быть частичной (не
все категории данных "видны", предоставлены пользователю) и отражать
субъективный характер восприятия. В зависимости от уровня пользователя
могут применяться те или иные средства внешних МД. Типы операций над
данными также включаются в МД.
     Занимающая промежуточное положение концептуальная МД представляет
содержание баз данных в несколько абстрактной форме по сравнению с
формами физического хранения данных. Различают 3 основных варианта
концептуальной МД: иерархический, сетевой и реляционный. Реляционные
базы данных доминируют в силу простоты и однородности МД. Итак, внешнее
представление данных неоднозначно, концептуальная МД может быть любой
и не зависит от внутреннего представления данных и их связей, методов
доступа, будучи реализуема в ЭВМ любых типов.
    Концепция реляционной МД предложена Е.Коддом в 1970 г. В ее основе
- математическое понятие отношения. Таблица данных, в которой строка
описывает отдельный экземпляр из заданной предметной области ("экземпляр
сущности") и в каждом столбце которой размещаются значения одного
свойства (атрибута) экземпляров, наглядно представляет объектное
отношение. Ключом называют совокупность атрибутов, однозначно
идентифицирующую строки (говорят об уникальности значений ключа).
    Укажем признаки, позволяющие считать таблицу данных отношением.
 1. В таблице нет строк с совпадающими ключами (строки уникальны).
 2. В каждой строке - значения одного и того же набора атрибутов.
 3. Значения атрибутов "атомарны", неразложимы. Это означает, что
отношения не могут быть элементами отношения.
    Связное отношение устанавливает связи сущностных экземпляров. Оно
содержит ключи двух или более объектных отношений (внешние ключи),
устанавливая связь экземпляров. Каждому значению внешнего ключа в
связном отношении обязательно соответствует строка объектного
отношения (каждая ссылка реальна; это свойство называют ссылочной
целостностью). Например, строка Табельный номер - Номер отдела
содержит 2 внешних ключа и свидетельствует о принадлежности
сотрудника (экземпляр сущности) указанному отделу (экземпляр иной
сущности). Строки связного отношения могут содержать также факты
(атрибуты), относящиеся к данной связи, например, продолжительность
работы сотрудника в отделе.
     Применительно к реляционным базам данных соответствие уровней
"внешний - концептуальный - физический" отражает следующая таблица:
--------------------------------------------------------------------
   Уровень     │       Соответствие терминов разных уровней
--------------------------------------------------------------------
 Предметный    │   Сущность  │ Экземпляр сущности │   Свойство
 Математический│   Отношение │      Кортеж        │   Атрибут
 Базы данных   │   Таблица   │  Строка таблицы    │ Столбец таблицы
 Физический    │   Файл      │      Запись        │   Поле записей
--------------------------------------------------------------------
     Пример 1.
   Сущностью является коллектив из 200 сотрудников фирмы, экземпляром
- личность сотрудника. Возьмем кортеж атрибутов <Фамилия - Имя -
Дата рождения - Адрес - Пол>. Каждый такой кортеж в таблице представлен
строкой. Число кортежей (строк таблицы) называют мощностью
отношения (здесь 200), число атрибутов в кортеже (столбцов таблицы) -
степенью отношения (здесь 5). Определяя отношение, будем записывать
              <Имя отношения> (<Кортеж атрибутов>).
  Все кортежи отношения должны быть попарно различимы. Если допустить,
что в коллективе могут быть не только однофамильцы-тезки, но и
совместно проживающие родственники, то в данном объектном отношении А
в качестве ключа придется использовать совокупность первых четырех
атрибутов. Термин "ключ" распространим на соответствующий набор полей
записи. В исключительных применениях, когда содержание записи в целом
может быть не уникальным, условимся дополнительно использовать в ключе
порядковый номер записи. Ключ, состоящий из одного атрибута, прост в
использовании. Например, можно добавить в отношение А табельный номер
сотрудника (уникален) и сделать ключом.
  Допустим, в нем имеется еще атрибут "Спорт", включающий сведения о
виде спорта, которым занимается сотрудник, и спортивной квалификации.
Нарушено требование атомарности. Атрибут заменяют двумя: "Вид спорта"
и "Спортивная квалификация", т.е. отношение приводят к так называемой
первой нормальной форме (1НФ).
  Операции над отношениями. К отношениям применимы пять операций над
множествами: объединение, пересечение, разность, декартово произведение,
деление, - и три специальные операции: проекция, соединение и выборка.
Выделим некоторое подмножество атрибутов отношения. Проекция отношения
на вектор этих атрибутов формирует отношение меньшей степени и,
зачастую, меньшей мощности, так как кортежи-дубликаты исключаются.
Например, проекция отношения А на вектор <Фамилия - Адрес> - это
таблица фамилий сотрудников с их адресами, в которой совместно
проживающие однофамильцы, например родственники, отражены одной строкой:
           │ Сидоренко Анна  1965  ул.1 залпа "Авроры",1,7  Жен
Исходная   │ Сидоров Андрей  1952  52-я ул.Строителей,12,9  Муж
           │ Сидоров Павел   1947  2-й Комм. тупик, 8,43    Муж
 таблица   │ Сидоренко Петр  1972  ул.1 залпа "Авроры",1,7  Муж
           │ Сидоров Юрий    1975  52-я ул.Строителей,12,9  Муж  
                    │ Сидоренко  ул.1 залпа "Авроры",1,7 │
        Проекция    │ Сидоров    52-я ул.Строителей,12,9 │
                    │ Сидоров    2-й Комм. тупик. 8,43   │
    Соединение двух отношений A, B по выделенному атрибуту выполняется
через конкатенацию каждой пары их кортежей, имеющих одно и то же
значение атрибута. Если некоторое значение атрибута используется в N
кортежах 1-го отношения и M кортежах 2-го отношения, то в отношении-
результате появится N*M кортежей (столько пар <кортеж A - кортеж B>
для данного значения). Таким образом, мощность отношения-результата
может быть значительно большей, чем мощность A и B.
    Пример соединения отношений. Кроме A, имеется отношение B,
содержащее другие атрибуты сотрудников. В нем, как в A, используется
табельный номер и атрибуты "Вид спорта", "Хобби", "Любимые животные".
Соединение по табельному номеру дает отношение со сводной характеристикой
сотрудников. Кроме соединения по равенству, возможны операции соединения
по любому условию, проверяемому для пары кортежей из A,B.
     Операция выборки по заданному условию, примененная к отношению,
дает отношение меньшей или равной мощности путем отбора в него
кортежей, удовлетворяющих этому условию.
     Возможно совместное использование операций, например, проекция
выполняется одновременно с выборкой. Рассмотренная система операций
позволяет получать искомые отношения из других, что ограничивает
объем хранимых данных при всем разнообразии используемых отношений.
    Итак, реляционная модель базы данных (БД) определяется
совокупностью изменяемых во времени нормализованных отношений
различных и, возможно, изменяющихся мощностей и степеней.
"Изменение во времени" предполагает операции включения, удаления
и изменения кортежей.
    Реляционные СУБД действуют с реляционными БД, используя, по
меньшей мере, проекцию, соединение и выборку в операциях над БД [1].

      2. Функциональные зависимости. Нормализация отношений

     Здесь мы коснемся проблемы совершенствования модели создаваемой
БД. В БД должны обеспечиваться поддержание целостности
(непротиворечивости и корректности) данных в ходе обновления,
простое обновление данных, защищенность от несанкционированного 
доступа к данным, удобные средства восстановления при сбоях, приемлемые 
затраты памяти и быстродействие. Идеального решения может и 
не быть, но от выбранной модели зависит степень приближения к нему.
    Совершенствование модели БД идет путем нормализации отношений.
Здесь ключевым понятием является функциональная зависимость атрибутов.
Далее для краткости будем опускать слово "функциональная". Атрибут B
функционально зависит от A, если в любой момент времени значению
атрибута A соответствует одно определенное значение B. Например,
от ключа зависит каждый неключевой атрибут. Действительно, любое
значение ключа может встретиться лишь в одной записи, и для него
различных вариантов значений прочих атрибутов - просто нет. При
составном ключе атрибут может зависеть и от его части, тогда
говорят о частичной зависимости. Если атрибут зависит только от
ключа в целом, говорят о полной зависимости.
    Пример 2. Возьмем отношение  C (Поставщик, Товар, Город, Факс,
Телефон, Стоимость транспортировки, Объем поставки) с составным
ключом <Поставщик + Товар>. Имеется зависимость атрибутов поставщика
<Город, Факс, Телефон, Стоимость транспортировки> от части <Поставщик>
ключа, что ведет к дублированию данных, если Поставщик поставляет не
один Товар (эти данные содержат все кортежи для данного Поставщика). 
Возникает также проблема контроля избыточных данных, так как изменение 
любого из указанных атрибутов придется производить во всех кортежах 
для данного Поставщика.
    Сделаем проекцию на вектор атрибутов, исключив частично зависимые.
Получаем из C отношение D (Поставщик, Товар, Объем поставки). Кроме
того, сделаем проекцию на вектор, состоящий из части ключа и зависимых 
от нее атрибутов. Получаем из C отношение E (Поставщик, Город, Факс, 
Телефон, Стоимость транспортировки) с сокращением избыточности данных. 
Отгошения D и E используются вместо C.
     Данное преобразование, исключающее частичную зависимость
атрибутов, называют приведением отношений ко 2-й нормальной форме (2НФ).
Если таких зависимостей не было, отношение изначально было в 2НФ.
     В отношении E атрибут <Стоимость транспортировки> зависит от
ключа не прямо, а через зависимость от атрибута <Город> (транзитивно).
Полагая одинаковой стоимость транспортировки одной тонны любого груза,
мы вновь сталкиваемся с избыточностью данных: в данном <Городе> может
быть не один поставщик и во всех кортежах с одинаковым значением <Город>
стоимость одна и та же. Возьмем проекцию F отношения E на атрибуты
<Город, Стоимость транспортировки> и его проекцию G на все атрибуты,
кроме зависимого от ключа транзитивно. Заменим E отношениями F и G.
Подобное преобразование отношения, находящегося в 2НФ, исключающее
в с е  транзитивные зависимости неключевых атрибутов от ключа, называют
приведением отношения к 3-й нормальной форме (3НФ).
     Заметим, что проведенные преобразования позволяют иметь в БД
данные о потенциальных поставщиках и городах, в которых (пока) нет
поставщиков данного клиента. Наличие этой информации может быть
важным для пользователя БД. В исходных отношениях возможна ее утрата.
Если некий поставщик прекратил, возможно, временно поставки,
информация о нем в отношении C не сохраняется (ключ должен быть
полностью определенным, пустые его части запрещены).
     Итак, нормализация отношений - это процесс пошаговой декомпозиции
(разложения) исходных отношений на более простые с целью устранения
нежелательных зависимостей атрибутов, а вместе с тем - избыточности
данных, и уменьшения вероятности аномалий при работе с БД. 3НФ более
совершенна, чем 2НФ, а 2НФ совершеннее 1НФ.
     Пример 3.
  Сущностью является школа подготовки абитуриентов вуза.
Особенности: репетитор готовит лишь по одному предмету, но преподавать
его могут несколько репетиторов. Абитуриент имеет одного репетитора по
каждому предмету. Эта информация нужна для определения зависимостей.
Рассмотрим отношение H (Абитуриент, Предмет, Репетитор). Возможный ключ
<Абитуриент, Предмет> (эти сочетания уникальны). Из условия примера
вытекает, что часть <Предмет> зависит от неключевого атрибута <Репетитор>. 
Возникающая проблема не нова: если какой-либо репетитор остался без 
обучаемых, теряется информация о том, что именно он может преподавать. 
Выполняем проекции отношения H на векторы <Абитуриент, Репетитор> и 
<Репетитор, Предмет>, получая усовершенствованную 3НФ. В ней выполнено 
требование: любой атрибут (возможно, составной), от которого зависит 
другой атрибут, может быть ключом. Оно не было выполнено в исходном
отношении H, ибо для него атрибут <Репетитор> возможным ключом 
не является. 
     Атрибут X многозначно определяет атрибут Y, если с каждым значением
X может использоваться Y из фиксированного подмножества значений Y. 
Например, в вузе каждый курс могут читать преподаватели из четко
определенного подмножества преподавателей. Считаем, что их подготовка
"универсальна", т.е. любой раздел курса может быть прочитан любым из
них. Тогда в кортежах <Курс, Преподаватель, Раздел курса> атрибут <Курс>
многозначно определяет атрибуты <Преподаватель> и <Раздел курса>. Эти
независимы, ибо раздел курса и преподаватель жестко не связаны.
   Пример 4.
   Рассмотрим первые кортежи отношения J (Предмет, Лектор, Раздел):
             <Физика, профессор Иванов, Оптика>
             <Физика, профессор Попов, Механика>
             <Физика, профессор Иванов, Механика>
             <Физика, профессор Попов, Оптика>
Та же информация содержится в кортежах двух проекций отношения J:
        <Физика, Оптика>          <Физика, профессор Иванов>
        <Физика, Механика>        <Физика, профессор Попов>
Сокращение избыточности данных было бы более впечатляющим при увеличении
группы преподавателей и большем количестве разделов.
     Приведение отношения к 4НФ заключается в его разложении на 
проекции с тем, чтобы в каждой оказалась лишь одна многозначная
связь из связей атрибутов с одним и тем же ключом.
     Все рассмотренные преобразования (приведения к НФ) обратимы,
т.е. по проекциям - результатам разложения - можно восстановить исходное 
отношение. Существуют также 5НФ, 6НФ, 7НФ [2,3].
     Нормализация отношений проводится после разработки исходной
МД ("принципиальной"), в которой каждой "сущности" соответствует
объектное отношение и, возможно, имеются связные отношения. В
получаемых при нормализации отношениях назначаются ключи. Затем
отношения описывают средствами СУБД (формируются пустые БД), после
чего можно программно получить размер записи (см. п. 3.1), а зная
приблизительное или максимально возможное число записей -
ориентировочный размер каждой БД.

                   3. CLIPPER и/или FOXPRO ?

    Системы программирования CLIPPER и FOXPRO - наиболее яркие,
массовые, различающиеся по принципу реализации СУБД "клана" dBASE,
мощной ветви древа реляционных СУБД для ПЭВМ. Актуальные запросы
потребителей, достижения и просчеты конкурирующих фирм - изучается все.
Быстро становятся "общим достоянием" передоаые идеи, неожиданные
решения, новые технологии.
    Примером является история заимствования предложенных фирмой
Ashton-Tate Corp. принципов организации БД, конструкций языка dBASE, 
формата файлов, воплощенных ею в популярной СУБД  dBASEШ Plus.
Некоторое время "кладезем мудрости" была и система CLIPPER.  
    В ПЭВМ концептуальная простота реляционных БД оказалась "божьим
даром" для создателей первых промышленных СУБД. Две другие концепции
БД оказались "на задворках". Проблема быстродействия в начале
внедрения СУБД в ПЭВМ не была актуальна. Она вышла на передний план
после удовлетворения первых потребностей рынка и должного осознания
перспектив построения развитых информационных систем в ПЭВМ.
Номинальная емкость жестких дисков, а с нею и размеры БД стремительно
росли, операции с БД замедлялись, несмотря на рост быстродействия
ПЭВМ. Производительность и не могла быть высокой ввиду интерпретации
команд программы при ее выполнении.
    Если разработчики FoxBase (прообраз FOXPRO) пошли по пути создания
интегрированной среды, сохранив принцип интерпретации, то создатели
системы CLIPPER взяли курс на построение компилятора, отделив этап
трансляции от выполнения программы. Создаваемый в CLIPPER загрузочный
модуль (.EXE-файл) - законченный продукт, используемый (и
распространяемый) отдельно от системы CLIPPER. Кроме принципа
компиляции, создатели предусмотрели и другие меры для ускорения
работы .EXE-файлов: ввели переменные новых классов, блоки кода,
нашли альтернативу макроподстановкам в циклах и т.д.
    Достоинством CLIPPER является открытая архитектура: пользователь
может разрабатывать собственные функции, команды, изменять имеющиеся
команды. Функции пользователя могут быть написаны на С или
Ассемблере. Все это в немалой степени способствовало привлечению
"внешних" разработчиков к развитию индустрии инструментальных средств. 
Система замещаемых драйверов БД позволит применять CLIPPER к БД 
"чужих форматов". Делалось и делается все для расширения сферы 
применений CLIPPER и, конечно, не из простого альтруизма. В частности,
CLIPPER (и FOXPRO) дополняется возможностями языков общего назначения.
    Многомерные массивы CLIPPER по своей роли подобны структурам в Си.
Это облегчает решение задач со сложной логикой и
структурами данных, изменяемыми в ходе решения. Изощренный программист
в состоянии оценить и другие нововведения.

                  4. Как работать с книгой

    Книга построена таким образом, что примерно третью часть
занимает общий материал, немногим более трети - главы по языку
CLIPPER, а остальное приходится на FOXPRO. Большая часть 1-й главы
посвящена структуре языка, правилам записи, стандартным функциям,
выражениям, массивам и может быть быстро пройдена читателем,
знакомым с другими языками программирования. Определенных
усилий потребует освоение средств работы с символьными строками,
клавишных функций и макроподстановок.
  Глава 1 завершается рассмотрением операций с переменными,
операций ввода/вывода, программных блоков, простейших меню. Задачей
главы является создание достаточно широкой базы для последующих
примеров и заданий. Автор стремился к "строго дозированной" специфике
в начале изучения языка, поэтому многие темы находят дальнейшее
развитие в главах, посвященных языку CLIPPER и FOXPRO, на более
сложных примерах. Из тех же соображений базы данных становятся
предметом изучения лишь со 2-й главы, являющейся как бы введением в
СУБД (глава может быть быстро пройдена читателем, знакомым с СУБД),
а 3-я глава содержит основной материал, но без детализации.
    Дальнейшие пути у читателей, избравших главным предметом
CLIPPER или FOXPRO, расходятся. Первые знакомятся с принципиальными
особенностями CLIPPER в главах 4, 5, а вторые - сразу переходят к
главе 15. Если при чтении первых глав у читателя возникнет
впечатление большой общности языков, то в дальнейшем, рассматривая
реализацию одних и тех же "сюжетов" и способы достижения одних
и тех же программистских целей, он увидит весьма существенные
различия. Но главная задача автора - помощь тем, кто решил
самостоятельно освоить CLIPPER или FOXPRO (или обе системы).
    За прошедшие годы стало не только очевидно, что основное
внимание обучаемых языкам СУБД с самого начала надо направлять на
разбор примеров программ, эксперимент с ними, самостоятельное
выполнение заданий на ЭВМ (изменившийся характер пособий по СУБД это
подтверждает), но и созданы хорошие предпосылки для такого стиля
работы. Необходим практикум, иначе неизбежно быстрое "насыщение"
плохо упорядоченной массой сведений. Многое остается "вещью в себе",
пока лично не опробовано обучаемым на ЭВМ, и вызвано это как
спецификой предмета, так и несовершенством руководств по
программированию. 
    Безусловно, примеры в них не должны быть фрагментарными и
требовать от читателя доработки перед опробованием на ЭВМ, но опасна
и другая крайность, когда стремление к "максимуму пользы", увеличению
практической значимости выливается в многостраничные программы-примеры.
Немногие читатели в состоянии их "одолеть". Объем новых сведений,
воспринимаемых перед очередным подходом к ЭВМ, также не должен быть
велик.
    Материал данного руководства разбит на порции, которые содержат
примеры (их общее число превышает 200), проверенные на ЭВМ, и
задания, реализация которых также проверялась. Советую читателю
выполнять и самые простые задания: может быть простота их иллюзорна?
Не  следует обращаться к ответу, не сделав серьезной попытки
выполнить задание. Задания постепенно усложняются и, начиная с
главы 3, придется обращаться к справочнику с функциями и командами
(приложения 1, 2). Одновременно с этим нужно начать использовать
отладчик для проверки программ, наблюдения процесса выполнения.
Главы, посвященные отладчикам, можно изучать по мере необходимости.
     Примеры (и ответы к заданиям) не всегда имеют "рекомендательный"
характер, иногда являясь лишь иллюстрациями. Читатель может найти и
другие варианты решения задач, тем более, что языки СУБД избыточны.
Однако не следует оставлять их без проверки на ЭВМ, а ответы к
заданиям нужно анализировать в любом случае. Итак, постоянное
общение с СУБД и активная работа с примерами и заданиями - залог
успеха. Надо обзавестись дискетой (для надежности - двумя) и
создаваемые учебные базы данных, программы. С помощью редактора
их фрагменты можно переносить в новые программы. Храните базы-
"эталоны", а для экспериментов снимайте копии, которые не жалко
испортить. В CLIPPER для создания баз данных используйте утилиту
DBU.EXE (см. приложение 3).
     Автор надеется, что ряд примеров, особенно в главах 3 - 9,
будут полезными и в практике программирования. Во всяком случае они
могут быть начальной основой для построения собственной библиотеки
программных блоков.
     Ограниченный объем приложений 1, 2 не позволил поместить в
них полный объем справочных сведений по языкам и дать в них примеры.
В справочниках даны ссылки на страницы книги, где рассмотрено
использование функции или команды. Если читатель в большинстве
случаев будет находить в них ответ на свои вопросы и лишь иногда
обращаться к системе помощи CLIPPER (директория NG) или FOXPRO,
эти приложения оправдают себя. Хотелось обратить на них внимание
и тех пользователей, которые еще не осознали вред, приносимый
здоровью многочасовым общением с компьютером.


