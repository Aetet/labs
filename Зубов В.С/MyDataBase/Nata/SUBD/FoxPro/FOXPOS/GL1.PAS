
         ЧАСТЬ 1. ИЗУЧАЕМ ОСНОВЫ ЯЗЫКОВ CLIPPER И FOXPRO

             1. РАССМАТРИВАЕМ ОБЩИЕ ЭЛЕМЕНТЫ ЯЗЫКОВ

     Данная глава знакомит со средствами представления данных в
основной памяти и реализации вычислений,  обработки строк и дат,
с простыми средствами ввода и вывода данных. Вы получаете возможность
начать работу в системе, еще не используя баз данных. Предыдущий
опыт изучения других языков программирования окажется полезным.

             1.1 Структура языка. Правила записи

     Мы сделаем акцент на общность языка рассматриваемых систем.
Отличия будут рассмотрены в следующих разделах.
     В CLIPPER  и  FOXPRO  используются  обычные  для  языков
программирования символы, причем кириллица  допустима  лишь в
символьных строках и примечаниях. Специальными  символами являются:
@, &, |, $, ?, % (операция получения  остатка от деления);
имеются составные символы:  != (не равно; по другому  <> или #),
<= (не больше), >= (не меньше), ** (возведение в степень), ->.
     За исключением редких, оговариваемых случаев регистр букв может
быть произвольным. Например, имена TOR, tor, Tor обозначают одну
и ту же переменную. Длина имен переменной, массива, поля записи
не должна превышать 10 символов, следующие символы игнорируются.
     Конструкции языка по мере их усложнения могут быть отнесены
к уровню слов, выражений, предложений, блоков (алгоритмических),
программных файлов. Программа в целом может быть представлена совокупностью
последних или одним таким файлом (расширение имени  .PRG).
     К словам относят имена; обозначения компонентов массивов,
например A[3, 2] или A[3][2]; вызовы функций, например LOG(X);
константы логические (.TRUE. или .T. - "истина", .FALSE. или .F. -
"ложь"), числовые (до 18 значащих цифр), символьные, т.е. строки.
Строки окаймляются кавычками или апострофами,  например "С'ЕЗД".
В FOXPRO есть константы-даты, например {03/21/73} - 21 марта 1973 г.
     Выражения могут быть числовыми (N), логическими (L), символьными
(C),  выражениями-датами (D); указанные латинские буквы применяются
для обозначения типа выражения (см. функцию TYPE в п. 1.6). В CLIPPER
есть особое значение NIL ("пусто"), которым можно заменять значение
любого типа.
     В определениях предложений используется понятие список. Списком
будем называть последовательность элементов, разделяемых запятыми
(если не оговорен иной разделитель). Предложения могут быть директивами,
командами языка, заголовками блоков, объявлениями переменных и
массивов. Например, команда ввода данных       ACCEPT TO <имя>
позволяет задать последовательность знаков, становящуюся значением
символьной переменной <имя>.   Для вывода на дисплей будем использовать
команду
                       ? <Список выражений>.
     Особо выделим предложения-операторы, организующие структуру
программы, например реализующие ветвления и циклы. Элементы операторов
занимают отдельные строки, чередующиеся с командами языка.
     Блоки (подпрограммы) - это функции и процедуры; в языке CLIPPER
есть также блоки кода - особая форма подпрограмм. Основную программу
будем считать главным блоком. Программный файл содержит блоки. Первые
две строки блока, называемого функцией пользователя, имеют вид
             FUNCTION  <Имя функции пользователя>
             PARAMETERS <Список формальных параметров> ,
последней строкой обычно является оператор возврата
            RETURN <выражение - возвращаемый результат> ;
если функция без параметров, команды PARAMETERS нет. Слово PARAMETERS
можно сокращать:  PARAM .  В языке CLIPPER имеется другой вариант
передачи параметров функции (см. п. 4.5).
     Правила записи текстов программ. Предложение обычно занимает
отдельную строку; длинное предложение может занимать и несколько
строк, каждую из них, кроме последней, заканчивают знаком ";".
     Примечание, текст которого идет до конца строки, начинают
знаками "&&"; строку примечания можно также начать знаком "*".
Рекомендуется начинать программу примечаниями, объясняющими ее
назначение, используемые данные и результаты.
    В языке CLIPPER пару знаков "&&" можно заменять парой "//",
можно ограничивать примечание слева "/*", а справа "*/". Этим
пользуются и для многострочного примечания, начиная и заканчивая
его указанными ограничителями. В языке CLIPPER можно записывать в
строке более, чем одно предложение, разделяя их знаком ";".
    Задание 1.1. Запишите программу с двумя действиями: A = 2*2,
вывод числа A на дисплей. Запись действий сопроводите примечаниями
"Умножение", "Вывод на дисплей"; программу начните примечанием
"Программа дважды-два".

           1.2. Математические функции. Функция Inlist()

     Числовое выражение  будем обозначать <вырN>  (или  <вырN1>,
<вырN2> и т.п.); выражениe типа "дата" - <вырD>, символьное -
<вырC>; обозначения <выр>,<выр1> и т.п. - "нейтральны" к типу.
     В CLIPPER и FOXPRO имеются следующие математические функции:
  ABS(<вырN>) - абсолютная величина значения <вырN>;
  SQRT(<вырN>) - квадратный корень из значения <вырN>;
  EXP(<вырN>) - показательная функция (экспонента) аргумента <вырN>;
  LOG(<вырN>) - натуральный логарифм значения <вырN>;
  INT(<вырN>) - целая часть значения <вырN>;
  MAX(<выр1>,<выр2>) - максимальное из двух чисел или дат;
  MIN(<выр1>,<выр2>) - минимальное из двух чисел или дат; в FOXPRO
число аргументов функций MAX и  MIN  произвольно (но не менее 2);
  MOD(<вырN1>,<вырN2>) - целочисленный остаток от деления  <вырN1>
на <вырN2>;
  ROUND(<вырN1>,<вырN2>) - результат округления значения <вырN1> до
<вырN2> знаков после запятой (например, до сотых, если <вырN2>= 2);
при отрицательном значении <вырN2> округление идет до десятков,
сотен и т.д. Например, значение ROUND(157536, -3) равно 158000.
     В FOXPRO дополнительно имеются следующие математические функции:
  LOG10(<вырN>) - десятичный логарифм <вырN>; в CLIPPER взамен можно
использовать выражение  0.43429*LOG(<вырN>);
  SIGN(<вырN>) - функция знака <вырN>, принимающая значения -1,0,1;
  CEILING(<вырN>) - ближайшее целое, большее или равное <вырN>;
  FLOOR(<вырN>) - ближайшее целое, меньшее или равное <вырN>;
например, значение FLOOR(-3.7) равно -4,  а CEILING(-3.7) равно -3;
  BETWEEN(<выр1>,<выр2>,<выр3>) дает значение "Истина" (.T.),
если значение <выр1> больше или равно <выр2>, но меньше или равно
<выр3>; все 3 выражения должны иметь один тип (число, дата, строка);
  RAND() - псевдослучайное число в диапазоне [0, 1]; если в скобках
задан аргумент <вырN>, то это число формируется на основе <вырN>.
Только первое из цепи чисел следует формировать таким образом;
следующие обращения к RAND должны быть без аргумента. Если значение
<вырN> отрицательно, то число формируется на основе показаний таймера,
т.е. начало цепи чисел всякий раз оказывается новым (и цепь чисел
также). В CLIPPER используйте функцию RanCli (см. п.4.4).
  SIN(<вырN>), COS(<вырN>), TAN(<вырN>) - тригонометрические
функции; аргумент в радианах (см. ниже функцию DTOR);
  DTOR(<вырN>) - переведенное в радианы значение <вырN> (градусы);
  ASIN(<вырN>), ACOS(<вырN>), ATAN(<вырN>) - обратные тригонометрические
функции; результат в радианах в интервале от -Пи/2 до Пи/2
для ASIN() и ATAN(), а для ACOS() - в интервале от 0 до Пи;
  ATN2(<вырN1>,<вырN2>) - арктангенс отношения <вырN1>/<вырN2>,
причем допустимо <вырN2>= 0; результат в радианах от -Пи/2 до Пи/2;
  RTOD(<вырN>) - переведенное в градусы значение <вырN> (радианы);
  PI() - число Пи с большой длиной дробной части.
     Пример 1.1.
 ? RTOD(1.57),  RTOD(PI()/2)  // Выводятся значения 89.95, 90.00
     В FOXPRO имеется весьма полезная функция Inlist:
               Inlist(<выр>,<список выражений>),
возвращающая значение .T., если значение <выр> совпадает со значением
какого-либо выражения из списка. Все выражения должны быть одного
типа: числа, строки символов или даты.
     Задание 1.2. Запишите выражение для получения максимума из
чисел A,B,C,D  в языках CLIPPER и FOXPRO.

            1.3. Функции и команды для работы с датами.
                         Операции с датами

     Способ изображения даты (формат даты), используемый в программе,
задают командой  SET DATE <Ключ>;  возможные форматы указаны в
таблице. 1.1, где "mm" обозначает месяц, "dd" - день, "yy" - год,
например дата 03/21/73 в формате AMERICAN, принимаемом по умолчанию,
означает 21 марта 1973 г.
                                                      Таблица 1.1
──────────────────────────────────────────────────────────────────
    Ключ            Формат      │       Ключ             Формат
--------------------------------│----------------------------------
 AMERICAN          mm/dd/yy     │      GERMAN           dd.mm.yy
 ANSI              yy.mm.dd     │      ITALIAN          dd-mm-yy
 BRITISH/FRENCH    dd/mm/yy     │      JAPAN            yy/mm/dd
-------------------------------------------------------------------
    Пользователь может назначить собственный формат даты заданием в
команде SET DATE FORMAT положения ее элементов и разделителя,
например: SET DATE FORMAT dd:mm:yyyy (день, месяц, 4 цифры года).
Минимальная дата, которой можно оперировать, - 1 января 100 года.
    Функция DATE() возвращает значение текущей даты в установленном
формате. Задать значение типа "дата" можно при помощи функции CTOD,
аргументом которой является строка, обозначающая дату в установленном
формате: CTOD("12/31/93"). Функция проверяет номер дня и месяца;
если значение недопустимо (например, месяц "31" в дате 31/12/93 в
формате AMERICAN) - возвращает пустую дату. Составляющие даты (год,
месяц,день) выделяют при помощи функций YEAR(<вырD>), MONTH(<вырD>),
DAY(<вырD>) соответственно. Результаты этих функций - числа.
Функция DOW(<вырD>) возвращает порядковый номер дня недели. Кроме
того, есть функции CDOW(<вырD>)  и  СMONTH(<вырD>),  возвращающие
соответственно название дня недели и название месяца в виде строки.
Функция DTOC(<вырD>) возвращает строку, представляющую дату в
установленном формате. Обычно ее используют в составе символьных
выражений, например "ПРОТОКОЛ ОТ"+ DTOC(DATE()); при отдельном
выводе даты ее преобразование в строку происходит автоматически.
     Перед выводом дат можно задать четырехзначное представление
года командой SET CENTURY ON; команда SET EPOCH <Год> задает начало
отсчета дат: все они будут в пределах ста лет, начинающихся с
заданного года. Например, согласно команды SET EPOCH 1994 год "22"
понимается как 2022 год. По умолчанию начало отсчета - год 1900.
     Функция DTOS(<ВырD>) возвращает строку следующего вида:
"yyyymmdd", где yyyy - 4 цифры обозначения года, mm - месяц, dd -
день, например, 19931231. Если произвести упорядочение
(индексирование) содержащих дату записей по этим преобразованным
представлениям даты, получится хронологический порядок.
     Константы-даты в FOXPRO должны быть записаны в соответствии с
используемым форматом дат. Даты можно увеличивать (уменьшать),
прибавляя (вычитая) число. Из даты можно вычитать дату, получая
ч и с л о дней.
     Пример 1.2. Дата в формате AMERICAN суммируется с числом:
  ? {07/08/94} + 53         && Выводится новая дата "08/30/94".
  ? CTOD("07/08/94") + 53   && CLIPPER; реализуется то же самое

     Пример 1.3. Вычитание дат; в CLIPPER потребуется функция CTOD.
     ? {07/08/96} - {07/08/38}     // 21185 (число дней за 58 лет).
     В языке FOXPRO дополнительно имеются следующие функции:
  GOMONTH(<вырD>,<вырN>) - возвращает дату, отстоящую от даты <вырD>
на <вырN> месяцев вперед или, если  <вырN> < 0,  назад ;
  DMY(<вырD>) - представляет дату <вырD> строкой "день месяц год",
например DMY({09/01/96}) возвращает строку     "01 September 96".
     Задание 1.3. Оперируя датами, попытайтесь вывести на дисплей
прошедшее число дней новой эры, хотя бы приблизительно, а также
число прожитых вами дней.

            1.4. Строковые функции. Операции со строками

     В базах данных (БД) символьный тип занимает особое место, а
средства работы со строками являются обязательным инструментом при
обработке данных БД и особенно - при создании интерфейса. Заметим,
что многие из функций действуют со строками, включающими символы
кириллицы, лишь при наличии в СУБД руссификатора.
    В дальнейшем термин <строка> будем понимать расширительно, как
строковое выражение <вырC>. В CLIPPER длина строк d - до 64 K. Для
строк определена операция конкатенации (слияния), обозначаемая
знаком "+" или "-". В любом случае строки соединяются; в отличие от
варианта с плюсом в варианте с минусом концевые пробелы первой строки
переносятся в самый конец результата слияния.  Допустим даны строки
SS ="НЕВИДИМО", S ="ВИДИМО-      ".  Команда    ? S+SS    выводит
"ВИДИМО-      НЕВИДИМО", команда  ? S-SS  -  "ВИДИМО-НЕВИДИМО      ".
    Операция <вырС1> $ <вырC2> .  возвращает результат .T. ("Истина"),
если строка <вырC1> содержится в <вырC2> или эти 2 строки совпадают.
    Пример. Требуется проверить, является ли ответ пользователя
(строка S) одной из букв "Y", "N", "y", "n".  Используется операция
S $ "Y N y n". Аналогичным образом можно проверять ответы, состоящие
из нескольких букв:  Upper(S) $ "YES NO ". Функцией Upper буквы ответа
переведены в верхний регистр (прописные буквы).
    Сравнение строк. Имеется 2 режима: SET EXACT OFF (режим по
умолчанию) и SET EXACT ON. В режиме SET EXACT OFF операция сравнения
<вырC1> = <вырC2> возвращает результат .T., если строки идентичны
или <вырC2> является начальной подстрокой в <вырC1>. Например, в
файле изделий, где поле MARKA обозначает изделие, мы можем найти
первое по порядку записи изделие фирмы SONY, используя условие
MARKA = "SONY" (обозначение изделия длиннее 4 символов). Переставьте
левый операнд с правым, и поиск становится безрезультатным.
     Не удивляйтесь тому, что в режиме SETEXACT OFF сравнение <вырC> =""
всегда возвращает .T. Действительно, пустая строка является подстрокой
другой строки. Чтобы проверить, является ли <вырC> пустой строкой,
нужно изменить режим командой  SET EXACT ON, и тогда при сравнении
лишь идентичность строк, исключая их концевые пробелы, будет
основанием получения результата .T.  Можно также применить операцию
"==", которая дает .T. лишь при идентичности строк  р а в н о й  длины,
включая их концевые пробелы:  <вырC> == "".
      Наконец, если вы хотите проверить, содержит ли строка <вырC>
литеры, применяйте функцию Empty(<вырC>), которая возвращает .T. и
для пустой строки, и для строк, содержащих лишь пробелы, знаки
табуляции, возврата каретки, перевода строки. Функция применима и к
аргументам иных типов (см. приложение 1).
    Рассматриваемые ниже функции F, не изменяя строку-аргумент,
возвращают измененный ее  д у б л ь,  а для изменения самой строки
нужна команда Sp = F(Sp), где Sp - символьная переменная, обозначающая
строку. В дальнейшем тексте обязательные аргументы напечатаны жирно.
Для краткости вместо <вырC> используются обозначения S,SS,S1 и т.п.
    Функции Ltrim(S), Rtrim(S), Alltrim(S) возвращают усеченную
строку, удаляя пробелы соответственно слева, справа и с обоих сторон
строки. Напротив, функции Padl(S,l,z), Padr(S,l,z), Padc(S,l,z)
возвращают дубль строки S, имеющий длину l, в который добавляется
заданный символ z соответственно слева, справа и равномерно с обеих
сторон. Если 3-й параметр не указан, добавляются пробелы. Если же
длина l меньше длины d строки S, происходит усечение дубля справа.
    Не только усечение строки, но и выделение подстроки SS - любой
части строки - можно произвести функцией Substr (S,k,l),  где  k -
начальная позиция подстроки в строке S, l - длина подстроки. Если l
больше (d-k), подстрока оканчивается вместе со строкой, как и в
случае возможного не указания l. Если b отрицательно, начальный символ
подстроки отсчитывается от конца строки S.
    Пример:   ? Substr("ПОБЕДА",-4)             // Выводится "БЕДА"
Функции Left(S,n) и Right(S,n) имеют более узкое назначение, выделяя
в подстроку n символов соответственно с левого и правого края строки.
    Три вышеуказанных функции часто используются совместно с функциями
At(SS,S) и Rat(SS,S), которые находят в S первое (последнее)
вхождение подстроки SS, возвращая в любом случае номер начального
символа SS внутри S или ноль - если подстрока SS в S не обнаружена.
    Пример 1.4. Строка S содержит фамилию, имя, отчество. Выделяем
фамилию с первым инициалом (ставим точку), отводя для них 20 позиций:

    Z = Alltrim(S)           //Создается копия без внешних пробелов
    Y = At(" ", Z)+1)      //Устанавливается позиция буквы инициала
    Z = Padr(Substr( Z,1,Y) +".", 20)       //Оформляется результат
    Поскольку возможны ошибки данных, в прикладной программе этими
тремя операторами не ограничиваются. Если по ошибке в S пропущены
разделительные пробелы, например, заменены знаком "_", функция At()
не найдет пробел и возвратит 0; в итоге Z будет содержать первую
букву фамилии с точкой. Другими словами, надо проверять значение Y.
    Функция Stuff(S, k, nu, SS) в дубле строки S удаляет nu символов,
начиная с позиции k, а затем вставляет в этот пункт подстроку
SS. Если удаление не требуется, задают nu=0.  Если же не требуется
вставка, задают SS ="" (пустая подстрока). Рассмотрим примеры. Функция
Stuff("дефективный",1,2,"эф") возвращает строку "эффективный".
     Пример 1.5. Заменяем в строке S  "вышеперечисленные личности"
первое ее слово двумя словами "перечисленные выше":
   S =  Stuff (Stuff (S, At(" ",S), 0, " выше"),   1, 4, "") ;
здесь внутренняя Stuff вставляет слово, а внешняя - удаляет 4 буквы.
    Если подобное изменение надо осуществить по всему тексту длинной
строки S, лучше воспользоваться функцией со скрытым циклом
                 Strtran(S, SS1, SS2, k, n),
где SS1 - подстрока S, а SS2 - замещающая SS1 подстрока; с помощью
k, n  можно  указать, что замены надо начинать с k-го вхождения SS1
в S, причем требуется обработать n таких вхождений. Если двух
последних параметров нет, обрабатываются  в с е  вхождения подстроки.
Для повсеместной замены в длинной строке S слова "вышеперечисленные"
словами "перечисленные выше" запишем функцию Strtran дважды,
учитывая возможность появления слова в начале предложения:
        Strtran(S, "вышеперечисленные", "перечисленные выше")
        Strtran(S, "Вышеперечисленные", "Перечисленные выше") ,
     Функция  Space(n) возвращает строку, состоящую из n пробелов.
Функция Replicate (SS,n) возвращает строку, состоящую из n подстрок
SS. Функция Upper(S) возвращает дубль строки S, в котором все буквы
прописные. Напротив, функция Lower(S) делает буквы строчными.
     Примеры:  ? Replicate("ДИНЬ-", 3)    //Вывод "ДИНЬ-ДИНЬ-ДИНЬ-"
               ? Replicate("*",15)        //Вывод "***************".
    Функции анализа строк. Функция Len(S) дает длину d строки S.
Чтобы проверить, пуста ли строка S, нужно сравнить Len(S) с нулем;
функция Empty(S) непригодна, она дает .T. и в случае, если строка
состоит из пробелов. Можно также сравнить S c пустой строкой "".
    Функция Isalpha(S) возвращает .T. только если 1-й символ строки
буква, а Isupper(S) дает .T. только для заглавной буквы в 1-й
позиции строки, тогда как Islower(S) - для строчной. Функция
Isdigit(S) возвращает .T., только если первый символ строки цифра.
Функции анализа, а также Upper(S), Lower(S), Proper(S), Atc(SS,S),
Atcline(SS,S) (см. приложение 2) действуют с кириллицей лишь при
наличии русификатора в пакете FOXPRO.
     Прежде, чем изучить дополнительные функции FOXPRO, рассмотрим
понятие символьной маски, используемой при поиске. Маска наряду с
явно указанными символами может содержать знак "?", обозначающий
позицию, занятую некоторым символом, и знак "*", обозначающий
некоторую последовательность символов, хотя бы и пустую. Например,
при поиске в базе данных лиц, телефон которых имеет окончание 4-73,
используется маска *4-73 или ???-?4-73, если телефонные номера
семизначные.
     В языке FOXPRO функция Like(<вырC1>, <вырC2>) возвращает
значение .T., если строка <вырC1> имеется в <вырC2>, причем <вырC1>
может быть маской. Например,   LIKE("??монстр*", "демонстрация")
возвращает значение .T., как и  LIKE("*монстр*", "Зомби-монстр").
    Функция FOXPRO Occurs(SS,S) возвращает число вхождений подстроки
SS в строку S. У функций At, Rat (см. выше) может быть 3-й параметр:
числовое выражение, которое указывает номер разыскиваемого
экземпляра подстроки (отсчет слева для At и справа - для Rat).
Кроме того, имеется функция Atc, которая не различает при поиске
прописные и строчные буквы, а в остальном аналогична функции At.
    Функция FOXPRO Chrtran(S, S1, S2) возвращает измененную копию
строки S, в которой все вхождения j-го символа строки S1 заменены
j-м символом строки S2, j=1..Len(S1).   Если строка S2  короче
строки S1 и в ней нет j-го символа, то в строке S попросту
исключаются знаки, являющиеся j-м символом S1.     Примеры:
    ? Chrtran("ПРОСТРАЦИЯ", "АИРЦЯ", "")       // Выводится "ПОСТ"
    ? Chrtran("ПРОЛЕТАРИЙ", "ТЕРАПОИЛЙ", "ЕДТНСУ")     //"СТУДЕНТ"
     Задание 1.4. Используя строковые функции, запишите процедуру
попарной перестановки соседних слов в произвольно заданной строке
(повторное применение процедуры восстанавливает строку).

                1.5. Выражения. Условные выражения

    Операции с числами и операции сравнения указаны в табл. 1.2.
                                                       Таблица 1.2
───────────────────────────────────────────────────────────────────
│     Знаки числовых операций   │      Знаки операций сравнения
│-------------------------------│----------------------------------
│ +,-    Сложение и вычитание   │ = или ==     Равно
│ *,/    Умножение и деление    │  <, <=   Меньше, меньше или равно
│ **,^   Возведение в степень   │  >, >=   Больше, больше или равно
│ %    Остаток от деления нацело│  !=, #       Не равно

    Логические операции записывают как .NOT.(отрицание), .AND.
(конъюнкция) и .OR.(дизъюнкция) (отрицание можно также обозначать знаком
"!"). Операции сравнения "==","=" применимы к выражениям всех типов.
    Операции выполняются над однотипными данными;   исключения:
а) сложение (вычитание) даты и числа (результат имеет тип "дата");
б) сравнение операнда любого типа на равенство значению NIL ("пусто");
при сравнении с NIL допустимыми являются знаки =, ==, # и != .
    В языке CLIPPER предусмотрены составные операции:
     <Имя A> <Знак числовой операции><Знак "=" > <Выражение B>;
сначала выполняется числовая операция над A и B, а затем ее результат
присваивается A, ибо здесь знак "=" означает присвоение. Операции "+="
и "-=" применимы также к строкам и датам (см. п."а" выше).
Пример: B:=1; C:=8; C/=(B+=3) // В итоге B получает значение 4, C=2.
    Ниже операции перечислены по убыванию приоритета (старшинства).
  1. Операция конкатенации ("слияния")строк (см. п. 1.4).
  2. Унарные операции "+" и "-", например, минус в записи   - 2**2.
  3. Возведение в степень; например, - 2**2 дает значение   + 4.
  4. Умножение, деление, получение остатка от деления.
  5. Вычитание, в том числе <дата>-<дата>, <дата>-<число>, и
сложение,  включая случай <дата>+<число>.
  6. Операции сравнения и проверка вхождения подстроки в строку.
  7. Логическая операция отрицания (.NOT.).
  8. Логическая операция "И" (.AND.).
  9. Логическая операция "ИЛИ" (.OR.).
     В выражении, где нет скобок (), старшие операции выполняются
в первую очередь; считается, что операции равного приоритета
выполняются в порядке слева-направо.   Если в выражении имеются вызовы
функций, то прежде всего находятся их значения; при этом порядок
действий в аргументе-выражении подчиняется общим правилам.
     Пример 1.6. Даты D1, D2 были заданы как даты начала и окончания
этапа некоторой работы соответственно. Установлена новая дата
D3 начала. Требуется определить новую дату D4 окончания.   Команда
D4 = D2 +  D3 - D1 вызовет сообщение об ошибке (в FOXPRO) или даст
неверный результат (в языке CLIPPER), ибо действия "+","-" равного
приоритета и выполняются слева-направо, а операции сложения дат не
существует. Следует записать команду в виде   D4 = D2 + (D3 - D1).
    Итак, проставляя скобки, можно определить любой необходимый
порядок выполнения операций, повысить наглядность выражений.
    Условные выражения. Функция Iif(), позволяющая реализовать
условные выражения, имеет структуру     Iif (<вырL>, <выр1>, <выр2>) ;
она возвращает значение <выр1>, если <вырL> истинно,  в  противном
случае - значение <выр2>. Например, Abs(X) и функция Iif(X<0,-X,X)
имеют одинаковый результат. Типы выражений <выр1> и <выр2> не
обязательно согласовывать. Пример: Iif(A>=0, Sqrt(A),"Аргумент < 0").
    В качестве <выр1>,<выр2> можно использовать другие, вложенные
функции Iif; глубина вложений не ограничивается.
    Пример 1.7. В некоторой базе данных поле Sem имеет значения "Х"
(холост),"Б" (в браке),"Р" (разведен), поле Pol - значения "муж",
"жен". Выводим фамилию (поле Fam) и семейное положение (словесно):
  ? Fam, Iif(Sem="Х",  Iif(Pol="муж", "Холост", "Не замужем"),  ;
                       Iif(Sem="Б", "В браке", "Разведен(а)") )
    Функция Iif обеспечивает лаконичную запись ветвлений, особенно,
если тот или иной выбор нужно реализовать в рамках выражения.
Поскольку в <выр1>,<выр2> возможны функции пользователя, сложность
ветвей не ограничивается. Если от функции Iif не требуется возврат
значения, ее используют как команду (CLIPPER) или в фиктивном
присваивании (FOXPRO; см. пример 1.8).  Если при этом одна ветвь
пустая, ее показывают в Iif выражением "0" (ноль) или пустой строкой.
    Пример 1.8. Выделяем в строке S прописными буквами слово, началом
которого является заданная подстрока SS. Если такого слова нет,
строка не изменяется.

* При реализации программы в CLIPPER надо убрать "=" в 3-й строке
ACCEPT TO S                        && Ввод строки S и подстроки SS
ACCEPT TO SS
= Iif (!Empty(S).and.!Empty(SS), f(), 0)  && Если строки S, SS не
? SS, S                    && пустые, строка S изменяется в блоке f
CANCEL                           && Возвращение в командную строку
FUNCTION f
k = At(Upper(SS),Upper(S))  && k-начальная позиция подстроки SS в S
l = Iif(k>0, At(' ', Substr(S,k)) - 1, 0) && l-длина искомого слова
l = Iif(l<0, Len(S)-k+1, l)   && Случай, когда конец слова= концу S
SS = Upper(Substr(S, k, l))  && Слово приводится к верхнему регистру
S = Iif(k>0, Stuff(S,k,l,SS), S)         && Замена слова в строке S
RETURN 0            && Ноль, ибо возвращаемое значение не требуется
     Задание 1.5. Используя функцию Iif, составьте программу,
удаляющую из заданной строки S первое слово с заданным окончанием SS.

         1.6. Тип выражения. Преобразования типа операндов.
                      Звуковое сопровождение

    В некоторых случаях, например, при отладке программы, требуется
определить тип значения выражения. Функция Type("<Выражение>")
возвращает символ, обозначающий тип этого значения (табл. 1.3;
курсивом выделены типы, определяемые лишь в языке CLIPPER; буква "U"
возвращается при невозможности установления типа также и в FOXPRO).
Например, если аргумент Type - заключенное в кавычки имя массива,
в языке FOXPRO возвращаемая буква определяется типом первого элемента
массива; в языке CLIPPER - возвращается буква A (см. табл. 1.3).
______________________________________________________Таблица 1.3
Т и п  Число Символьный Логический Дата  MEMO Блок кода  Массив NIL
-------------------------------------------------------------------
Символ   N       C           L       D    M      B         A     U
-------------------------------------------------------------------
    Тип MEMO ("Примечание") является одним из типов полей записи.
В языке CLIPPER при синтаксической ошибке в выражении функция Type
возвращает строку "UE", а при ошибке неизвестного характера - "UI"
(например, если в нем есть функция пользователя).
    Пример.  X=5;    ? Type ("X+Y"), Type("X+*5"), Type("f(X)+5")
Возвращается соответственно буква "U", "UE", "UI". Если мы забудем
поставить выражение в кавычки, возникает сообщение об ошибке.
    Поскольку в операциях участвуют, как правило, однотипные
операнды, необходимы преобразования типов. С функциями CTOD, DTOC,
DTOS вы уже знакомы (см. п. 1.3). Теперь рассмотрим преобразования
"число -> строка" (функция Str) и "строка -> число" (функция Val).
     При выводе командой "?" числовых выражений происходит
автоматическое преобразование "число -> строка".  Функции  Transform()
(см. п. 1.11) и Str() осуществляют его с определением длины строки.
     В функции Str(<вырN1>,<вырN2>,<вырN3>) последние 2 аргумента
не обязательны, а первый - представляет само преобразуемое число;
<вырN2> задает длину строки (по умолчанию 10), <вырN3> - количество
знаков после десятичной точки в строковом представлении числа (по
умолчанию - 0). Необходимое округление происходит автоматически.
     Пример 1.9. Требуется расположить записи сотрудников по
отделам (символьное поле Otd), а записи каждого отдела - по росту
сотрудников (числовое поле Rost, сантиметры). С этой целью проиндексируем
(или отсортируем) базу данных по составному ключу. Его запись
в виде "Otd + Rost" некорректна (разные типы полей). Воспользуемся
записью  Otd + Str(Rost,3).
     Функция Val(<вырC>) возвращает значение типа N - итог
преобразования цифрового начала строки <вырC>; в случае, если <вырC>
начинается не с цифры, не с пробела и не со знака "+" или "-",
функция Val() возвращает 0. Например, Val("15.3 км") возвращает
число 15.3, а Val("$1500") возвращает 0; нередко цифровую часть
строки приходится выделять функцией Substr, чтобы перевести в число.
    Функция Asc(<вырC>) возвращает ASCII-код первого символа <вырC>,
а Chr(<вырN>), напротив, возвращает символ, ASCII-код которого
задан выражением <вырN>. Например, команда  ? Chr (Asc("D")-3)
выводит латинскую букву "A" (последовательность кодов соответствует
алфавиту, позиции букв "A" и "D" разнятся на 3).
     Функция Chr пригодна и для выдачи звуковых сигналов. Например,
команда  ? Chr(7)   выдает краткий звуковой сигнал,    а команда
? Replicate (Chr(7), <вырN>) моделирует зуммер.  Частоту и длительность
одиночного сигнала в CLIPPER устанавливает функция Tone (),
а в FOXPRO - команда Set Bell To. Их первым параметром является
частота звука (по умолчанию - 512), вторым - длительность (по
умолчанию - 2 единицы в 1/18 с).  Диапазон частот -  19 .. 10000 герц.
      Задание 1.6. Запишите выражение для получения числа 42.195 из
строки "Расстояние 42 км 195 м", а также последовательность команд
для получения с помощью ЭВМ звуковой гаммы (частоты звука 262, 294,
330, 349, 392, 440, 494, 523).

        1.7. Ввод и присваивание значений переменным. Массивы

     Вы уже видели использование команды ACCEPT (п. 1.5) для ввода
строк-значений символьных переменных; ее развернутая форма такова:
   ACCEPT <необязательное выражение-подсказка> TO <имя переменной>,
например:       ACCEPT "Введите имя файла  " ТО  Name.
Вычисления приостанавливаются до тех пор, пока вы не введете после-
довательность знаков без внешних кавычек (максимум 255 знаков),
завершив ее нажатием Enter. Если сразу нажать Enter, будет введена
пустая строка. Аналогичную структуру имеет команда  INPUT:
   INPUT <необязательное выражение-подсказка> TO <имя переменной>,
но вводится значение любого типа. В общем случае после приостановки
вы набираете  в ы р а ж е н и е,  которое по нажатии Enter транслируется
и вычисляется, найденное значение присваивается переменной,
например:  INPUT "Введите имя файла" TO Name. В отличие от команды
ACCEPT внешние кавычки при вводе строк-констант требуются. Представим,
что необходимо полное имя файла, причем путь к файлу уже хранится
в переменной Put; имя файла - Stud.dbf. Тогда нам нужно набрать
выражение   Put +"Stud.dbf"  (конкатенация строк) и нажать Enter.
     Присвоить переменным значения можно с помощью команды
 STORE <выражение> TO <список имен переменных и элементов массивов>
(присваивается общее значение <выражения>) или несколькими командами
вида      <переменная или элемент массива> = <выражение>.
     Элементы массива допускается использовать, только если массив
был объявлен, например в операторе
       DECLARE <имя массива> [<список размеров массива>].
По умолчанию элементы массива получают значения NIL (в CLIPPER) или
.F. (в FOXPRO). Есть и другие операторы объявления массивов (см. гл.
4, 5). В FOXPRO существуют одно- и двумерные массивы, в языке CLIPPER
размерность массива не ограничивается. Обозначением элемента массива
в командах является следующая запись:
           <имя массива> [ <список индексных выражений>].
Число индексных выражений равно размерности массива; в FOXPRO
дополнительно используют форму  <Имя массива> [<Приведенный индекс>],
где <Приведенный индекс> - это порядковый номер элемента в памяти.
В FOXPRO имя массива может появляться слева от знака "=", что означает
присвоение одного и того же значения всем элементам массива, например
A = 0. В языке CLIPPER для этого используют функцию Afill (см. гл. 5).
     Пример 1.10. DECLARE A[4,5]   && Объявлена матрица размером 4х5
                  J = 1
             A[J,5] = 0   && 0 присвоен последнему элементу 1 строки
             A = 0       && Только в FOXPRO ! Обнуление всей матрицы
     Задание 1.7. Составьте программу, в которой по желанию пользователя
переменная L получает значение N или N+M, где N и M - предварительно
заданные значения, а затем выводится значение выражения
L*(L-1)*(L-2).

                1.8. Некоторые клавишные функции

     При нажатии клавиш вырабатываются коды, называемые Inkey-
кодами (приложение 4; имеются различия Inkey-кодов в языках CLIPPER
и FOXPRO). Например, Inkey-код клавиши F2 равен  -1. Inkey-коды
заносятся в так называемый буфер клавиатуры (БК), а затем расходуются
теми или иными функциями и командами. Например, команда  ACCEPT (см.
п. 1.7) считывает все имеющиеся коды из БК при нажатии клавиши
Enter, присваивая соответствующее значение символьной переменной.
Без нажатия клавиш Inkey-коды символов, образующих некоторую строку
<ВырC>, можно занести в БК командой            KEYBOARD <ВырC> .
    Функция  Inkey(<ВырN>) возвращает очередной код, взятый из БК,
который от этого кода освобождается. Если БК был пуст, <ВырN> секунд
ожидается нажатие клавиши, код которой и возвращает Inkey(). Если же
за это время нажатия клавиши не будет, Inkey() возвращает 0.
    Аргумент <ВырN> может быть опущен (ожидания нет) и равен 0 (не
ограниченное временем ожидание). В FOXPRO функция может иметь 2-й
аргумент <ВырC>, используемый для управления курсором и выявления
нажатий кнопки мыши. Если <ВырC> = "S", курсор включается, а если
<ВырC> = "H", отключается. Чтобы контролировать нажатия мыши,
записывают <ВырC> = "M", при этом функция возвращает число 151.
Допустимы сочетания "MS","MH" (оба вида управляющих воздействий).
    Использованные командой или функцией коды клавиш уходят из БК,
стираются в нем. Последний использованный код доступен, будучи уже
стертым в буфере. Для его сохранения используется так называемая
клавишная ячейка. Она хранит код, пока он не будет замещен следующим
"вытолкнутым" из БК кодом. Код клавишной ячейки возвращает функция
Lastkey(). Функция Inkey, ждущая нажатия клавиши, сразу же
"выталкивает" поступивший в БК код в клавишную ячейку.
    Пример 1.11. Рассмотрим фрагмент программы, составленный для
оперативного выбора одного из двух вариантов ее продолжения. К
моменту выбора БК пуст. Нажатие F2 означает выбор 2-го варианта.
Первая функция Iif нужна для вывода сообщения о выбранном варианте,
вторая назначает соответствующее значение A:
  ? "Нажмите клавишу F2, если требуется вариант 2"
  ? Iif (Inkey(5) # -1, "Вариант 1, A=5", "Вариант 2, A=10")
  A = Iif (Inkey() # -1,  5, 10)
    Фрагмент ошибочен, ибо во 2-й функции Iif значение Inkey()
всегда 0: к моменту ее выполнения БК пуст. Правильная запись:
  A = Iif (Lastkey() # -1, 5, 10).
    В CLIPPER также имеется функция Nextkey(), которая возвращает
очередной код клавиши, не стирая его в буфере. Функция Inkey()
удобна тем, что дает задержку, необходимую для принятия решения.
В варианте без задержки она может применяться для анализа содержания
БК.
    Пример 1.12. Изучите на примере использование клавишных функций.
     KEYBOARD "ЗСБ"    && Команда KEYBOARD заносит коды строки в БК
   ? Chr(Inkey())                           && Выводится символ "З"
   ? Chr(Nextkey()), Chr(Lastkey())       && Выводятся символы "СЗ"
   ? Chr(Inkey()), Chr(Nextkey()), Chr(Lastkey()) && Выводится "СБС"

     Функция Readkey() возвращает код клавиши, нажатой для выхода
из команды редактирования READ. Если пользователь не успел изменить
данные, возвращается Inkey-код, а если данные изменены - увеличенный
на 256 Inkey-код.
     Задание 1.8. Запишите программу, которая выводит прописными
буквами строку S = "Be or not to be?", если в течение 10 секунд с
момента появления на экране сообщения "Для вывода прописными нажмите
F5" нажата клавиша F5 (Inkey-код  -4), иначе строка S выводится в
исходном виде.

                 1.9. Операция макроподстановки

     Нередко возникает необходимость сделать частью текста или
команды последовательность символов, которая определяется в самой
программе и может варьироваться как значение символьной переменной.
В этих случаях к символьной переменной, занимающей соответствующее
место в тексте, команде, применяют операцию макроподстановки,
изображаемую знаком &, например  &A.
     Пример 1.13. Макроподстановка в тексте.
  A = "ДИНЬ"
 ? "&A-&A-&A И ТРОЙКА ..."  && Выводится "ДИНЬ-ДИНЬ-ДИНЬ И ТРОЙКА ..."
     Если имя макропеременной соседствует с символом, допустимым в
именах, необходим макроограничитель - точка справа от имени
макропеременной. Если по тексту именно здесь идет точка, следует
записывать 2 точки. Чаще всего имя макропеременной ограничено пробелом.
     Макроподстановки аргументов команд. Аргументы команд (также и
команды целиком - в FOXPRO) можно задавать через макроподстановку,
например: ACCEPT "Введите имя удаляемого файла" TO f;  ERASE &f.
В случае подстановки имени файла или поля удобнее использовать
расширенные выражения - символьные выражения, заключенные в скобки.
Этот случай подстановки не требует записи знака &, например:
ERASE (Name +".dbf"), где переменная Name содержит имя без расширения.
     Макроподстановки в выражениях. Если макроподстановка стоит в
выражении или на месте выражения, то сначала происходит подстановка
текста, а затем компиляция всего выражения макрокомпилятором.
     Пример 1.14. Назначается дата (относительная) выполнения работы;
если это воскресенье, срок выполнения переносят на понедельник:
 ACCEPT "Укажите дату выполнения в форме   Date()+<Число>" TO D
 ? "Работу выполнить к", Iif(Dow(&D)= 1, &D + 1, &D) .
В переменную D заносят текст, например "Date()+7". Этот текст
подставляется в функцию Iif и она компилируется. Затем команда
вывода выполняется.
     Макроподстановкой можно задать имя массива, обозначение
компонента массива (в том числе - в языке CLIPPER - подмассива).
Например, после команд  B ="A"; C="A[1,5]"  обозначения &B[1,5],
&C и A[1,5] равносильны.
     Вложения макроподстановок. Если после подстановки выясняется,
что вставленный участок содержит знак &, производится очередная
подстановка и т.д. Когда все знаки & "изжиты", производится
макрокомпиляция, если первая макроподстановка находилась в выражении
(на месте выражения). Длина подставляемого текста не должна
превышать 255 (FOXPRO) или 254 (CLIPPER) символов.
     Пример 1.15. Двукратная макроподстановка в выражении и тексте.
  n = "Date()"
  m = "&n + 7"
 ? &m                  && Выводится текущая дата, увеличенная на 7
 ? "&m"         && Подстановка в тексте; выводится текст "Date()+7"
     В FOXPRO имеется функция Evaluate(<ВырC>), которая возвращает
значение выражения, текст <ВырC> последнего записан ее аргументом. В
примере 1.14 функцию Iif можно заменить следующей:
     Iif(Evaluate(D)= 1, Evaluate(D) + 1, Evaluate(D) ).
Функция выполняется быстрее макроподстановки.
     В CLIPPER макроподстановка применима не только к переменным,
но и к символьным выражениям (макровыражениям), заключенныым в скобки.
Подробно макроподстановки в языке CLIPPER рассматриваются в гл. 4.
     Задание 1.9. Запишите программу вывода одного (указанного
пользователем) варианта из следующих:
 1. "Служил Гаврила <хлебопеком>, Гаврила <булку испекал>",
 2. "Служил Гаврила <за прилавком>, Гаврила <флейту продавал>,
 3. "Служил Гаврила <почтальоном>, Гаврила <письма разносил>,
вставляя в основу текста варьируемые части (даны в "уголках" < >).
Объявите двумерный массив: DECLARE A[3,2] для помещения в него
варируемых текстовых значений.

           1.10. Управляющие структуры. Операторы управления

     В отличие от функции Iif оператор IF, реализуя ветвление,
непосредственно использует команды в записи ветвей:
    IF <вырL>                              && Условие выбора ветвей
    <команды>                              && Ветвь для <вырL> =.T.
    ELSE
    <команды>                              && Ветвь для <вырL> =.F.
    ENDIF
ELSE и нижележащую ветвь опускают, если действия предусмотрены лишь
для случая <вырL>=.T. Подобная структура может входить в состав
любой из ветвей, т.е. допускается вложение операторов IF.  При этом
надо внимательно следить за тем, чтобы внутренние структуры IF были
закрыты (ограничены) записью ENDIF до элементов ELSE или ENDIF
внешней структуры. Вообще, любая алгоритмическая структура может быть
вложенной в другую алгоритмическую структуру.
     Структура DO CASE представляет ветвление с несколькими ветвями,
для выбора каждой из них предусматривается отдельное условие:
     DO CASE                            && Открытие структуры
       CASE <вырL1>                     && Условие выбора 1-й ветви
       <команды>                        && Ветвь для <вырL1> = .T.
       CASE <вырL2>                     && Условие выбора 2-й ветви
       <команды>                        && Ветвь для <вырL2> = .T.
       .  .  .
       OTHERWISE                        &&   Необязательные
       <команды>                        &&              элементы
     ENDCASE                            && Граница структуры
Необязательную ветвь ниже OTHERWISE используют для действий,
которые выполняются при ложности всех условий <вырL1>, <вырL2>,... .
Всегда выполняется лишь одна ветвь (первая, для которой <вырL>=.T.)
     Пример 1.16. R - ежесуточный расход электроэнергии в некотором
непрерывном производстве; найдем суммарный ее расход Sum в течение
текущего месяца (его номер представлен переменной Mes).
    Mes = Month (Date())    && Выделение номера месяца из тек.даты
    DO CASE
       CASE Inlist(Mes, 1,3,5,7,8,10,12)            && Если 31 день
        Sum = 31 * R
       CASE Inlist(Mes, 4,6,9,11)                   && Если 30 дней
        Sum = 30 * R
       CASE Mes = 2                      && Особый случай - февраль
        .   .   .                        && Действия для февраля
    ENDCASE
    ? Str(Mes,2) + "-й месяц. Суммарный расход:", Sum
     Напоминаем, что функция Inlist() определена лишь в FOXPRO; в
языке CLIPPER запись условий будет более громоздка. Запись действий
для февраля оставляем на усмотрение читателя, который может:
а) проверить год на високосность, чтобы найти число дней в феврале;
б) с этой же целью найти разность дат  {03/01/<тек.год>} - {02/01/
<тек.год>},  предварительно функцией Year() определив <тек.год>.
     Структура цикла с предусловием имеет следующий вид:
      DO WHILE <вырL>    && Заголовок цикла с условием входа в цикл
       <команды, в числе которых            && Тело цикла, т.е.
       может быть EXIT - выход из цикла     && совокупность команд,
       и LOOP - переход  к   следующему     && повторяемых в цикле
       повторению действий тела цикла>
      ENDDO                                 && Граница структуры

     Подразумевается, что в <вырL> входят переменные, изменяющиеся
в цикле, вследствие чего оно становится ложным и происходит выход
из цикла, однако допустим и вариант заголовка цикла  DO WHILE .T.,
при котором управление окончанием цикла находится в его теле:
       IF <вырL>                         && Условие выхода из цикла
         EXIT                            && Команда выхода из цикла
       ENDIF
     Пример 1.17. В массиве Vir хранятся данные о дневной выработке
продукция, начиная с 1 числа текущего месяца; найдем суммарную
выработку Sum за все предшествующие дни месяца.

     Tek_den = Day(Date())       && Определение номера текущего дня
     Den = 1
     Sum = 0
      DO WHILE Den < Tek_den
      Sum = Sum + Vir[Den]
      Den = Den + 1
      ENDDO
    ? "Суммарная выработка продукции за ", Tek_den-1, " дней:", Sum

     Данный пример показывает особенность цикла с предусловием: его
тело может не выполняться ни разу - запустите эту программу первого
числа. Чтобы выполнить пример на ЭВМ,читатель должен описать массив
Vir и ввести в цикле воображаемые значения дневной выработки.
     Циклы с параметром в FOXPRO и CLIPPER можно записать идентично:
      FOR <параметр цикла> = <вырN1> TO <вырN2> STEP <вырN3>
       <тело цикла>
      ENDFOR                                && Граница структуры
Элемент <вырN1> задает начальное значение параметра, <вырN2> -
верхнюю границу его значений, необязательные элементы STEP <вырN3>
задают шаг приращения параметра (по умолчанию равен 1). В теле цикла
также могут быть команды LOOP, EXIT. В языке CLIPPER границей цикла
с параметром может быть NEXT, как в языке Бейсик.
     Пример 1.18. Найдем строку матрицы A, имеющей размер 5х4, в
которой максимален элемент второго столбца, и выведем ее содержимое:
   J = 1
   FOR I = 2 TO 5
    IF A[I,2] > A[J,2]                     &&   Т е л о
       J = I                               &&
    ENDIF                                  &&  ц и к л а
   ENDFOR
   ? A[J,1], A[J,2], A[J,3], A[J,4]
   CANCEL
Предполагается, что в начале программы массив A описан и его
элементы определены. Ниже приводится еще один вариант тела цикла:
 J = Iif(A[I,2] > A[J,2], I, J)   && Используем Iif для краткости.
    Если знак приращения <вырN3> не согласован с положением границ,
т.е. противоположен знаку <вырN2> - <вырN1>, цикл ни разу не
выполнится. Хотя шаг приращения параметра может быть дробным и
отрицательным, эти возможности следует использовать осторожно. Например,
тело цикла с заголовком FOR J = 0.1 TO 2 STEP 0.1 будет выполнено
19, а не 20 раз (проверено на практике) из-за положительной погрешности
значения J. Увеличим границу на пол-шага, сделав ее 2.05,
и тем самым избежим влияния погрешности: цикл выполнится 20 раз.
     Для транслятора языка CLIPPER границы структур взаимно
неразличимы, ибо анализируются лишь 3 первые буквы: E,N,D. Поэтому
любая из границ может быть записана как слово END, а реакция
транслятора на пропуск границы вложенной структуры своеобразна:
граница внешней структуры как бы становится границей вложенной
структуры и сообщается о том, что не закрыта  в н е ш н я я  структура.
     В гл. 12 дополнительно рассматривается используемая в CLIPPER
структура  BEGIN SEQUENCE  ...  END .
     Задание 1.10. Запишите заново программу вывода звуковой гаммы
(задание 1.6), используя массив для значений частот звука и
оператор цикла с параметром. Запишите также заново программу примера
1.17, используя цикл с параметром взамен цикла с предусловием и не
забывая об особенной текущей дате - первое число месяца.

                  1.11. Блочная структура программ

     В п. 1.1 вы узнали правила записи, а в п. 1.5 увидели пример
применения блока, называемого функцией пользователя в отличие от
функций системных. Обычным обращением к функции является запись
      <Имя функции> ( <Список фактических параметров> ),
которая может входить в выражения. Даже если функция не имеет
параметров, скобки обязательны,  например   Fi ().
     По месту записи блоки, т.е. функции и процедуры, можно разделить
на внутренние и внешние. Внутренние блоки записываются в одном
программном файле ( .PRG-файле) с использующими их блоками,  а
внешние - в отдельном файле. В примере 1.8 использована внутренняя
функция; ее заголовок начинается словом FUNCTION. Заголовок очередного
блока рассматривается как нижняя граница текста предыдущего блока.
     Внутренняя процедура снабжается заголовком (первая ее строка)
                   PROCEDURE  <имя процедуры>
и по сути отличается от внутренней функции тем, что у нее нет
результата, который бы обозначался ее именем; в ней оператор
возврата RETURN (п.1.1) либо не записывается, либо в нем отсутствует
выражение. Обращением к процедуре является команда вызова процедуры
   DO <Имя процедуры> WITH <Список фактических параметров> .
Впрочем, так же можно обращаться и к функции, если нас не интересует
возвращаемое ею значение. Если блок оформлен без параметров,
т.е. в нем нет команды PARAM, в команде DO элементы   WITH <список
параметров> не записывают.

    Пример 1.19.  DO proc1            && Здесь главный блок служит
                  CANCEL        && лишь для вызова процедуры proc1
              PROCEDURE proc1
              ? "РАБОТАЕТ ПРОЦЕДУРА PROC1"       && Тело процедуры
     Число фактических параметров в обращении к блоку не должно
превышать число формальных параметров. Избыточные формальные пара-
метры автоматически получают пустое значение NIL (в языке CLIPPER)
или .F. (в языке FOXPRO). Зная это, нетрудно реализовать правило
умолчания, т.е. задавать неопределенным параметрам значения в самом
блоке, если пользователь не указал значения в обращении к блоку.
     Блок, прямо или косвенно (через другие блоки) вызываемый из
данного блока, считается подчиненным данному блоку - его подблоком.
     Часто используемые процедуры и функции имеет смысл объединить
в отдельный .PRG-файл, называемый процедурным. Запись содержащихся
в нем внешних блоков производят по указанным выше правилам. Для
пользования этими блоками необходимо сначала подключить (открыть)
процедурный файл командой SET PROCEDURE TO <имя процедурного файла>.
В каждый момент открытым может быть лишь один такой файл, поэтому
очередная команда, открывая другой процедурный файл, автоматически
закрывает предыдущий. Закрыть процедурный файл можно также командой
 SET PROCEDURE TO   без указания имени файла.
     Блок, занимающий отдельный файл, заголовком можно не снабжать,
тогда в обращении к нему указывают имя файла, выполняющее роль имени
блока. Использование для блоков таких "персональных" файлов не
рекомендуется из-за снижения производительности, ибо файл загружается
в память всякий раз при вызове хранимого в нем блока.
     Пример 1.20. Файл с именем MINIMUM представляет внешнюю функцию
без заголовка:
****** ПРОГРАММНЫЙ ФАЙЛ MINIMUM.PRG ******     Всего три строки !
  PARAMETERS U,V
  RETURN  Iif(U<V, U, V)             && Конец файла и блока MINIMUM

Например, если надо вывести минимальное из значений A,B, записываем
команду   ? MINIMUM (A,B)     && Не забывайте, что это блок-функция
     В FOXPRO непосредственно доступными являются не только блоки
текущего программного файла, но и блоки файлов, из которых прямо
или косвенно произведен вызов блока текущего файла. Более того,
командой DO можно обратиться к блоку в составе иного файла, но в
этом случае в конец команды надо добавить элементы IN <имя файла>.
Особенности блочной структуры в языке CLIPPER рассмотрены в гл. 4.
     Задание 1.11. Составьте программу нахождения минимального среди
максимумов строк двумерного массива A[8,5]; выделите в ней внутренние
блоки нахождения максимума и минимума.

               1.12. Области действия переменных.
         Сохранение в файле и восстановление переменных

    Переменные, действующие в блоке, действуют и в подчиненных
блоках (подблоках), исключая те переменные, имена которых совпадают с
именами, описываемыми в подчиненных блоках, ибо новое описание
создает и новую переменную. Для описания используют оператор PRIVATE:
              PRIVATE <Список имен переменных>.
Оператор PRIVATE порождает переменные, существующие до
момента возврата из блока, содержащего этот оператор. Если до входа
в данный блок существовали переменные, одноименные с описываемыми,
они не уничтожаются, а переводятся в скрытое состояние до момента
завершения работы блока, когда вновь становятся доступными.
     Кроме переменных класса PRIVATE, имеются PUBLIC-переменные,
существующие, пока не закончит работу программа, и доступные в
любом ее блоке с оговоркой, рассмотренной выше. Переменные класса
PUBLIC могут быть порождены в любом блоке. Более того, в FOXPRO
их можно породить отдельной командой до запуска программы. Этот
класс переменных удобен при отладке программы; заменив в описании
слово PRIVATE на PUBLIC, мы делаем внутренние переменные блока
доступными для рассмотрения  и после возврата из него на внешний
уровень. В операторах PUBLIC, PRIVATE языка CLIPPER можно иметь
описания массивов (как в DECLARE, п. 1.7), т.е. порождать массивы;
например PRIVATE z, A[2,5].
     Во избежание непредсказуемых эффектов не следует использовать
для PUBLIC-переменных имена, обозначавшие ранее другие переменные
данной программы. Появление имени не описанной прежде переменной
означает автоматическое порождение PRIVATE-переменной,
однако этим следует пользоваться разве что в главном блоке.
     Явное описание PRIVATE-переменных в блоках устраняет ошибки,
вызываемые случайным совпадением имен переменных, используемых в
разных блоках. Описание переменных должно предшествовать их
использованию; рекомендуется операторы PRIVATE и PUBLIC для большей
наглядности помещать в начале блоков, после заголовка.
     Время жизни PUBLIC- и PRIVATE-данных может быть усечено
указанием их имен в команде  RELEASE <Список переменных, массивов> ,
удаляющей указанные переменные и массивы, действующие в данном блоке.
Команда CLEAR MEMORY уничтожает все множество PUBLIC- и PRIVATE-данных
независимо от места и времени их создания. Это делают для освобождения
занятой ими памяти с целью увеличения объема памяти, доступного для
дальнейшего использования в программе.  Команда RELEASE с атрибутом
ALL (все варианты) исключает PRIVATE-данные (в FOXPRO также PUBLIC-
данные). В CLIPPER она заменяет значения PRIVATE-данных на NIL,
а освобождение памяти, занятой этими данными, происходит по окончании
работы текущего блока. Рассмотрим варианты команды.
      Команда RELEASE ALL LIKE <Маска>  удаляет переменные и массивы,
имена которых отвечают заданной символьной маске (см. п. 1.4).
Например, команда RELEASE ALL LIKE *tom?  удаляет все переменные,
в конце имени которых имеется сочетание "tom", а за ним - произвольный
символ. Напротив, команда  RELEASE ALL EXCEPT <Маска>  удаляет все
переменные и массивы, имя которых не отвечает заданной маске.
RELEASE ALL удаляет все переменные и массивы текущего блока.
     Освобождение памяти может быть временным: множество переменных
запоминают в файле, затем их удаляют из памяти, а когда они
понадобятся для дальнейших действий, их восстанавливают, загружая
в память из файла. Сохранение переменных в файле осуществляет
команда        SAVE TO <Имя файла, используемого для сохранения>,
эта команда может использовать маску так же, как команда RELEASE.
Примеры:      SAVE TO  Spas  ALL LIKE *tom? ;      SAVE TO Hran .
     По умолчанию создаваемый файл получает расширение имени .MEM .
Только FOXPRO допускает указание массивов в команде SAVE для их
записи на диск. Реализуемая с помощью специальных блоков возможность
сохранения и восстановления CLIPPER-массивов рассмотрена в гл. 10.
     Восстановление (загрузку) переменных выполняет команда
             RESTORE FROM <Имя файла>  ADDITIVE ,
необязательный атрибут ADDITIVE препятствует автоматическому
уничтожению переменных и массивов, имевшихся в памяти на момент
загрузки, т.е. происходит добавление переменных из файла к существующим.
     Пример: RESTORE FROM Spas  && Память очищается от переменных,
а затем в нее загружаются переменные, хранившиеся в файле Spas.
     Загружаемые переменные получают статус PRIVATE-данных в текущем
блоке, следовательно, автоматически уничтожаются по завершении
его работы. Если какое-либо из их имен совпало с именем PUBLIC-
переменной и в команде имеется атрибут ADDITIVE, эта PUBLIC-переменная
получает новое значение, а PRIVATE-переменная не создается.
    В языке FOXPRO имеется команда DISPLAY MEMORY для обзора активных
переменных и массивов: указываются имя, класс, значение переменной.
Могут быть добавлены атрибуты  LIKE <маска>  и   TO PRINTER
(вывод на принтер) или  TO FILE <Имя файла> (вывод в файл). Пример:
команда    DISPLAY MEMORY  LIKE *  TO PRINTER    выводит на принтер
переменные, исключая системные, - это и обозначает атрибут  LIKE *.
    Задание 1.12. Запишите команду уничтожения всех переменных, имя
которых содержит фрагмент "HRU".

       1.13. Вывод командами "?","??". Преобразования при выводе

     Вывод значений заданного списка выражений, имеющих тип C,N,L,D
или M (MEMO-поле), легко и удобно реализуется командами "?", "??":
        ? <Список выражений> ,          ?? <Список выражений> ,
которые различаются лишь тем, что команда "?" перед выводом выполняет
перевод строки. Для вывода пустой строки надо записать один
лишь знак "?". Выводимые слева-направо значения разделяются пробелами;
в FOXPRO вывод этих пробелов можно исключить командой SET SPACE OFF,
а когда потребуется - восстановить исходный режим командой SET SPACE ON.
     При заполнении строки возникает автоматический переход на новую
строку. Если текущей была самая нижняя строка экрана, то при выводе
командой "?" возникает скроллинг - сдвиг содержимого строк экрана на одну
строку вверх всякий раз, когда заполняется строка. В языке CLIPPER
имеется функция Setpos(Y,X) для задания позиции курсора. Указывая с
ее помощью строку Y, можно избежать скроллинга. Не следует только
указывать последнюю строку, ибо команда "?" начинает с перевода строки.
     Перед выводом все значения автоматически преобразуются в строки.
Возможны и специальные преобразования, реализуемые функцией
       Transform ( <Выводимое выражение>, <SAY-шаблон> ) .
SAY-шаблон - это строка, определяющая форматное преобразование.
Имеются две возможности, реализуемые совместно или по отдельности,
а именно, задание функций форматирования и задание так называемой
маски, посимвольно представляющей формат вывода.
     Строка функций форматирования начинается со знака"@" и содержит
один или несколько специальных символов, указанных в табл. 1.4.
                                                       Таблица 1.4
____________________________________________________________________
 Символ                Д е й с т в и е
--------------------------------------------------------------------
 B      Выравнивает числа по левому краю (если в маске нет $,*)
 C      Выводит "CR" после положительных чисел
 X      Выводит "DB" после отрицательных чисел
 Z      Выводит нулевое значение как строку пробелов
 (      Выводит модуль отрицательного числа в скобках ( )
 )      То же, что и для "(", с подавлением пробелов (CLIPPER)
 D      Выводит дату в формате, установленном в SET DATE
 E      Выводит дату в формате British (английском)
 E      Выводит число с запятой вместо десятичной точки (CLIPPER)
 ^      Выводит число в экспоненциальной форме (FOXPRO)
 R      Разрешает писать в маске любые символы, помимо указанных
        в табл. 1.5, с целью их явного воспроизведения
 !      Воспроизводит буквы в верхнем регистре (прописные)

Строка формата - маска   представляет тем или иным символом
каждую позицию выводимой строки, например, маска "99.9" показывает,
сколько цифр числа следует изобразить (3 цифры) и как они расположены
по отношению к точке. При совместном использовании строку функций
и строку формата следует записывать через пробел как  о д н у
строку, начиная с функций, например: ? Transform("ram","@!R A A A").
Эта команда выведет "R A M",  ибо функция "!"  обеспечит прописные
буквы, а функция "R"- разрешит "посторонние" символы среди них,
которыми в данном случае являются пробелы. Буквы показаны в шаблоне
знаками "A". Роль используемых в маске символов указана в табл. 1.5;

                                                      Таблица 1.5
__________________________________________________________________
 Символ                Р о л ь   с и м в о л а
-------------------------------------------------------------------
A, N, X, 9, # Резервирует место для одного знака исходной строки
9, #          Резервирует место для знака (цифры) в данных типа N
$             Выводит знак $ вместо ведущего пробела в данных типа N
.             Обозначает позицию десятичной точки в данных типа N
,             Обозначает позицию десятичной запятой в данных типа N
*             Выводит знак * вместо ведущего пробела в данных типа N
!             Обозначает позицию для вывода буквы в верхнем регистре
L   (Y)       Выводит значение типа L как "T" или "F"  ("Y" или "N")
--------------------------------------------------------------------
     Еще один пример применения функции R для вставки:   команда
           ? Transform("3627774", "@R  тел.999-99-99")
выводит "тел.362-77-74". Вместо знака "9" в маске можно было бы
использовать "A","N","X" или "#" (при  в ы в о д е  разницы нет).
     В языке FOXPRO имеется расширенный синтаксис команд "?","??":
   ? <Список элементов вывода> ,  ?? <Список элементов вывода> ,
где элемент вывода - сочетание следующих необязательных элементов:
 <Выводимое выражение>  PICTURE<вырC>  FUNCTION<вырC>   AT <вырN>
<вырC> представляет SAY-шаблон (используем либо PICTURE<вырC>, либо
FUNCTION<вырC>; в последнем случае можно не иметь знак @ в <вырC>).
<вырN> задает номер колонки, начиная с которой производится вывод.
Пример:  ? "3627603" PICTURE "@R тел.999-99-99"   && тел.362-76-03.
  Новая функция V<n> в FOXPRO позволяет выполнять вывод в вертикальную
полосу шириною n колонок, что удобно при выводе головки таблиц.
Пример:  ? "РАЗРЯД" PICTURE "V3" AT 5, "ОПЛАТА" PICTURE "V2" AT 11
По этой команде возникает следующая картина вывода:
     РАЗ   ОП
     РЯД   ЛА
           ТА
Возможный следующий вывод будет производиться ниже самого нижнего
из фрагментов слов, выведенных данной командой.
     По умолчанию вывод происходит на дисплей. Чтобы направить
поток вывода на принтер, надо выполнить команду     SET PRINTER ON,
а если мы хотим при этом отключить вывод на дисплей, дополнительно
даем команду SET DISPLAY OFF. Вместо принтера поток вывода можно
направить в файл, записав дополнительно команду
          SET PRINTER TO <Имя файла с расширением>.
     Прежнее содержимое файла будет стерто; если же вы хотите
дополнить файл, добавьте в конец этой команды атрибут ADDITIVE.
     Итак, возникает следующая схема записи программы:

   SET PRINTER ON             && Разрешение на вывод помимо дисплея
   SET PRINTER TO text.txt    && Назначение для вывода файла text
   < Получение информации, подлежащей выводу. Вывод >
   SET PRINTER TO             && Файл text.txt закрывается
   SET PRINTER OFF            && Отключение потока вывода

     В отсутствие последней команды дальнейший вывод, кроме дисплея
(который мы не отключали), будет идти на принтер. Если между первыми
двумя командами будет записан вывод, то он также пойдет на принтер,
поскольку еще не произошло назначение файла вывода.
     Для вывода больших объемов текстовой информации удобно использовать
команду TEXT:

       TEXT
    <текстовая информация, например головка таблицы>
       ENDTEXT                     && Граница текстовой информации
     В дальнейшем вы узнаете, как при необходимости включать в этот
текст варьируемые части (например, фамилию в текст приглашения).
    Задание 1.13. Имеется некоторый документ, представленный строкой
S. Нужно вывести ее в файл, а затем на принтер в одинаковом виде:
начиная с 7-й колонки вертикальной полосой, имеющей ширину 40 позиций.
На дисплее документ не отображать, но перед его выводом надо высветить
на дисплее надпись "Включите принтер" и дать звуковой сигнал (п.1.6).
Составьте соответствующую программу, полагая, что строка S вводится.

        1.14. Ввод-вывод данных командами @ ...SAY ...GET

     Назовем координатами номер строки Y (для дисплея Y= 0..24) и
номер колонки X (для дисплея X= 0..79). В командах Y и X задают как
выражения; примеры: а) 5, 9;  б) Y, X;  в) Row(), Col()+5  (функция
Row() возвращает номер текущей строки, Col() - номер колонки).
     Координаты Y1,X1 верхнего левого и Y2,X2 нижнего правого угла
прямоугольника, заполняемого на экране пробелами, указывают в команде
очистки области экрана       @ Y1,X1 CLEAR TO Y2,X2  .
В отсутствие координат Y2,X2 команда очищает прямоугольник, нижний
правый угол которого совпадает с нижним правым углом экрана. Самый
краткий вариант  @ Y1,X1  очищает строку Y1, начиная с колонки X1.
     Команда CLEAR очищает весь экран, а  вместе с тем и список
Getlist (см. гл. 7);  в  языке  CLIPPER  также  имеется  команда
CLEAR SCREEN (сокращенно CLS), равносильная     @ 0,0 CLEAR TO .
В любом случае после очистки курсор оказывается в левом верхнем
углу очищенной области. Таким способом можно задать начальную позицию
вывода, выполняемого командой "??"  (команда "?" переводит строку).
     Пример.  @ 9,0            && Независимо от исходного положения
       ?? "ПРОСТО ПРИМЕР"    && курсора вывод начнется в 9-й строке
     Команды  @ ... SAY ... GET  предоставляют возможность ввода-
вывода по заданным координатам в удобном формате и цвете с сопутствующими
проверками вводимых данных. При полном использовании возможностей
одна такая команда заменяет несколько простых команд. Здесь
мы рассмотрим основные возможности, в гл. 7 эти сведения будут
дополнены. Усеченная команда (без GET и последующих элементов)
         @ Y,X  SAY <выр>  PICTURE <вырC1>  COLOR <вырC2>
выводит отформатированное по SAY-шаблону (см. п. 1.11) значение
<выр> символами заданного цвета в поле заданного цвета. Если атрибуты
PICTURE, COLOR не заданы, используется формат и цветовые характеристики
по умолчанию. Перенос на новую строку не предусмотрен.
     Примеры.  @ 5,10 SAY "День недели:" + CDOW(Date())
      @ 7,0 SAY Diskspace()  && Вывод числа свободных байт на диске
     Информацию, состоящую из разнотипных элементов, можно свести в
одно выражение, приводя их к символьному типу.
     Пример 1.21. Выведем головку таблицы "1 курс  2 курс ... 5 курс"
   @ 1,7  CLEAR TO               && Очистили рабочую часть экрана,
   FOR J = 1 TO 5           && причем текущей становится 1-я строка
   @ Row(), Col()  SAY  Str(J) +" курс"
   ENDFOR
     Для понимания примера необходимо знать, что после каждого акта
вывода курсор оказывается справа от выведенных данных, поэтому
значение Col() в цикле изменяется; пробелы перед номером курса
возникнут автоматически, ибо по умолчанию функция Str отводит для
строчного представления числа 10 позиций.
     Элементы, записываемые в команде после слова GET, используются
для ввода и могут быть оформлены как самостоятельная команда:
@ Y,X GET <переменная или поле записи> PICTURE<вырC1> COLOR<вырC2>;
         WHEN <вырL1>  RANGE <min>,<max>  VALID <вырL2> ,
причем обязательны лишь элементы слева от слова PICTURE, другими
словами, имя вводимой переменной или поля записи должно указываться.
Более того, этой переменной (GET-переменной) предварительно должно
быть задано значение, хотя бы ноль или строка пробелов (но не пустая
строка). Необязательные элементы будут пояснены на примерах.
     Команда (часть команды) со словом GET, обеспечивает оформление
поля ввода, называемого GET-полем; в частности, происходит занесение
в GET-поле исходного значения переменной (оно должно существовать,
хотя бы пустое).  Фактически ввод состоится, только если за
командами @ ... GET идет команда READ (возможно отделенная от них
несколькими командами). При выполнении READ начинает мерцать курсор
в GET-поле, приглашая к набору значения GET-переменной. Присвоение
ей набранного (скорректированного) значения происходит при нажатии
клавиши Enter или по заполнении последней позиции GET-поля.
     Если в одной команде используются и SAY, и GET, координаты
указывают лишь в ее начале; GET-поле будет выводиться на один
пробел правее информации (значения) SAY-выражения; <вырC1> и <вырC2>
задают соответственно GET-шаблон (подобный SAY-шаблону) и цветовые
характеристики GET-поля.
     Пример 1.22.  Y = Space(30)    && Резервируем 30 позиций для Y
        @ 5,8 GET Y PICTURE "@!"  && Буквы будут введены прописными
     Пример 1.23.  Otvet = "Yes"     && Задание ответа по умолчанию
  @ 9,6 SAY "Введите Ваш ответ: Yes, No"  GET Otvet  PICTURE "@K"
В данном примере используется функция формата "@K", обеспечивающая
стирание в GET-поле ответа по умолчанию ("Yes"), если пользователь
начал набор ответа в поле ввода. Если же ответ "Yes" его устраивает,
он нажимает клавишу Enter.
     Необязательные элементы. Представим, что в базе данных появилось
новое поле DevFam - "Девичья фамилия". В программе, реализующей ввод
в это поле значений, следует его выполнять лишь для тех
персон женского рода, семейное положение которых "Б"(в браке) или
"Р"(разведена). Предусловие, записываемое после "WHEN", будет
проверять пол на равенство значению "Ж" и семейное положение на
равенство "Б" или "Р". Если предусловие ложно, ввод в GET-поле
автоматически пропускается; в GET-поле не появится мерцающий курсор.
     Выражения "min","max" после слова RANGE представляют наименьшее
и наибольшее из возможных значений GET-переменной. Если вводимое
значение выходит из заданного диапазона, то нажатие клавиши
Enter или заполнение последней позиции GET-поля вызывает звуковой
сигнал и указание диапазона в правом верхнем углу экрана; значение
GET-переменной не изменяется. В языке FOXPRO любая из границ может
быть опущена, тогда смыслом проверки будет "не больше"("не меньше").
     Логическое выражение, записываемое после VALID (постусловие),
позволяет записывать сколь угодно сложную проверку вводимого значения
(в постусловии можно использовать функцию пользователя), причем
в отличие от проверки на диапазон  значение по умолчанию также
подвергается контролю - когда пользователь нажимает клавишу Enter.
     И при проверке на диапазон, и при проверке постусловия процесс
ввода не завершается до тех пор, пока пользователь не даст правильного
значения GET-переменной: до этого нажимать Enter бесполезно.
     GET-шаблон строится по тем же правилам, как и SAY-шаблон (см.
п. 1.13). В функциях форматирования, кроме символов, указанных в
табл. 1.4,  используются следующие специальные символы:
 A - разрешает только буквы при вводе строки символов;
 K - заменяет значение по умолчанию пробелами (см. пример 1.23),
только если первой нажатой клавишей не является клавиша управления
курсором, т.е. оставлена возможность редактирования значения по умолчанию;
 S<размер GET-поля>  - определяет меньший, чем длина редактируемой
строки, размер GET-поля; нажатиями клавиш  ->, <-  можно осуществлять
"прокрутку" текста строки в GET-поле, как своего рода окне.
     В маске символ A маскирует букву, 9 - цифру, а N - букву или
цифру; ввод иного символа в соответствующую позицию блокируется.
Символ X разрешает ввод любых знаков, а символ # - ввод цифр, знака
числа или пробела. Пример: маска "AAA#99#99" может быть использована
для ввода автомобильного номера. Поскольку дефис и знак числа
изображаются одним знаком, мы применили символ #, маскируя дефис.
     Необязательный атрибут COLOR объясняется в п. 7.1.
     Задание 1.14. Осуществите вывод в кратном цикле с помощью
одной команды SAY элементов числового массива A в следующем виде:
      A(1,1) = ...        A(1,2) = ...       A(1,3) = ...
      A(2,1) = ...        A(2,2) = ...       A(2,3) = ...
(троеточиями показано место вывода значений элементов).

            1.15. Создаем световые меню - PROMPT-меню

     PROMPT-меню предлагает выбор из нескольких пунктов меню (до 32
в CLIPPER, до 128 - в FOXPRO), каждый из которых представляет строку
символов, например "Создание", "Корректировка" и т.п. Один из
пунктов выделен (подсвеченный прямоугольник), его назовем активным. 
Чтобы сделать активным другой пункт, прямоугольник "надвигают" на
него клавишами управления курсором. Активный пункт становится
выбранным пунктом при нажатии клавиши Enter.
     Команд PROMPT столько, сколько пунктов, и они размещают пункты
меню, ибо в каждой из них заданы координаты Y,X левого края пункта:
              @ Y, X PROMPT <ВырC1> MESSAGE <ВырС2>,
<ВырC1> представляет текст пункта, необязательные элементы MESSAGE
<ВырC2> обеспечивают выдачу пояснения к пункту меню. Пункты меню
получают номера (неявные) по порядку следования команд PROMPT.
Координаты Y, X могут быть относительными, например: @ ROW(), COL()+5,
где ROW(), COL() - номера текущих строки и столбца. Надо иметь в
виду, что после выполнения команды PROMPT курсор справа от пункта.
     Команда MENU TO <Переменная> делает активным 1-й пункт меню,
включает механизмы перемещения по меню и выдачи пояснений, а когда
выбор сделан, присваивает <Переменной> номер выбранного пункта
(если нажатием Esc осуществлен отказ от выбора, присваивается 0).
Начинают выполняться следующие команды, где <Переменная> используется
как управляющая в структуре DO CASE ... ENDCASE или IF ... ENDIF.
     Пример 1.24. Вертикальное меню из двух пунктов:
   @ 5,21 PROMPT "Создание базы данных"
   @ 7,21 PROMPT "Наполнение базы данных"
     MENU TO j  //Присвоение переменной j номера выбранного пункта
   DO CASE
      CASE j = 1
     <Действия по созданию базы данных>
      CASE j = 2
     <Действия по наполнению базы данных>
   ENDCASE
     Мы могли бы добавить атрибут MESSAGE, например, в 1-ю команду:
@ 5,21 PROMPT "Создание базы данных" MESSAGE "Запись структуры базы"
Добавленное пояснение высвечивается в строке с номером <ВырN>,
только если до команды MENU TO j записана команда  SET MESSAGE TO <ВырN>
CENTER. Необязательный атрибут CENTER задают, если сообщение надо
центрировать в строке. Команда SET MESSAGE TO без аргумента отменяет
вывод сообщений. В CLIPPER команда SET WRAP ON  обеспечивает цикличность
обегания меню (от последнего пункта переход к первому и наоборот).
     Пункты PROMPT-меню можно размещать произвольным образом.
     Задание 1.15. Сделайте и испытайте горизонтальное меню с
пунктами "КАЗНИТЬ", "НЕЛЬЗЯ", "ПОМИЛОВАТЬ", причем для пункта "КАЗНИТЬ"
сделайте вертикальное подменю с пунктами "ПРЕЗРЕНИЕМ", "ДИФФАМАЦИЕЙ"
и т.п. Используйте относительные координаты. К пункту "КАЗНИТЬ"
выводите пояснение в 24-й строке (примените атрибут MESSAGE):"Имеется
в виду не физическая, а моральная казнь". Пункт "НЕЛЬЗЯ" используйте
для выхода из меню.

                ЗАКЛЮЧЕНИЕ К 1-Й ГЛАВЕ. ЗАДАНИЯ

     При рассмотрении основ языка в данной главе нами показана
общность языка систем CLIPPER и FOXPRO. Принципиальные различия и
различия в возможностях рассматриваются во 2 и 3 разделах книги.
Каждая из тем,  будь то выражения языка, блочная структура программ,
переменные, присваивание и ввод-вывод, GET-система, получит развитие
в последующих главах.
     Если вы выполнили задания, вами достигнут начальный уровень
подготовки, позволяющий строить одноблочные программы и программы с
простейшими процедурами, пока без использования файлов баз данных,
и выполнять их на ЭВМ. Уделите особое внимание работе со строками,
ибо в базах данных символьный тип доминирует над другими.
     Если вы не смогли выполнить какое-либо из заданий, тщательно
изучите ответ к нему (в конце книги). Не лишним будет делать это
всегда, когда ваша реализация задания не совпадает с ответом,
будучи, возможно, правильной. Поступите так и при выполнении
следующего ниже задания.
     Задание 1*. Используя команды @ ... SAY, @ ... GET и структуру
DO CASE, постройте простейшее меню для выбора одного из действий:
   а) уменьшения переменной K на 1;      б) ее увеличения на 1;
   в) вывода ее значения в 7-й строке с 9-й колонки командой "??".
Команды SAY примените для вывода пунктов меню   "1. Уменьшение",
"2. Увеличение", "3. Вывод",  команду  @ ... SAY ... GET  - для
указания (ввода) номера выбранного пользователем пункта. Этот номер
используйте как управляющую переменную в структуре DO CASE...ENDCASE.
     Получив работающее меню, обдумайте изменение программы,
обеспечивающее использование меню для последовательного, возможно,
неоднократного выбора каждого из указанных действий.
     Задание 2*. Составьте циклическую программу для получения
значений функции Sin(x)/x  для x = 0.1, 0.2, 0.3, ... ,PI,  сохраните
таблицу как текстовый файл (см. п. 1.13) и выведите на  принтер,
располагая в  строке по 10 значений. Проанализируйте возможности
наглядного оформления таблицы, например печатания в отдельной строке
значений аргумента x.

