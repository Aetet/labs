      22. ИСПОЛЬЗУЕМ ОТЛАДЧИК И ОБРАБАТЫВАЕМ ОШИБКИ В FOXPRO

    О методике отладки и задачах отладчика вы прочли в п. 14.1.
Рассмотрим в данной главе, как эти задачи реализуются в FOXPRO.
Чтобы упростить изложение, мы обозначаем терминами "точка останова"
и "точка прерывания" различные сущности.

                   22.1. Выполняем трассировку

    Как и в CLIPPER, участок программы может выполняться в
автоматическом (обычном) режиме, в режиме анимации и пошаговом
режиме (см. п. 14.1).
    Включение отладчика можно предусмотреть при подготовке
программы: мы включаем в нее команду SET STEP ON перед участком,
который вызывает сомнения, т.е. должен трассироваться. После
запуска программы и выполнения части, предшествующей SET STEP ON,
эта команда вызовет останов, активизирует отладчик и откроет окно
Trace с текстом программы, где следующая команда будет обозначена
маркером как подлежащая выполнению:
                     T r a c e
        Program   Resume   Out   Over   Step
       ---------------------------------------
         <Текст программы, в котором строка
          очередной (но еще не выполненной)
          команды обозначена прямоугольным
                    маркером>
       ---------------------------------------
       <Имя программы>
    "Горячие" буквы меню мы изобразили жирно. В действительности они
белые. Пункт Program есть и в системном меню FOXPRO. В данном
изложении речь идет о пункте меню Trace. После "горячей" буквы, в
скобках, будет указываться обозначение пункта меню.
     Итак, для выполнения каждой следующей команды мы нажимаем
"горячую" букву S (Step) или v (Over). Разница лишь в выполнении
команд DO: при нажатии v вызываемая подпрограмма выполняется "разом",
а S вызывает переход маркера в ее тело для выполнения по шагам.
Когда все сомнительные точки программы пройдены, мы можем
 а) прекратить выполнение: нажимая P (Program), входим в подменю и
выполняем подпункт Cancel;
 б) закончить выполнение программы в автоматическом режиме (например,

                             - 2 -
для получения конечных результатов): нажимаем O (Out);
 в) повторить трассировку, например с другими данными: выполняем п.
"а" или "б", при этом в меню пункт "Resume" окажется заменен "Do ...".
Нажимаем D (Do ...), появляется окно Do Program File со списком
программных файлов. Наводим маркер на имя отлаживаемой программы,
нажимаем Enter. В окно Trace вызывается ее текст, где 1-я команда
обозначена маркером, причем пункт "Do ..." заменяется "Resume".
Нажимаем R и программа выполнится до SET STEP ON. Дальнейшее известно.
    Можно вызывать программу в окно и через подменю Program (подпункт
Open). Окно Trace убирается нажатием Esc.
    Открытие окна Trace через системный интерфейс. Выбираем подпункт
Window/Trace и вызываем в появившееся окно Trace программу, как в п."в".
    Трассировка в режиме анимации. До (после) вызова текста программы
или после ее останова, на любом шаге, нажимаем Ctrl+R (или выбираем
подпункт Throttle в подменю Program, который вначале за пределами окна
подменю). В появившемся окне Execution Throttle указываем задержку
(интервал между командами - в секундах) и выбираем <OK>. Теперь нажатие
R (Resume) будет продолжать выполнение программы в режиме анимации,
а нажатие  O (Out) - в обычном автоматическом режиме.
    Задание 22.1. Осуществите различные варианты трассировки несложной
программы, используя и различные способы загрузки ее текста в окно.

           22.2. Точки останова. Наблюдаем и изменяем данные

    Если программу можно разделить на части "бесспорно правильные" и
"сомнительные", следует на стыке частей сделать точки останова. Тогда
вы будете иметь возможность те или иные части выполнять в
автоматическом режиме, а другие - по шагам или в режиме анимации.
Трассировка в чистом виде используется редко. Обычно ее сочетают с
наблюдением данных (отслеживают изменения). В таком случае точки
останова назначают во всех пунктах, где имеет смысл оценка
промежуточных результатов.
    Трассировка по точкам останова. После загрузки программы
(используем Do ...) нажимаем R и программа выполняется до 1-й
точки останова. Соответствующая ей команда, обозначенная маркером,
еще не выполнялась. Если нужно выполнить, нажмите S. Следующие
нажатия R выведут на очередные точки. В эти моменты можно проверять
значения переменных и выражений.
    Установка и отмена точек останова. После загрузки программы,
в любой момент ожидания клавишных воздействий, можно переместить

                             - 3 -
курсор на выбранную вами строку программы и нажать клавишу пробела,
устанавливая точку останова (обозначается ромбиком слева).
Повторное нажатие клавиши пробела ликвидирует точку останова
(ромбик удаляется). Отмену сразу всех точек останова выполняет
подпункт меню Program/Clear Breakpoints.
    Наблюдение данных. В любой момент ожидания выбираем подпункт
Window/Debug главного меню. Появляется и становится активным окно
Debug, разделенное вертикалью. Слева будем записывать точки просмотра
- интересующие нас выражения, хотя бы и переменные, а справа будут
показаны их значения. Системные функции, например Recno(), Found(),
и выражения, их содержащие - допустимые точки просмотра. После
записи точки обязательно нажмите Enter. Возврат в окно Trace, переход
в окно команд или повторную активизацию окна Debug выполняем с помощью
Ctrl+F1. Для удаления точки просмотра нажимаем Ctrl+BackSpace, когда
курсор находится под ее записью.
    Пример с постепенным назначением остановов. Допустим, о
правильности или ошибочности выполнения можно судить по некоторой
совокупности данных, изменяемых множеством команд. Применим
дихотомию при поиске ошибки. Назначим останов в середине сомнительного
участка и точки просмотра. После останова оценим правильность.
Если все правильно, следующий останов назначим в середине 2-й
половины участка, иначе - в середине 1-й половины и т.д. Всегда две
назначенные последними точки останова будут парой типа "правильно-
неправильно". Когда число команд между ними станет невелико, "пройдем
пешком" от одной к другой, нажимая S (Step) и контролируя данные.
    Изменение данных в ходе отладки. Если при проверке сложной
программы получены неверные промежуточные результаты, не торопитесь
с отменой выполнения. Возможно, вы сэкономите время, "на ходу"
исправив их, чтобы наблюдать следующие этапы работы. В командном
окне доступны все действующие переменные и массивы. Перейдите в него
и присвойте им новые значения. При этом можно пользоваться и
"посторонними" подпрограммами, в обращении к которым (команда DO)
параметрами будут эти переменные и массивы. Замену данных можно
применить и при тестировании тех блоков программы, которые иначе
проверялись бы на недостаточном множестве вариантов входных данных.
    Можно изменять поля открытых БД, причем не только в текущих
записях, не забывая восстанавливать статус БД и, в частности,
возвращаться к прежним текущим записям.
    Теперь можно дать обзор пунктов подменю Program:
 - Open ... (^E) загружает файл программы (как и пункт Do ...);

                             - 4 -
 - Cancel  прекращает дальнейшую работу остановленной программы;
 - Line Numbers (^L) обеспечивает нумерацию строк программы;
 - Сlear Breakpoints (^B) отменяет все точки останова;
 - Trace Between Breaks устанавливает трассировку по точкам останова;
 - Throttle ... (^R) устанавливает интервал между командами (0..5.5 с);
 - <Имя программы> возвращает в окно Trace участок программы со
строкой, отмеченной маркером, если курсор переместили на другие
страницы. То же произойдет при нажатии "горячей" буквы S.
  Примечание. Указанные в скобках эквиваленты действуют лишь
при активном окне Trace.
    Задание 22.2. Исследуйте работу программы из задания 22.1,
перемежая выполнение ее по шагам с изменением данных в окне
команд.

          22.3. Применяем остановы, управляемые событиями

    Простейшее "событие" - это изменение значения переменной.
Точки просмотра можно сделать точками прерываний: сразу после
изменения значения точки просмотра будет происходить останов.
При этом маркер будет обозначать команду, следующую за командой
изменения. Иногда мы недоумеваем, откуда взялось то или иное
значение. Многократно нажимая R (если изменения производит не
одна команда или команда изменения стоит в цикле), мы рано или
поздно увидим его возникновение.
    При изменении значения точки прерывания в правом верхнем
углу экрана появляется сообщение "Do suspended" о приостановке
программы. Можно проанализировать ситуацию, выполнить, если
нужно команды и затем вернуться в окно Trace.
    Порождение точек прерываний. Сначала создаем точки просмотра.
Затем, находясь в окне Debug, нажимаем Tab. На вертикальной
линии, делящей окно, возникает маркер. Перемещаем его в нужную
строку и нажимаем клавишу пробела. На маркере возникает ромбик.
Перемещая маркер в другую строку, можем создать еще одну точку
прерываний и т.д. Аналогичным образом отменяем точку прерываний.
Ромбик в ее строке исчезает.
    Окном Debug с точками прерываний можно пользоваться и в
отсутствие окна Trace, хотя это и неудобно. При останове на
точке прерывания активизируется окно команд. Данные три окна
почти полностью перекрывают экран с результатами, однако имеется
простая возможность: нажать Ctrl+Alt+Shift (экран откроется) и

                             - 5 -
придерживать их. Когда мы их отпустим, окна вновь появятся.
    Пример 22.1. Необходимо разобраться с ошибками обработки
записей в рабочей области "B". До открытия БД в этой области
нет смысла выполнять программу по шагам. Если логика программы
такова, что в этой области открывается одна из нескольких БД,
мы должны или сделать несколько точек останова - на командах USE,
или применить для останова выражение  DBF(2)=="". Оно имеет значение
.T., пока область "B" не будет задействована. Как только
значением станет "F", произойдет останов. Начинаем детальный
просмотр обработки записей.
    Пример 22.2. Возникло подозрение, что неправильно переключаются
рабочие области, и надо проверить все случаи. Записываем с этой
целью точку прерываний  Select(). Функция Select() возвращает
номер активной области при установке SET COMPATIBLE OFF, действующей
по умолчанию.
    Пример 22.3. В БД Kadr правильно обрабатываются лишь записи,
предшествующие 123-й записи. Их обработку надо пропустить, а дальше
включить пошаговый режим. Записываем для этого точку прерываний
Recno() = 123. Если в программе обрабатываются и другие БД, выражение
усложняем:    Right(DBF(),8)=="KADR.DBF".AND. Recno() = 123 .
Если мы сами назначали для БД Kadr рабочую область, например 3-ю,
и только для нее, возможен вариант Recno(3) = 123. Последний вариант,
возможно, с проверкой имени БД необходим, если обрабатываются записи
открытой, но не обязательно активной БД Kadr.
    Пример 22.4. Вопреки предположениям число записей в БД Kadr
становится больше известного предела N. Ищем ошибку, используя
точку прерываний  Reccount() > N  или  Reccount(<Область>) > N.
    Здесь показаны возможности использования информации, имеющейся
в СУБД. Конечно, в большинстве случаев используются иные выражения.
    Задание 22.3. При выполнении в отладчике программы из задания 22.1
опробовать остановы, управляемые событиями.

             22.4. Работаем с диалоговыми окнами

     В случае прерывания выполнения из-за ошибки в диалоговое окно
с 3 кнопками выдается сообщение о ней, например (отсутствует БД):
                   File <Имя БД> does not exist
              <Cancel>      <Suspend>       <Ignore> .
Нажав "горячую" букву C, мы прекратим выполнение программы. Буква S
вызовет приостановку (команда Suspend). Через интерфейс и командное

                             - 6 -
окно мы можем изучить текущую ситуацию и по возможности исправить ее,
чтобы продолжить работу программы. Определенные возможности дает и
кнопка <Ignore>: после нажатия I выполнение может быть продолжено,
но база данных не открыта и операция с БД вызовет диалоговое окно,
чтобы можно было открыть некоторую БД. Итак, если мы ошиблись в
записи пути или имени, дело поправимо.
     При работе с несколькими БД полезна команда SET STATUS ON,
обеспечивающая присутствие на экране строки статуса с именем активной
БД, номером текущей записи и общим их числом. Пример:  KADR    1/205.
Более полную картину дает окно, появляющееся при выборе подпункта
Window/View, где показаны используемые области, связи БД и т.п. Вы
можете открыть нужную БД в желаемой области, закрыть другие БД.
Наконец, используя View, можно увидеть действующие системные установки:
элемент ON/OFF вызывает соответствующее окно, где для каждой
установки в скобках [ ] показано, действует ON (в скобках X) или OFF
(в скобках пробел).
     Если действует установка SET ESCAPE ON, вы можете прекращать
выполнение программы клавишей Esc, получая сообщение и 2 кнопки:
                       *** INTERRUPTED ***
                 <Cancel>               <Ignore>

    Частым является сообщение о файле, подлежащем уничтожению:
           <Имя файла> already exists, overwrite it ?
              <Yes>                         <No>
Если вы сознательно перезаписываете файл, отвечайте <Yes>.  Если
вас не беспокоит возможность ошибочного стирания файла (все файлы
учебные, небольшие) или вы уверены в себе, можете подавить такие
сообщения командой SET SAFETY OFF, а когда нужно - изменить данную
установку командой SET SAFETY ON.
    Задание 22.4. Намеренно указав в программе обработки БД
несуществующую БД, найдите и опробуйте разные способы продолжения
работы программы в отладчике.

                 22.5. Обрабатываем ошибки выполнения

     Прерывание с выдачей сообщения об ошибке (см. выше) можно
предотвратить, используя команду   ON ERROR <Команда>,
где подчиненная <Команда>, работающая только при возникновении
ошибки выполнения, как правило, является вызовом подпрограммы
обработки ошибки, разрешающей конфликтную ситуацию. Например,

                             - 7 -
попытка перехода к несуществующей записи может реализовываться
как переход к последней записи БД.
    Команда ON ERROR должна предшествовать команде, в которой
может возникать ошибка (они не обязательно в соседних строках). В
случае ошибки последняя не выполняется, происходит выполнение
подчиненной <Команды>, после чего управление передается на команду,
идущую за ошибочной. Говорят, что ON ERROR перехватывает прерывание
вызванное ошибкой.
    Пример 22.5. В программе должна использоваться БД Sessia
("Сессия"). В межсессионный период эта БД не существует, но для
проведения работ по модернизации программы предусматривается
использование БД Qwazy - макета БД "Сессия":
    ON ERROR  USE Qwazy
    USE Sessia         && Если нет БД Sessia, ошибка не выдается,
    <Работа с БД>      && а работа идет с БД Qwazy (см. выше)
Это просто иллюстрация. Конечно, сделать можно по-иному.
    Действие команды ON ERROR распространяется на группу следующих
ниже команд вплоть до команды ON ERROR без аргумента, обозначающей
отмену действия, или до конца программы.
    Подпрограмма обработки ошибки может быть выполнена универсально
с учетом типа ошибки и контекста: из какого блока и даже из какой
строки блока произошел вызов. Эта информация предъявляется функциями
Error(), Program() и Lineno() соответственно, которые и используются
как фактические параметры в обращении к подпрограмме обработки
ошибок. Бывают случаи, когда возврат из подпрограммы должен
происходить на команду, вызвавшую ошибку, а не на следующую, как
обычно. С этой целью подпрограмму заканчивают специальным оператором
RETRY (см. пример 22.6).
    Пример 22.6. Обрабатывается ошибка открытия БД (в 2 местах).
  ON ERROR DO Executor WITH LineNo(),Program()
  ACCEPT "ВВЕДИТЕ ИМЯ МАТЕРИНСКОЙ БД: " TO Imya
  USE (Imya)
  ACCEPT "ВВЕДИТЕ ИМЯ ДОЧЕРНЕЙ БД: " TO Imya
  USE (Imya) IN B
  ON ERROR
  LIST                                    //Имитация обработки БД
PROCEDURE Executor
PARAM Lin, Prog
? Lin
? Iif(Lin = 5,"Как не стыдно ошибаться еще и здесь!","")

                             - 8 -
?"БУДЬТЕ ВНИМАТЕЛЬНЫ! ПРОВЕРЬТЕ ИМЯ БД! МОЖЕТ БЫТЬ, НУЖЕН ПУТЬ?"
ACCEPT "ВВЕДИТЕ ИМЯ "+ Iif(Lin=3,"МАТЕРИНСКОЙ","ДОЧЕРНЕЙ")+" БД: " TO Imya
RETRY
    Возможно, найдутся программисты, учитывающие в подпрограмме
обработки ошибок и "предисторию" команды с ошибкой, а именно,
какая цепь вызовов блоков предшествовала ошибке. Возможность этого
обеспечивает функция Program с аргументом - номером блока в цепи.
    Пример 22.7. Пример не связан с обработкой ошибок.
* Это главный блок - "дедушка"; его именем является имя файла
DO Otec
  PROCEDURE Otec   && Блок второго "поколения"- блок-"отец"
  DO Sinok
PROCEDURE Sinok    && Блок третьего "поколения"- блок-"сын"
?'Мой "дед" '+Program(1),'вызвал папу',Program(2)
?'Мой "папа" '+Program(2),'вызвал меня - старшего сына'
?'А это я',Program(3),'разговариваю с Вами в',Str(LineNo(1),2),'строке'
?'Ее абсолютный номер -',Str(LineNo(),2)
    Аргумент функции LineNo() имеет другой смысл: если он имеется
(обычно - 1), номер строки будет относительным - в пределах тела
блока. Если аргумента нет, возвращаемый номер строки будет "сквозным"
- отсчитывается от начала файла.





