 

                          ГЛАВА 16.
              РАБОТАЕМ С БАЗАМИ ДАННЫХ В FOXPRO

     Продолжая обсуждение тем, рассматривавшихся в гл. 2,3, данная
глава показывает одну из сильных сторон FOXPRO: высокую эффективность
применения индексов, фильтров и имеющихся в командах фильтрующих
условий. Благодаря этому FOXPRO имеет высокие скоростные
характеристики. Вы увидите также, насколько удобна работа со
связанными БД и MEMO-полями в FOXPRO.

              16.1. Используем несколько рабочих областей

     Указанные в п. 3.1 справочные функции DBF(), Reccount(), RecSize(),
Recno(), Fcount(), Header(), Deleted(), Found(), а также функции EOF(),
BOF(), Field(), Filter(), Lupdate(), Order(), Seek() могут иметь аргумент
<Обл> - обозначение области, в которой открыта БД, в виде <ВырC>
(не забывайте кавычки!) или <ВырN>. Команды перемещения по БД, например
SKIP, команда SET ORDER TO и команда USE могут иметь атрибут IN<Обл>
(кавычки не нужны). Открываемая такой командой USE база не становится
активной, если уже есть активная БД. Эти функции и команды позволяют
строить программу, работающую сразу с несколькими БД, без частых
переключений областей.
     Интересна новая функция SEEK (<Аргумент поиска>, <Обл>),
которая используется в тех же условиях, что и команда SEEK, и возвращает
.T., если поиск по заданному аргументу в заданной области успешен,
иначе - .F.. Иначе говоря, она работает "по совместительству" как Found().
     Пример 16.1. Имеются БД одинаковой или близкой структуры, 
предположим, с записями - описаниями личностей: БД  DB1 и DB2. Составим
программу, которая для заданной в DB1 личности ищет в DB2 подходящую
личность. Это может быть поиск преступника в картотеке, донора по
группе крови, родственника по делу о наследстве и т.п. Ниже показан
упрощенный учебный вариант. Улучшение программы будет рассмотрено в
п. 17.3.
 USE DB1
 USE DB2 IN 2                && Активной осталась DB1 (см. выше) !
 INDEX ON Famil TO IndFam    && По полю "Фамилия" индексируется DB1
 ACCEPT "Введите инд.выражение для DB2 " TO S
 ACCEPT "Введите имя инд.файла для DB2 " TO Ind
 SELECT 2                      && Вынужденное переключение областей
 INDEX ON &S TO &Ind              && Индексируется DB2 для создания
 SELECT 1                         && условий быстрого поиска в DB2
 ACCEPT "Введите фамилию " TO Fam        && Указание личности в DB1
 IF Iif(Seek(Fam), Seek(&S,2), .F.)
? Recno(2), DB2.Famil  && Контрольный вывод номера и поля найденной записи
 ELSE
? "Отсутствует исходная (Seek(Fam) = .F.) или нет подходящей записи"
 ENDIF
     Функция Seek(&S,2), работая с DB2 (аргумент "2" указывает рабочую
область), использует в аргументе поиска значения полей текущей записи
из BD1. По тем же полям проиндексирована DB2. Если выражений, по которым
может производиться поиск, немного (столько же возможных индексов),
индексы могут быть созданы заранее и открыты вместе с DB2. В этом случае
могли быть использованы функция Order(2) для отображения имени ведущего
индекса и Key(<Ном>,2) для отображения его ключа, чтобы пользователь
назначал необходимый индекс не "вслепую".
     Связи баз данных. В п. 2.6 рассмотрено установление связей БД.
Рассмотрим примеры связи "одна-с-одной" (1:1) для уяснения деталей
этого процесса. Напомним, что в выражении связи используются функции и
поля материнской БД, хотя обеспечиваемый им поиск (или доступ к записи)
происходит в дочерней БД.
     Пример 16.2. База Dipl содержит данные о дипломниках, в том
числе фамилию с инициалами (поле Famil), номер кафедры (NKaf), 
размер стипендии (Stipa) и признак (Pr) зачета по преддипломной 
практике (Pr равен .T., если зачет есть). В базе Kafedr номеру каждой
кафедры Nkaf сопоставлено ее название (KNaz) и номер факультета (NFak),
которому принадлежит эта кафедра. В базе Faki каждому номеру Nfak
сопоставлено название факультета (FNaz). Индексы двух последних БД уже
созданы (по ключам - номерам NKaf и NFak соответственно).
     Нужно напечатать список дипломников, не имеющих зачета, с
указанием названия кафедры и факультета. Команда LIST с атрибутом
TO PRINT выводит список одновременно на дисплей и принтер.
 USE Kafedr INDEX Kafedr     && В области 1 открываем базу-"маму"
 USE Faki INDEX Faki IN 2    && В области 2 открываем базу-"дочку"
 SET RELATION TO Nfak INTO Faki && Устанавливаем связь "мама-дочка"
 SELECT 0  && Переходим в свободную область с наименьшим номером(3)
 USE Dipl                  && В области 3 открываем базу-"бабушку"
 SET RELATION TO Nkaf INTO Kafedr          && Связь "бабушка-мама"
 ? "СТУДЕНТЫ, ПРЕДСТАВЛЕННЫЕ К ОТЧИСЛЕНИЮ"
 SET FILTER TO .NOT.Pr
 LIST OFF Famil, A.KNaz, B.FNaz TO PRINT
     Обратите внимание на то, что связь "мама-дочка" установлена
при активной базе-"маме", а связь "бабушка-мама" - при активной
"бабушке". Рассмотрим, что может случиться, если в записях БД
Dipl имеются несуществующие номера Nkaf. Если такова текущая
запись, то при поиске в БД Kafedr, а затем - и в БД Faki происходит
выход из БД на фиктивную (пустую) запись. Будет отпечатана лишь
фамилия студента, приписанного к "непонятной" кафедре. Упрощая 
пример, мы выводили неупорядоченный список; использовались лишь 
обязательные для дочерних областей индексы.
     Уничтожение связей БД. Если все связи БД не нужны одновременно,
не назначайте их одной командой, а добавляйте по мере надобности,
указывая в конце команды слово ADDITIVE. Без его указания существующие 
связи уничтожатся. Ставшую ненужной связь следует немедленно
уничтожать командой SET RELATION OFF INTO<Область> (при надобности
ее можно будет возобновить). Дело в том, что каждая связь вызывает
поиск в дочерних БД, и чем больше связей, тем медленнее обрабатываются
записи материнской БД. Команда SET RELATION TO уничтожает все связи.
Ее можно использовать и при отмене большинства связей, восстанавливая
затем необходимые. Две данные команды используются при активной
материнской БД.
     Связь по числовому выражению. Числовое выражение дает номер
"дочерней" записи. Итак, поиска нет, индексировать дочернюю БД не
нужно.
     Пример 16.3. В некоторой "глобальной" системе описания персон
есть и медицинские сведения о них, используемые в исключительных
случаях. Эти сведения (группа крови Grk, данные .T./.F. о перенесенных
болезнях, травмах, о генетической предрасположенности и т.п.),
занимая в БД большой объем, замедляли бы этим процесс решения
большинства задач, поэтому вынесены в отдельную БД так, что одинаковые
по номеру записи из нее и основной БД Glav относятся к одной персоне.
     В задаче, требующей медицинских данных (БД Medic), связь БД
устанавливается с помощью числового выражения Recno():
  USE Glav
  USE Medic IN 2
  SET RELATION TO Recno() INTO Medic           && Активна БД Glav !
  LIST Famil, Addr, B.Grk && Команда LIST "моделирует" обработку данных
Сложные числовые выражения редко применяют для связи БД. 
     Связь "одна-со-многими"(1:N). После установления связи "одна-с-одной"
выполняют команду SET SKIP TO <Список дочерних областей>, например
SET SKIP TO A,B.  При выводе данных такая связь поддерживается командами
LIST и BROWSE. Обратимся к примеру 2.6 вновь,
используя взамен LIST команду BROWSE, рассматриваемую подробно в
п. 18.1. Воспользуемся ключами  :H=<ВырC> (ключ записывается правее
обозначения выводимого поля), где <ВырC> - заголовок над колонкой
поля в таблице.
  USE Deti
  INDEX ON TabNum TO Tb
  SELECT 0
  USE Kadr
  SET RELATION TO Tabnum INTO Deti       && Установление связи "1:1"
  SET SKIP TO Deti                       && Установление связи "1:N"
  BROWSE FIELDS Famil :H="Фамилия,и.,о.", A.Imya :H="Имя ребенка"
     При выводе данных о детях сотрудника его фамилия выдается один
раз независимо от числа детей. Если дети отсутствуют, в соответствующей
колонке выводится поле пробелов. Имейте в виду, что вывод происходит
лишь на дисплей, тогда как команда LIST может выводить и на принтер.
     В главе 17 вы ознакомитесь с другими возможностями одновременного
использования нескольких БД.
     Задание 16.1. Одно из неудобств программы примера 16.1 состоит
в том, что при повторном применении выражения поиска (ключа индекса)
выдается вопрос, нужно ли индексировать БД, ибо индекс существует.
Он существует, но не был открыт нами, и мы вынуждены ответить "Да".
Измените программу, чтобы избавить пользователя от ненужных
вопросов и не повторять создание индекса.

              16.2. Работаем с Memo-полями в FOXPRO

     Для работы с Memo-полями в FOXPRO предусмотрены специальные
функции и команды. Кроме того, используются строковые функции (п. 1.4).
В команде REPLACE предусмотрен атрибут ADDITIVE, наличие которого
вызывает добавление в конец Memo-поля нового текста, а не замещение
им прежнего. Как и в CLIPPER, для удобства наблюдения Memo-поле
форматируется, разбивается на части-строки (не путать с символьными
строками!). Ширину строки <ВырN> в диапазоне от 8 до 256 устанавливает
команда SET MEMOWIDTH TO <ВырN>. По умолчанию ширина строки равна 50.
     Функция ATLINE (ATCLINE) возвращает номер строки Memo-поля, в
которой найдено первое вхождение <ВырC>: ATLINE (<ВырС>,<Memo-поле>).
Ее "дубль" ATCLINE игнорирует различие строчных и прописных букв.
RATLINE ("дубль" - RATCLINE) возвращает номер строки, где имеется
последнее вхождение <ВырC>. Все эти функции возвращают 0, если
вхождения <ВырC> не обнаружено. Данные функции применимы и к обычной
символьной строке (вторым аргументом будет ее имя), если выполнена
команда SET MEMOWIDTH TO <ВырN>.
     Функция MLINE (<Memo-поле>,<Ном>) выделяет из Memo-поля и
возвращает строку с номером <Ном> (пустую строку, если <Ном> больше
числа строк), а MEMLINES (<Memo-поле>) возвращает число строк в
Memo-поле. Результаты этих функций зависят от ширины строки и возможно
имеющихся в Memo-поле жестких возвратов каретки (п. 8.1).
     Команды для Memo-полей. Специальная команда обновления Memo-поля
      APPEND MEMO <Memo-поле> FROM <Имя файла> OVERWRITE
либо заново записывает Memo-поле (это делается при наличии OVERWRITE
в команде), перенося в него текст из файла, указанного с расширением
имени, либо добавляет этот текст в конец Memo-поля (в отсутствие
OVERWRITE). Напротив, команда  COPY MEMO <Memo-поле> TO <Имя файла>
ADDITIVE добавляет текст Memo-поля к существующему файлу; при
отсутствии ADDITIVE создает файл с указанным именем (расширение по
умолчанию TXT) и копирует в него этот текст. Если файл с таким именем
существовал, его содержание аннулируется.
     Команда      MODIFY MEMO <Список Memo-полей>
    NOEDIT  NOWAIT  RANGE<ВырN1>,<ВырN2>  SAVE  WINDOW<Окно>
открывает окна редактирования Memo-полей. В списке могут быть
Memo-поля нескольких (открытых) БД. При нажатии Ctrl+W изменения
текста переносятся в Memo-поле и окно закрывается, а при выходе из
окна по Esc сохраняется прежний (неизмененный) текст Memo-поля. В
отсутствие атрибута WINDOW каждое Memo-поле открывается в отдельном
системном окне, иначе для всех используется указанное в команде окно
(по очереди).
    Рассмотрим опции команды:
NOEDIT - допускает только просмотр Memo-поля (нет редактирования);
NOWAIT - совмещает открытие окна с продолжением выполнения команд,
например, до ближайшей команды READ;
RANGE - открывает окно с блоком текста от позиции <ВырN1> до
позиции <ВырN2>. Если эти позиции совпадают, выделение текста не
происходит, а курсор устанавливается в данную позицию. В любом случае
обеспечивается исходное продвижение текста в окне, когда оно необходимо;
SAVE - сохраняет окно на экране по завершении редактирования.
     Команда CLOSE MEMO <Список Memo-полей> закрывает окна,
открытые командами MODIFY MEMO и BROWSE для указанных в списке Memo-полей,
перенося в эти Memo-поля сделанные в окнах изменения текста. Команда
CLOSE MEMO ALL закрывает все окна редактирования Memo-полей.
     Если в различных командах редактирования будет использовано
общее для многих Memo-полей окно, его можно заранее описать (см. гл.18)
и назначить командой
SET WINDOW OF MEMO TO <Окно>. Та же команда без параметра отменяет
сделанное назначение.
     Пример 16.4. На должность повара в стройотряде необходимо
выбрать студентку, имеющую наибольший опыт. "Послужной список"
студентов отражен в Memo-поле History записей БД Boyci.  При
последовательном просмотре Memo-полей пользователь с помощью приводимой
ниже программы отбирает и копирует в файлы подходящие "послужные списки".
Распечатки этих файлов предъявляются на окончательное рассмотрение.

* Для копирования в файл нажимают Ctrl+W, для пропуска - Esc.
USE Boyci                && Открываем БД - список бойцов отряда
SET SAFETY OFF
 SCAN FOR Pol="Ж"   && Цикл перебора "женских" записей БД Boyci
  @ 24,4 SAY "Студентка " + Fam
  N = At(" повар",History)
  N = Iif(N = 0, At("Повар",History), N)
  MODIFY MEMO History NOEDIT RANGE N,N
  IF Lastkey() = 23              && 23 - это Inkey-код  Ctrl+W
   Fail = Str(Recno(),2)   && По номеру записи создается имя файла
   COPY MEMO History TO &Fail                && Копирование в файл
  ENDIF
  CLOSE MEMO History
 ENDSCAN
     Если в тексте найдено слово "повар", курсор устанавливается на
его начало. При его поиске мы не воспользовались функцией Atc, а
дважды применили At, поскольку Atc непригодна в случае кириллицы.
     Как указывалось в п. 3.7, дисковое пространство для Memo-поля
выделяется блоками. В FOXPRO можно назначать размер блока Rb (по
умолчанию 64 байта) командой SET BLOCKSIZE TO <ВырN>, причем, если
<ВырN> < 33, Rb равен <ВырN>*512, иначе Rb = <ВырN>. Рассмотрим
еще один пример целесообразного применения Memo-полей.
     Пример 16.5. Строится система автоматической выдачи стандартных
документов. Каждый из них, имея шаблонную форму, требует внесения в
нее фамилий, дат или названий материалов и т.п. (см. пример 15.11). 
Поэтому для выдачи документов надо открыть БД, содержащую фамилии (и 
другие данные) личностей или названия материалов и пр., и запустить
соответствующую программу, использующую некоторый текстовый шаблон.
Создадим БД Docum с полями Nazv (название документа), ImyaBD (имя
базы), Progr (имя программы), Shab (шаблон). Все поля символьные,
причем последнее может быть только Memo-полем ввиду произвольной
длины форм документов.
     Программа получается довольно-таки элементарной:
 USE Docum
 BROWSE FIELD Nazv    && Наводим маркер на соответствующее название
 Imya = ImyaBD                                    && и нажимаем Esc
 Pro = Progr
 SELECT 0       && Назначается свободная рабочая область (область B)
 USE (Imya)     && В ней открывается соответствующая документу база
 DO &Pro                   && Запускается соответствующая программа
     Рассмотрим содержание одной записи БД Docum, обратившись к
примеру 15.11. Названием документа (поле Nazv) будет "Суровое
напоминание", шаблон (Shab) будет таким, какой показан между командами
SCAN и ENDSCAN, имя используемой БД (поле ImyaBD) - Conduit. Имя
программы (поле Progr) пусть также будет Conduit и она будет размещена
в файле Conduit.prg.
Тиражируя напоминания c предъявлением их текста на экран, она будет
помещать эти тексты в файл Napom.txt для последующей распечатки:
 SET TEXTMERGE ON TO Napom        && Указан файл-накопитель Napom
 SCAN FOR Datisp < Date()     && Записано условие выбора поручений
 \
 \ <<A.Shab>>  && Вставка текста Memo-поля, в котором свои вставки
 \
 WAIT"" && Пауза для просмотра текста,прерываемая нажатием клавиши
 ENDSCAN
 SET TEXTMERGE TO                          && Закрытие файла Napom
     Задание 16.2. Создайте БД Docum и заполните хотя бы одну запись
с рассмотренным выше содержанием, удостоверьтесь в работоспособности
программы примера 16.5.

                 16.3. Узнаем новое об индексировании

     В FOXPRO внедрены новшества, сокращающие затраты дисковой памяти
для индексов и ускоряющие доступ к записям по индексу. Используются
"обычные" индексные файлы с расширением имени .IDX и мультииндексные
- с расширением .CDX .
     Компактные индексы. Начиная с версии 2.0 в FOXPRO используются
компактные индексы, в которых общие для ключей разных записей старшие
части даны в одном экземпляре, а для хранения ключей используются
строки не фиксированной, а фактической длины. Например, если БД
Student проиндексирована по ключу Fak+Kurs ("факультет + курс"), то
для всех записей студентов факультета ЭТ будет общей часть ключа "ЭТ".
Часть "Э" будет общей для записей всех факультетов с названиями,
начинающимися с буквы "Э". Итак, структура множества ключей -
древовидная. Индексы в .CDX-файлах компактные, а чтобы .IDX-индекс
тоже был компактным, в команде INDEX ON указывают атрибут COMPACT.
     Неполные индексы (индексы-фильтры). В команде INDEX ON можно 
записать FOR-условие для отбора в индекс записей, удовлетворяющих 
лишь этому условию. Доступ к записям ускоряется.
     Мультииндексный файл (.CDX-файл) хранит несколько индексных
выражений и является "складом" индексов - тегов. Поэтому увеличение
числа индексов не грозит превышением предела числа открытых файлов,
устанавливаемого в DOS. Каждый тег имеет имя, указываемое при создании
или открытии индекса. Для удобства пользования один .CDX-файл,
называемый структурным, сделан одноименным с БД. Он открывается
автоматически вместе с БД и закрыть отдельно от нее его нельзя. При
использовании его тегов можно не указывать имя .CDX-файла.
     Создание индексов. В связи с нововведениями команда INDEX ON
расширена: INDEX ON <Выр> <Индекс> FOR<Условие> COMPACT UNIQUE
                      DESCENDING  ADDITIVE .
<Индекс> может быть в 3 вариантах:
  а) TO <Имя .IDX-файла> ;
  б) TAG <Имя тега структурного .CDX-файла> ;
  в) TAG <Имя тега> OF <Имя .CDX-файла>.
     Пример: INDEX ON  Fak+Kurs  TAG Fakrs OF Sklad  FOR Pol = "Ж".
В созданном теге (индексе) Fakrs .CDX-файла Sklad будут учтены
только женщины. Если тег является первым (.CDX-файла прежде не было),
.CDX-файл создается. Атрибут COMPACT рассмотрен выше, UNIQUE - в
п. 2.5. Созданный индекс автоматически открывается; ADDITIVE
предотвращает автоматическое закрытие ранее открытых индексов.
DESCENDING применим лишь к тегам и задает упорядоченность по убыванию
значений ключа. Последовательность тегов файла определяется
порядком создания.
     Открытие индексов. Ранее созданные индексы открывают или вместе
с БД, или командой SET INDEX TO. Ее содержание полностью соответствует
части команды USE, следующей за словом INDEX. Рассмотрим элементы.
  <Список индексных файлов> показывает очередность открытия файлов.
С ней связана "сквозная" нумерация индексов. Независимо от того, 
какими командами открыты индексы, начальные номера имеют .IDX-индексы 
в порядке их открытия, затем - теги структурного файла, за ними - прочие 
теги в порядке их открытия. Нумерация - с 1. Допустим, индексы открыты 
только командой USE, .IDX-файл один и замыкает список индексов. Он все 
равно получает номер 1. Если .IDX-файлы не открыты, номер 1 получает 
тег структурного файла, в его отсутствие - тег первого в списке 
.CDX-файла. Если, например, в списке .CDX-файл, в котором 3
тега, и два .IDX-файла, а в структурном .CDX-файле (в списке не указан)
2 тега, последний тег .CDX-файла будет под номером 7. Допустим, еще
один .IDX-файл открывает команда SET INDEX TO с атрибутом ADDITIVE.
"Сквозные" номера тегов увеличатся на 1, ибо номер 3 приписан вновь
открытому файлу.
  .IDX-файл, начинающий список, задает ведущий .IDX-индекс, если
атрибут ORDER не определяет иное. Если список начинается с .CDX-файла
и нет атрибута ORDER, нет и ведущего индекса. Тогда используется
физический порядок расположения записей. Тот же эффект вызывает
атрибут ORDER 0.
  С помощью атрибута ORDER ведущий индекс назначают одним из 3 способов:
а) ORDER<Номер> (нумерация индексов рассмотрена выше);
б) ORDER<Имя .IDX-файла>;   в) ORDER<Имя тега> OF <Имя .CDX-файла>.
Для структурного файла можно писать ORDER<Имя тега>.
  Атрибут ADDITIVE предотвращает автоматическое закрытие ранее
открытых (в USE, в INDEX ON, в SET INDEX TO) индексов. Открыть
(закрыть) отдельный тег нельзя: это действия с файлами.
  Атрибут ASCENDING (DESCENDING) задает порядок прохождения индекса,
например, при выводе командой LIST. По умолчанию используется
порядок, предусмотренный при создании индекса.
     Изменение ведущего индекса. Команда SET ORDER TO имеет
параметры, указанные выше, начиная с атрибута ORDER, т.е. она
выполняет часть работы команды SET INDEX TO. Команда без параметров
вообще отменяет ведущий индекс, то же делает  SET ORDER TO 0.
Команда допускает указание рабочей области: IN<Обл> (см. п. 16.1).
     Закрытие индексов, кроме структурного .CDX-файла, осуществляют
команды INDEX ON, SET INDEX TO без атрибута ADDITIVE. При этом команда
SET INDEX TO, лишенная параметров, только лишь закрывает индексы
(ее эквивалент - команда CLOSE INDEX).
     Действия над индексными файлами. Для их выполнения БД должна
быть открыта с соответствующими индексными файлами. Команды
      COPY INDEXES ALL  TO <Имя .CDX-файла>
      COPY INDEXES <Список .IDX-файлов>  TO <Имя .CDX-файла>
копируют соответственно все открытые или указанные в ее списке
(открытые) .IDX-файлы в .CDX-файл, где они становятся тегами. Если
параметр TO <Имя .CDX-файла> отсутствует, копирование идет в
структурный .CDX-файл. Напротив, команда
   COPY TAG <Имя тега>  OF<Имя .CDX-файла>  TO<Имя .IDX-файла>
снимает копию тега в виде .IDX-файла. Если имя тега уникально или
он из структурного файла, параметр OF<Имя .CDX-файла> не нужен.
     Команда DELETE TAG ALL OF<Имя .CDX-файла> удаляет все теги
из .CDX-файла (по умолчанию - из структурного), а команда
DELETE TAG <Список тегов> - все указанные в списке теги; элемент
списка тегов имеет вид     <Имя тега> OF <Имя .CDX-файла>   либо
<Имя тега> - если имя тега уникально или он из структурного файла.
     Справочные функции. Функция NDX(<Ном>) (или  CDX(<Ном>) )
возвращает имя .IDX-файла (.CDX-файла) из числа открытых, заданного
номером <Ном>, где <Ном> указывает очередность открытия. Нумерация
отдельна для .IDX- и .CDX-файлов. При этом структурный .CDX-файл,
если он есть, имеет номер 1. В его отсутствие номер 1 имеет другой
открытый .CDX-файл. Функция TAG(<Ном>) возвращает имя тега или
.IDX-файла, где <Ном> - номер "сквозной" нумерации индексов (см.
команду SET INDEX TO). В варианте TAG("<Имя .CDX-файла>", <Ном>)
<Ном> означает порядковый номер тега в указанном .CDX-файле.
Все указанные функции могут иметь 2-й аргумент - <Обл> (см. п. 16.1).
     Обновление индексов командой REINDEX. Если при изменении полей,
участвующих в ключах индексов, индексы не были открыты, такие индексы
можно обновить позднее: нужно открыть БД и эти индексы и выполнить
команду REINDEX. Такое обновление индексов большой БД занимает много
времени и прибегать к нему надо лишь при необходимости.
    В заключение рассмотрим полное определение команды USE:
  USE <Имя БД> IN<Обл> ALIAS<Алиас> INDEX<Список индексных файлов>
  ORDER<Обозначение индекса>  ASCENDING | DESCENDING  AGAIN
  NOUPDATE  EXCLUSIVE | SHARED .
    Опции команды рассмотрены в пп. 2.4, 16.1 (опция IN), 16.3
(опции INDEX, ORDER, ASCENDING | DESCENDING). Опция EXCLUSIVE | SHARED
рассматривается в п. 23.2. Опцию AGAIN указывают, если БД открывают
повторно - в новой рабочей области. При этом доступ к БД в области,
где она была открыта ранее, ограничивается чтением, а каждый индекс БД
может быть открыт лишь в одной из областей (в другой можно открыть его
копию).
   Опция NOUPDATE означает, что БД открывают в режиме "только чтение".

     Задание 16.3. Для имеющейся БД, например, БД Dipl, создайте
индексы-теги и .IDX-индексы. Изменяя в программе (или в командном
окне) порядок открытия индексов и используя несколько команд, 
открывающих индексы, изучите их нумерацию (используйте функцию TAG).
Опробуйте команды SET ORDER TO, COPY INDEXES, DELETE TAG.

            16.4. Новое в поиске данных. Технология Rushmore

     Кроме функции SEEK, упомянутой в п. 16.1, в FOXPRO имеется еще
одна полезная функция поиска  LOOKUP(<Поле1>, <Выр>, <Поле2>),
которая ищет первую запись с выполненным требованием <Поле2>=<Выр>
и если ее находит, возвращает строку - значение символьного поля
<Поле1> найденной записи. В противном случае возвращается пустая
строка. Если открыт индекс, ключ которого - <Поле2>, поиск
ускоренный, иначе - последовательный.
     Начиная с версии 2.0, в FOXPRO используется технология Rushmore
, позволяющая производить доступ к подмножеству записей индексированной
БД за время, сравнимое с временем доступа к одной записи. Выигрыш тем
ощутимее, чем больше записей в выделяемом подмножестве. Введение
компактных индексов рассматривается как усовершенствование показателей
СУБД, тогда как технология Rushmore качественно улучшает возможности
ПЭВМ при обработке "гигантских" БД, как бы приближает ПЭВМ к классу
средних и больших ПЭВМ. Данный способ оптимизации доступа используется
в командах AVERAGE, BROWSE, CALCULATE, CHANGE, COPY TO, COPY TO ARRAY,
COUNT, DELETE, DISPLAY, EDIT, EXPORT, LABEL, LIST, LOCATE, RECALL,
REPLACE, REPORT, SCAN, SORT, SUM, TOTAL, если
 - в команде имеется FOR-условие, а в нем как операнды (операнд)
равенств или неравенств записаны индексные выражения (индексное
выражение); данные равенства или неравенства назовем оптимизирующими;
 - соответствующие индексы (один индекс) открыты;
 - в команде нет атрибутов WHILE, NOOPTIMIZE и действует статус 
SET OPTIMIZE ON (статус, используемый по умолчанию; отменяется 
- SET OPTIMIZE OFF).
    Взамен FOR-условия может быть задан фильтр (SET FILTER) с 
аналогичным равенством (неравенством) и тогда оптимизируется работа
тех вышеуказанных команд, которые оказались в зоне действия фильтра.
     Если в логически сложном FOR-условии или фильтре не все 
составляющие являются оптимизирующими, доступ оптимизируется частично
или не оптимизируется, иначе оптимизация доступа полная.
     Пример 16.6. БД проиндексирована по ключам Fak (факультет),
Pol (пол). Подсчитывается число n студенток, число m студентов-
мужчин старше 20 лет и обрабатывается подмножество "студенты-мужчины 
факультета АВТ".
 USE student INDEX IndFak, IndPol ORDER 0
 COUNT TO n FOR Pol = "Ж"       && Полностью оптимизируемая команда
 SET FILTER TO Fak ="АВТ".AND. Pol ="М"       && Имеет место полная
 LIST Famil, Kurs OFF            && оптимизация команд LIST,AVERAGE 
 AVERAGE SrBall TO Sb    && Находится средний балл для подмножества
 SET FILTER TO 
 COUNT TO m FOR Pol ="М".AND. Vozr > 20    && Частичная оптимизация
     Неравенство Vozr > 20 (возраст больше 20) - неоптимизирующее,
поэтому оптимизация частична (см. ниже зависимость от логических 
операций). Заметим, что все открытые индексы отключены от управления 
(ORDER 0). Система оптимизации сама "распоряжается" открытыми индексами.
     Оптимизация при сложных логических выражениях. Операция .NOT.
не учитывается при выяснении уровня оптимизации, тогда как операции
.AND.,.OR. этот уровень определяют:
---------Подвыражение 1 ------------ Подвыражение 2 -----Результат------
Полностью (частично) оптимизир.│ AND│ Неоптимизир.│Частичная оптимизация
Полностью (частично) оптимизир.│ OR │ Неоптимизир.│   Оптимизации нет
     Пример 16.7. Устанавливается фильтр для выделения подмножества
студентов, которым меньше 18 лет или которые прошли воинскую службу
(признак VS равен "ДМБ"). Мы намеренно избегаем дизъюнкции (.OR.).
  USE Student INDEX IndVozr, IndPol ORDER 0 
  SET FILTER TO Pol ="М".AND..NOT.(Vozr >= 18 .AND. VS # "ДМБ")
     LOCATE и Rushmore. Ранее полагалось, что команда LOCATE выполняет 
поиск медленно, последовательным перебором записей. Оптимизация доступа 
к ним, особенно если она полная, приводит к тому, что LOCATE работает
столь же быстро, как SEEK. Заметим, что в LOCATE мы не ограничены в
выборе условия поиска и можем произвольно его усложнять.
     Требования к памяти. Оптимизация доступа увеличивает используемую
область памяти. Предполагается, что для работы с большими БД (больше
500000 записей) применяется расширенная версия FOXPRO при 
соответствующем оборудовании. В противном случае возможны сообщения
о нехватке памяти "Not enough memory for optimization". Ничего
"фатального" при этом не происходит, обработка ведется, но медленнее.
     Rushmore в SQL. Команда SELECT языка SQL (см. гл. 18),
выполняя сложную обработку данных, возможно, нескольких БД,
сама открывает БД и обеспечивает индексами, оптимизируя доступ.
     Полнота оптимизации доступа. Есть факторы, не указанные выше:
желателен статус SET DELETED OFF, отсутствие ведущего индекса (см.
в примерах 16.6, 16.7 атрибут ORDER 0). Учтите, что индексы-фильтры 
и индексы, созданные с атрибутом UNIQUE, в оптимизации не участвуют.
Все прочие разновидности индексов "работают".
     Примечание. Запись индексного выражения в FOR-условии (в фильтре)
должна быть идентична использованной при создании индекса, не должна
содержать алиасов.
     Отключение оптимизации доступа. Rushmore фиксирует подмножество
обрабатываемых записей в начале выполнения команды. В тех редких
случаях, когда команда изменяет в записях ключ индекса, участвующего 
в оптимизации доступа, она "рубит сук, на котором сидит". Возможна
неполная (а отсюда - и неправильная) обработка подмножества. Особенно
важно отслеживать такие случаи при установке оптимизирующих фильтров.
Если логика обработки столь "вычурна", отключайте оптимизацию в 
команде атрибутом NOOPTIMIZE или - для группы команд - установкой
статуса SET OPTIMIZE OFF (потом восстановите исходный статус).
     Задание 16.4. Используя команду LOCATE с оптимизацией доступа
и без него, убедитесь в эффективности оптимизации. Небольшие размеры
вашей БД "скомпенсируйте" применением цикла с большим числом 
выполнений LOCATE, чтобы разница времени обработки стала ощутимой.

       16.5. Выполняем сортировку и математическую обработку

     Сортировка (физическое упорядочение записей БД) рассмотрена в
п. 3.9. Укажем лишь новый атрибут DESCENDING, внесение которого в
команду SORT изменяет последовательность записей в отсортированном
файле на прямо противоположную. Это удобно при отладке, если
пробуется (используется) и та, и другая последовательности, особенно
если сортировка ведется по нескольким полям (команда усложнена).
     Пример 16.8. Путем сортировки БД Student получим упорядоченный
по алфавиту список Sp студентов: фамилия, и.,о., пол, возраст,
расшифровка (название) специальности SpecNaz, извлекаемая из дочерней
БД  SpecBD. Связующее поле БД (номер специальности) имеет имя Spec.
  USE Student                   && В области "A" открыта БД Student
  USE SpecBD IN B INDEX SpecIn  && В области "B" открыта БД SpecBD
  SET RELATION TO Spec INTO B      && Связь с дочерней областью "B"
  SORT ON Famil TO Sp FIELDS Famil, Pol, Vozr, B.SpecNaz
     Сортировка имеет какой-то смысл, если физическая упорядоченность
используется длительное время, возможно, во многих задачах. Проблемой
является ее поддержание при добавлении новых записей. Они должны
вставляться в БД, а не просто добавляться. Место вставки обозначается
текущей записью, определение которой - дело программы, а вставку
производит команда INSERT, имеющая варианты. Команда INSERT (INSERT
BEFORE) вставляет новую запись после (до) текущей записи, обеспечивая
полноэкранный режим редактирования для ввода значений полей.
     Команда INSERT BLANK (INSERT BEFORE BLANK) вставляет пустую
запись после (до) текущей записи, не предъявляя ее на экране. Если
перейти к ней командой SKIP, значения полей можно задать с помощью
REPLACE или команд  ... GET - READ .    При вставке многих записей 
расходуется неоправданно много времени, поэтому лучше для упорядочения
БД использовать индекс: в этом случае надобность в INSERT отпадает.
     Сортировка требует дополнительной дисковой памяти, равной
удвоенному размеру исходной БД. Нужно иметь в виду и то, что в
отличие от индексирования сортировка не использует функции, выражения 
для управления упорядочением (только поля БД "в чистом виде").
     Арифметическая обработка. Особенностью FOXPRO является команда
CALCULATE с широкими возможностями (см. п. 3.6). В частности, в ней
может быть указана финансовая функция NPV - функция оценки 
целесообразности капиталовложений. Последняя существует, если 
первоначально вложенный капитал NK приносит ожидаемый процент PR
годовой прибыли (эта ее часть тратится). "Сверхприбыль" идет на
расширение капитала. Планируются и убытки в те или иные годы.
Алгебраическую сумму годовой прибыли и убытков обозначим Dohod. Так
будет называться поле БД Capit, в которой записи упорядочены по годам.
     Допустим, PR=12 %, NK = 100000000 руб, а ожидаемые доходы по
годам составляют 1500000, 10000000, 25000000, 45000000. Команда
CALCULATE NPV(0.12, Dohod, -100000000) дает отрицательный результат
-44295955.79. Данное капиталовложение не позволяет ежегодно изымать
12 % капитала. Заметим, что начальный капитал задают со знаком минус,
а вместо процента указывают сотые доли. Получение неотрицательного
результата указывало бы на целесообразность вложения.
     Команда CALCULATE имеет то преимущество, что позволяет получать 
серию результатов всего за один "прогон" файла БД.
     Задание 16.5. Сравните по времени сортировку БД и упорядочение
ее через индексирование-копирование.

                       ЗАКЛЮЧЕНИЕ К ГЛАВЕ 16         
 
    Изучив примеры и выполнив задания данной главы, вы поднялись на
более высокую ступень в овладении средствами обработки баз данных.    
Возьмите на вооружение приемы, показанные в примерах данной главы.
