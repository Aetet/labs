
           ЧАСТЬ 3. ПРОГРАММИРУЕМ НА ЯЗЫКЕ FOXPRO

                         ГЛАВА 15.
                 ПРОДОЛЖАЕМ ИЗУЧАТЬ FOXPRO

    В данной главе рассматриваются основные возможности,
предоставляемые системным интерфейсом, работа в окне команд,
использование системы помощи, возможности редактора текстов,
применение функциональных клавиш. Ввиду специфики FOXPRO особое
внимание обратите на правила построения блочных программ и
использование параметров блоков. Вы ознакомитесь с массивами FOXPRO
и узнаете новое о подстановках в тексты при выводе. Перед
изучением цветовых установок в п. 15.7 следует просмотреть п. 9.5.

            15.1. Работаем через системный интерфейс

  После загрузки FOXPRO на экране возникает строка главного меню FOXPRO
 ─────────────────────────────────────────────────────────────────
 System     File     Edit    Database    Record   Program  Window
 ─────────────────────────────────────────────────────────────────
и командное окно (окно Command внизу справа). С их помощью можно
создавать БД и файлы, выполнять разнообразные операции с ними,
изменять структуру БД, отлаживать процесс будущих программ. Для
активизации главного меню нажимают Alt или F10 - пункт System выделяется
маркером. Если выбрать мышью любой пункт меню и нажать левую кнопку мыши,
сразу активизируется меню и подменю. Перемещая маркер мышью или клавишей
управления курсором, можно выбрать другой пункт. Каждый пункт
имеет вертикальное подменю, для вызова которого нажимают Enter или
клавишу "стрелка вниз". В нем маркером выделен верхний подпункт.
     Независимо от состояния системы главного меню, нажимая Alt и
одновременно выделенную цветом ("горячую") букву наименования пункта,
мы сразу попадаем в его подменю. Для прямого вызова подпункта
активированного подменю нажимают только "горячую" букву подпункта.
Изображаемые "приглушенным" цветом подпункты недоступны. Причина:
нет объекта или условий действия, например, нет открытой БД. 
Выполнение действий подпункта отображается командой, появляющейся 
в командном окне.
     Нажатием F1 вызывается справочная информация (Help) по
выделенному маркером пункту (подпункту). Таким образом системный
интерфейс можно освоить в ходе работы с ним, поэтому ограничимся
общим обзором возможностей и примерами. Некоторым неудобством для
"русскоязычного" пользователя являются используемые в системных
окнах английские слова и фразы. Небольшая практика работы с
интерфейсом сгладит и это неудобство.
     В зависимости от сложности действий подпункта может возникать
целая последовательность вызовов окон выбора, диалоговых окон. Их
активные элементы, через которые происходит вызов действий, называют
кнопками. Переход от элемента к элементу осуществляет клавиша Tab,
нажатие клавиши Enter или Space имитирует нажатие выбранной кнопки.
Для завершения работы в окне используют кнопку <OK>, а если ее нет
- кнопку с обозначением некоторого конечного действия, например,
<Save> (сохранить).
     В подменю System реализуются общесистемные функции. Для нас
наиболее значимы подпункты Filer и Macros... . Подпункт
Filer вызывает Файлер - процессор файлов. В основном окне Файлера
дано содержание текущей директории, но работать можно и в других,
переходя в них с помощью элемента [..]. Кроме того, кнопкой Drv.
можно изменить текущий дисковод, а с помощью кнопки Dir. быстро
перейти в любую старшую директорию. Для сокращения предъявляемого
списка файлов можно задать маску (элемент File like ...).
     Получив список файлов интересующей нас директории, наводим
маркер на нужный файл и отмечаем его (треугольник слева) нажатием
Enter или Space. Теперь возможны действия с файлом. Две нижние
строки окна содержат кнопки действий.
    Подпункт Macros... позволяет закрепить за функциональными
клавишами (комбинациями клавиш) или изменить макропоследовательности:
обычно это тексты команд и их совокупностей. Рассмотрим пример
закрепления за клавишами Shift+F6 макропоследовательности
   USE BASE\STUDENT{ENTER}
   LIST{ENTER}          && {ENTER} обозначает нажатие клавиши Enter.
Выбираем подпункт Macros... и ы появившемся окне наводим маркер на
кнопку New, нажимаем Enter. Появляется окно определения макроса.
Нажимаем Shift+F6 и в нем автоматически заполняются строки
Defined Key ("определяемая клавиша") и Macro Name ("имя макроса"),
а курсор оказывается в начале поля Macro Contents, где и нужно
набрать указанную выше макропоследовательность, нажав затем кнопку
<OK>. Вместо пробела мы могли бы записать {SPACEBAR}. Теперь нажатие
клавиш Shift+F6 будет применять команду LIST к БД Student в
директории BASE.
     Подменю File в основном предназначено для работы с файлами
FOXPRO. При выборе подпункта New (создание файла)  предъявляется
список типов файлов (в скобках даны расширения имен): Database
(.DBF), Program (.PRG), Index (.NDX или .CDX), File и т.д., где лишь
File обозначает произвольный текстовый файл, а прочие - типы файлов
FOXPRO. В списке выбранный тип при нажатии Enter отмечается точкой в
скобках. Подпункт Open (открытие файла) предъявляет аналогичный список
при использовании кнопки Type. Кнопка <OK> инициирует работу с этим
типом файлов. Открывается окно со списком файлов, в котором кнопки
Drive, Directory аналогичны кнопкам  Drv., Dir.  окна Файлера.
     Подменю Database предназначено для работы с базами данных.
Подпункт Setup позволяет изменять структуру открытой БД, создавать
индексы и фильтры, назначать ведущий индекс и т.п. Подпункт
Browse вызывает команду полноэкранного редактирования записей,
при этом главное меню дополняется справа пунктом Browse. Прочие
подпункты соответствуют командам обработки БД, включая APPEND FROM,
PACK и REINDEX, командам выдачи отчетов и этикеток.
     Подменю Record реализует действия с записями (команды FOXPRO):
добавление, редактирование, переход к нужной записи, поиск, замену
значений поля, установку и снятие пометок на удаление. В командах
- действиях подменю Database и Record через диалоговые окна могут
быть заданы область действия ("границы") и условия (см. п. 3.3).
     Подменю Program управляет выполнением программ, компиляцией и
генерированием приложений, документированием программ. Редактирование
программ выполняют через подменю Edit (см. ниже).
     Подменю Edit предоставляет средства текстового редактора.
Необходимый участок текста можно выделить клавишами управления
курсором при нажатой клавише Shift. Их нажатие без клавиши Shift
снимает выделение. Комбинация Shift+Ctrl+<Стрелка вправо (влево)>
выделяет фрагмент до конца (начала) слова, Shift+End (Shift+Home) -
до конца (начала) строки, а Shift+Ctrl+End (Shift+Ctrl+Home) - до 
конца (начала) всего текста. Комбинация Ctrl+A выделяет весь текст 
в окне.
     Комбинация Ctrl+<Стрелка вправо (влево)> смещает курсор на слово
вправо (влево), комбинация Ctrl+Home (Ctrl+End) - на начало (конец)
текста,  Home (End) - на начало (конец) текущей строки. Подпункт
Goto Line используется для перехода к строке с указанным номером.
     Карманом называют буфер для хранения выделенного участка (блока)
текста. Подпункт Copy (Ctrl+C; в скобках даны клавишные эквиваленты)
копирует его в карман, а Paste (Ctrl+V) - передает из кармана в пункт
текста (в активном окне), обозначенный курсором (вставляет). Подпункт
Cut (Ctrl+X) удаляет блок текста, запоминая его в кармане, а Clear
(Del) - удаляет его без запоминания. Для быстрого выделения всего
текста окна используют подпункт Select All (Ctrl+A). Удаляемое слово,
под которым стоит курсор, выделять не нужно: нажимают Ctrl+Backspace.
Если курсор - между словами, удаляется слово слева от курсора.
     Для поиска и замены в тексте используют подпункты Find (Ctrl+F;
поиск заданного фрагмента текста), Find Again (Ctrl+G; поиск следующего
его вхождения), Replace And Find Again (Ctrl+E; последовательный поиск
вхождений с заменой заданным новым фрагментом), Replace All (замена
сразу всех вхождений). Подпункт Undo (Ctrl+U) восстанавливает вид
текста, предшествующий последнему действию в редакторе (так называемый
"откат"), а подпункт Redo (Ctrl+R) - устраняет эффект этого восстановления 
(подтверждает действие).
     Запоминание отредактированного в окне текста выполняется клавишами
Ctrl+W. Если окно обозначено как "Untitled", возникнет запрос имени
файла. Подпункт Preferences используется для настройки редактора текстов.
     Подменю Window реализует работу с окнами (см. гл.18). Упомянем
лишь подпункты Trace, Debug, открывающие окна отладчика, и View,
позволяющий открывать базы данных в нескольких рабочих областях, 
устанавливать между ними связи (см. п. 16.1), назначать системные 
установки.

     Пример 15.1. Сделаем копию Stud  БД Student без записей,
помеченных на удаление; при этом изменим в копии значения поля  Kurs
в связи с переходом студентов на следующий курс. Размер символьного
поля Kurs равен 1.
  С помощью клавиш Alt+F переходим в подменю File, нажимаем "горячую"
букву O - на экране появляется окно Open со списком файлов типа Program,
оставшимся от предыдущих шагов работы. Клавишей Tab выбираем кнопку
Type, нажимаем Enter, в появившемся списке типов наводим маркер на
пункт Database ("базы данных") и нажимаем Enter. Если БД Student - в
текущей директории, мы увидим ее имя в списке файлов, иначе придется
сменить директорию (возможно, и диск), как это было показано выше.
Наведя маркер на имя БД Student, нажимаем Enter. В командном окне
появляется команда USE Student. Для копирования БД переходим в подменю
Database, наимая Alt+D. Нажатие "горячей" буквы C открывает окно
Copy to, в котором выделена кнопка <Save as...> . Нажимая Enter,
получаем окно со списком БД, которые в принципе могут быть приемниками
копии, и строку для набора имени новой БД. Набираем "Stud", клавишей
Tab наводим маркер на <OK> и, нажимая Enter, возвращаемся в окно
Copy to. Переходим на кнопку Scope ("Область действия"), нажимаем
Enter. Появляется окно для уточнения области действия. Здесь делать
ничего не надо, ибо мы видим, что выделено необходимое значение "ALL"
(вся БД). Опять возвращаемся в окно Copy to. Переходим на кнопку <For>,
нажимаем Enter. В появившемся окне набираем условие  .NOT. Deleted()
и возвращаемся в окно Copy to. Клавишей Tab перемещаем маркер на <OK>,
нажимаем Enter. Копирование выполнено, в командном окне появляется
команда Copy to. Открываем БД Stud, как ранее открывали Student.
     Нажимая Alt+R, получаем подменю Record, "горячей" буквой p
вызываем окно Replace, в списке полей выбираем поле Kurs. Как
указано выше, уточняем область действия: должно быть "ALL".
Остается в строке ввода (внизу) записать заменяющее выражение:
Str(Val(Stud.Kurs)+1, 1).
     Задание 15.1. Для освоения системного интерфейса создайте БД
Student (см. пример 2.20) из нескольких записей и выполните пример
15.1 на ЭВМ, добавив индексирование новой БД Stud по полю Famil и
вывод (клавиша F3).

             15.2. Назначаем функциональные клавиши.
                       Система помощи (HELP)

     За клавишами F1-F10 закреплены системные функции: F1 вызывает
помощь (Help), F2 - окно View (см. выше подменю Window), F3 (F8)
выполняет команду LIST (DISPLAY), если открыта БД, F4 выводит
содержание текущей директории, F5 - структуру БД, F6 предъявляет
действующие системные установки, а F7 - значения системных переменных,
F9 выполняет команду APPEND. Если нет открытой БД, нажатие F5, F8
или F9 выводит окно Open для выбора БД, после чего выполняется
основное действие. Клавиша F10 активизирует строку главного меню.
     Отменить такое использование клавиш можно командой CLEAR MACROS.
Вряд ли вы будете это делать. Во-первых, указанные назначения весьма
"актуальны", во-вторых, для ваших собственных назначений остается
немало комбинаций клавиш. Кстати, команда отменяет и сделанные вами 
назначения.
     Кроме подпункта Macros... (см. п. 15.1), назначения могут быть
сделаны в программе или в командном окне командой
     SET FUNCTION <Номер или обозначение клавиши> TO <ВырC> .
Например, команда SET FUNCTION Shift+F8 TO "DO SimSim;" задает
запуск программы SimSim по нажатии комбинации клавиш Shift+F8. Для
отмены этого назначения нужно дать новое или выполнить команду
SET FUNCTION Shift+F8 TO. В <ВырC> точка с запятой имитирует
нажатие Enter с целью выполнения команды; можно записать
и несколько команд, заканчивая каждую знаком ";".
     Таким образом, программист может дополнить системный интерфейс
вызовом макросов, обеспечивая максимальные удобства конкретному
кругу пользователей.
     Командой SET FUNCTION клавише можно сопоставить некоторое
значение для задания его GET-переменной. Так поступают с часто
используемыми значениями, например:
     SET FUNCTION F8 TO "ПЕНСИЯ"  && Возможна ";" в конце слова
  @ 5,9 SAY "УКАЖИТЕ В ПОЛЕ Dohod ИСТОЧНИК ДОХОДА: " GET Dohod
     READ    && Нажатие F8 заносит слово "ПЕНСИЯ" в GET-поле
Цифровые строки могут использоваться для задания значений-чисел:
     SET FUNCTION Shift+N TO "54782.33"
  @ 7,9 GET M DEFAULT 0   && Переменная M определена как числовая
     READ    && Нажатие Shift+N заносит  ч и с л о  в GET-поле
     Назначая комбинации клавиш, не забывайте о том, что многие
подпункты системного меню имеют эквивалент - комбинацию клавиш.
     Прямой вызов помощи. Нажатие F1 сразу выводит в нужный раздел
справочника или в соответствующую строку его оглавления, если
а) маркер наведен на интересующий вас подпункт системного меню;
б) в тексте активного окна выделен интересующий вас фрагмент
(команда, функция, системная установка и т.д.). Если по данному
фрагменту подсказки не существует, в окно Help выдается сообщение
"No help found for <выделенный фрагмент> ".
     В иных случаях нажатие F1 вызывает оглавление справочника:
в окно Help выдается его начало. В оглавлении за общими пунктами
помощи идут пункты команд и функций языка и пр. Листая оглавление,
надо навести маркер на требуемый пункт и нажать Enter. При этом
оглавление в окне заменяется информацией соответствующего раздела
(если она не умещается в окне, для дальнейшего просмотра пролистываем
страницы), а слева появляются управляющие кнопки:

      ──────────────────────────────────────────────────────
     │     < Topics >    │                                  │
     │     <   Next >    │                                  │
     │     <Previous>    │         С п р а в о ч н а я      │
     │     < Look Up>    │                                  │
     │     ──────────    │         и н ф о р м а ц и я      │
     │    │ See Also │   │                                  │
     │     ──────────    │                                  │
      ──────────────────────────────────────────────────────

    Кнопка <Topics> возвращает в оглавление, кнопки <Next> и <Previous>
осуществляют переход к соседним по оглавлению разделам, через кнопку
<See Also>  можно перейти в разделы, связанные с данным по смыслу.
Кнопка <Look Up> становится доступной, если в справочной информации
выделен фрагмент для очередной справки. Впрочем, необходимости в
кнопке нет: вместо <Look Up> можно нажать F1 и получить справку по
выделенному фрагменту.
    Копирование справочной информации. Поскольку редактор текстов
подключен к окну Help, можно выделять и копировать любые фрагменты
текста подсказки, включая примеры. Проделаем это на примере команды
APPEND FROM.
     Пример 15.2. 
   Вызвав подсказку, выделим текст примера в окне Help и нажмем Ctrl+C, 
чтобы снять копию. Затем откроем окно для нового .PRG-файла (подпункт 
New подменю File) и клавишами Ctrl+V перенесем пример в него. Нажимая 
Ctrl+W, выполним запоминание, при этом потребуется в соответствующей 
строке дать .PRG-файлу имя. Теперь можно выполнять программу примера,
предварительно создав используемые в нем базы данных.
     Задание 15.2. 1. Осуществите на ЭВМ действия, описанные в
примере 15.2, и выполните программу с искусственными данными.
  2. Назначьте клавише F8 команду CLOSE DATABASES ("ЗАКРЫТЬ БД").

               15.3. Работаем в командном окне

     Действия через системное меню находят отражение в командном
окне. При длительной работе возникает большой список команд,
включающий команды Help, если вы обращались за подсказкой. В
принципе этот список является избыточной программой, поскольку вы
могли попадать в "тупиковые" ситуации, повторять действия из-за
смысловых ошибок. Напоминаем, что подпункт меню доступен, только
если созданы надлежащие условия действия. Ошибочные (искаженные вами)
записи команд также остаются в окне. Тем не менее, для начинающего
программиста возможность создания частей программы без их написания
на бумаге, причем с автоматической проверкой реализуемости действий,
привлекательна, ибо при этом можно избежать и мелких, но досадных
неточностей, и пропусков команд.
     Действия через меню можно перемежать выполнением команд,
непосредственно записываемых или воспроизводимых в окне. Если
необходимая команда уже есть в списке, достаточно подвести к ней
курсор и нажать Enter. Выполнившись, эта команда добавится в конец
списка (прежняя запись ее сохранится). Если команда немного
отличается от имеющейся, сделайте в последней изменения и нажмите
Enter. Измененная команда, выполнившись, добавится в конец списка,
а прежняя - восстановит свой вид.
     Если вы намерены превратить список в программу, ведите учет
команд, оказавшихся ненужными. Когда процесс обработки файлов (баз
данных) вами отлажен, превратите список в блок текста (Ctrl+A),
занесите его в карман (Ctrl+C), создайте новый .PRG-файл и передайте
в него содержимое кармана (Ctrl+V). Так создают линейные части программы.
Теперь можно приступать к ее редактированию, убрать лишнее,
добавить недостающее, например, организовать циклы, ветвления.
Чтобы реже использовать структуры IF, реализуйте ветви как функции
пользователя, указываемые в функции Iif. Эти функции можно создать
как отдельные файлы и с помощью редактора включить их в основной
.PRG-файл.
     Переходя к выполнению программы, закройте БД, открытые при
работе в командном окне. Для этого можно использовать, например
F8, предварительно назначив ей команду CLOSE DATABASES.
     Если командное окно перекрывает результаты выполнения команд,
его можно скрыть с помощью подпункта Hide подменю Window. Для
восстановления окна применяйте подпункт Command этого же подменю.
     Задание 15.3. Создайте и наполните 2 небольшие БД с одинаковой
структурой, откройте одну из них и через меню выполните с нею
разнообразные действия: вывод (LIST), индексирование, сортировку,
вывод упорядоченной БД, добавление в БД записей из другой БД,
пометку записей на удаление (по некоторому условию), упаковку,
замену значений поля (например, усечение строк-значений), вывод
окончательного содержания БД. Превратите полученный список команд
в программу и выполните ее, чтобы убедиться в ее пригодности.

         15.4. Особенности блочных и многофайловых программ

     Программа может быть представлена несколькими .PRG-файлами.
Один из них, содержащий главный блок, назовем основным. В каждом
.PRG-файле может быть несколько блоков. Если главный блок не
первый в файле, необходим заголовок главного блока:
               PROCEDURE <Имя основного .PRG-файла> .
     Для вызова редактора с целью набора или изменения текста
.PRG-файла (см. п. 15.1) и открытия соответствующего окна используют
команду          MODIFY COMMAND <Имя .PRG-файла или маска>.
     Маску задают, если забыли точное имя редактируемого файла.
В этом случае открывается окно для каждого имеющегося .PRG-файла с
соответствующим маске именем. В режиме "обегания" окон (Ctrl+F1)
вы опознаете нужный файл и удаляете прочие окна клавишей Esc.
     Имя и маску можно не указывать, тогда открывшееся пустое окно
получает имя Untitled, а при сохранении текста окна (Ctrl+W) придется
дать .PRG-файлу имя.
     Особенности многофайловых программ. Блочные программы рассмотрены
в п. 1.11. Старшим называют блок, прямо или косвенно вызывающий
другой (младший) блок, именуемый подблоком. Чтобы правильно
организовать блочную программу, надо знать, как система ищет подблок
в .PRG-файлах. Сначала идет поиск внутреннего блока с данным именем,
т.е. поиск в том файле, где записан вызывающий блок. Если подблок не
найден, поиск продолжается в процедурном файле (если он подключен).
Далее просматриваются .PRG-файлы со старшими блоками в очередности,
обратной очередности вызовов блоков: проверяются внутренние блоки.
Наконец, разыскивается отдельный файл, обозначенный именем искомого
подблока, и лишь после этого (если подблок не найден) сообщается об
ошибке. Блоки, хранимые в разных файлах, могут иметь одинаковые
имена, однако указанный выше порядок поиска исключает неоднозначность.
     Хотя процедурных файлов (см. п. 1.11) может быть несколько, в
любой момент подключен лишь один. Подключение нового файла автоматически
отключает предыдущий. Блок может не иметь параметров, но если они есть,
команда PARAMETERS должна быть первой после его заголовка (первой, если
нет заголовка блока).
     Пример 15.3. Программа из 3 файлов. Действия блоков не показаны.

*Основной файл Glav с 3 блоками  │*Процедурный файл Prcd с 2 блоками
*Главный блок вызывает           │ FUNCTION F2     && Блок-функция
*блоки F,F1,P1,F2,P2             │ PARAMETERS E
SET PROCEDURE TO Prcd            │  .  .  .        && Тело функции
 . . .  && Текст блока с вызовами│ RETURN G
SET PROCEDURE TO                 │ PROCEDURE P2    && Блок-процедура
FUNCTION F1   && Внутренний блок │ PARAMETERS X,Y
PARAMETERS A,B                   │  .  .  .        && Тело процедуры
 .  .  .         && Тело функции │
RETURN R                         │*Файл с именем F (имя функции)
PROCEDURE P1  && Внутренний блок │ PARAMETERS S && Блок без заголовка
PARAMETERS C,D                   │ .  .  .          && Тело блока F
 .  .  .       && Тело процедуры │ RETURN Z         && Конец блока F
*Конец основного .PRG-файла      │ PROCEDURE P3   && Внутренний блок
                                 │  .  .  .        && Тело блока P3
                                 │ FUNCTION F3    && Внутренний блок
                                 │  .  .  .        && Тело блока F3
     Внутренняя функция F3 недоступна для обращений, идущих из
файлов Glav, Prcd, но внутренние блоки F1,P1 доступны для обращений
из файлов F, Prcd, поскольку с ними в одном файле находится старший
блок. Обращение к внутренней процедуре P3 из файлов Glav, Prcd
становится возможным, если в конце обращения указать файл ее
местонахождения (см. ниже). Обращаться к блокам F2,P2 файла Prcd
из файла F можно, поскольку у нас процедурный файл отключается командой
SET PROCEDURE TO лишь в самом конце работы программы.
     Обращение к процедурам выполняется командой
   DO <Имя> WITH <Список фактических параметров> IN <Имя.PRG-файла>,
где <Имя> обозначает .EXE-, .APP- или .FXP-файл либо блок в .PRG-файле.
В данной последовательности и выполняется поиск процедуры. Например,
если найден .EXE-файл с именем процедуры, то к нему и производится
обращение, независимо от существования одноименных .APP- и .FXP-файлов.
При обращении к внутренней процедуре .PRG-файла извне его указывают
после слова IN: это гарантирует доступ к ней. Обращение к процедуре P3
(пример 15.3) из главного блока должно иметь вид  DO P3 IN F
(данная процедура без параметров).
     Процедура заканчивает работу при выполнении команд
  RETURN - возврат в вызывающий блок (см. ниже варианты RETURN);
  CANCEL - выход в командное окно;
  QUIT - выход из FOXPRO в DOS
или при выполнении иной последней в ее тексте команды. В последнем
случае происходит возврат в вызывающий блок, а если таким образом
завершается главный блок, выполняется переход в командное окно.
     Команда RETURN TO MASTER реализует прямой возврат в главный 
блок, а RETURN TO <Имя блока> - в старший блок с указанным именем. 
Как обычно, возврат происходит к команде, следующей за обращением
к завершившейся процедуре. Редко применяемая команда RETRY
возвращает на само это обращение. Она позволяет вести процесс
последовательных приближений к результату: на каком-то шаге
использования процедура оценивает результат как окончательный и
вместо RETRY использует записанную в ней команду RETURN.
     Использование параметров. Все переменные, участвующие в
списке фактических параметров, в том числе обозначающие результаты,
должны быть инициализированы. PUBLIC-переменные имеют значения по
умолчанию (.F.), PRIVATE-переменные должны получить значения с
помощью команд. Число формальных параметров (их список - в команде
PARAMETERS) не должно быть меньше числа фактических. Избыточные
формальные параметры получают значение .F..
Мы будем намеренно добавлять в команду имена PRIVATE-переменных
блока, изымая команду PRIVATE для экономии места. Внутри процедуры
число переданных параметров дает функция PARAMETERS().
     Параметры, кроме выражений, передаются по ссылке. Переменную
можно передать по значению, заключая ее в скобки (искусственное
выражение), например:  
  DO Pr WITH (A),B  && B передается по ссылке, A - по значению .
     Соответствие фактических и формальных параметров
устанавливается по порядку следования, поэтому избыточными могут
быть лишь последние формальные параметры. Нужно следить за
совпадением типов соответствующих параметров.
     Пример 15.4. Процедура P выводит в строке R, начиная с
колонки C, сообщение Sob, указанное пользователем (см. пример 4.8).
  PROCEDURE P
  PARAM  R,C,Sob,N        && N - не параметр, а местная переменная,
  N=Parameters()         && представляющая число переданных параметров
  R=Iif(N=0,24,R)        && Данная и следующие 2 строки задают
  C=Iif(N<2,0,C)         && правила умолчания
  Sob=Iif(N=3,Sob,"Нажмите любую клавишу для продолжения")
 @ R,C   SAY Sob
  =Inkey(0)              && Задержка сообщения на экране
  В отсутствие всех 3 параметров  в 24-й строке экрана выводится
стандартное сообщение "Нажмите любую клавишу для продолжения".
Для упрощения программы сохранение/восстановление экрана в ней не 
предусмотрено.
     Функции пользователя. Рассмотрим лишь отличия от процедур,
исключая очевидные. Используется общепринятая форма обращения:
       <Имя функции> ( <Список фактических параметров> ) .
Список может быть пустым, но скобки опускать нельзя. Эта запись
не является предложением, следует добавить хотя бы "=" слева.
Если обращаться к функции командой DO, возвращаемое ею значение
теряется. Тогда возникает вопрос: почему в данном случае
используется форма функции, а не форма процедуры?
     По умолчанию (RETURN опущено или в нем нет выражения) функция
возвращает .T.. Заголовок функции не обязателен, если она первый
(или единственный) блок в файле (см. пример 15.3, функция F в начале
файла F).
     Все параметры (в том числе и массивы) передаются в функцию по
значению, тем самым фактические параметры защищаются от изменений
в ее теле. Следствие: внутри функции должна быть описана копия
массива - фактического параметра (Мфк); происходящие в ней изменения
никак не скажутся на Мфк. Способ передачи переменных и массивов
можно изменить, но только для всех параметров сразу. Устанавливает
его команда                  SET UDFPARMS <Способ>,
где <Способ> - это VALUE ("значение") или REFERENCE ("ссылка").
Команду SET UDFPARMS REFERENCE применяют, если кроме главного значения
функции нужно возвращать побочные результаты - через параметры.
     Пример 15.5. Функция F, вычисляющая сумму абсолютных величин
элементов квадратной матрицы A, к тому же заменяет элементы их
абсолютными значениями.
DECLARE A[2,2]       && Для контрольного примера взята матрица 2х2
SET TALK OFF   && Выключаем отклики системы, мешающие обзору экрана
A = -1                          && Заполняем матрицу значениями -1
SET UDFPARMS REFERENCE               && Назначаем ссылочный способ
? "S =", F(A,2)               && Выводим сумму абсолютных значений
SET UDFPARMS VALUE          && Восстанавливаем способ по умолчанию
? A[1,1], A[1,2]           && Контрольный вывод 1-й строки матрицы
? A[2,1], A[2,2]           && Контрольный вывод 2-й строки матрицы
  FUNCTION F
  PARAMETERS A,N,S,I,J,T                 && S,I,J,T - не параметры
  S=0
  FOR I = 1 TO N
   FOR J = 1 TO N
   T = ABS(A[I,J])
   S = S + T
   A[I,J] = T
   ENDFOR
  ENDFOR
  RETURN S
     Следует, как в нашем примере, после обращения к функции
восстанавливать способ передачи, принятый по умолчанию, если только
ссылочный способ не используется в множестве обращений к функциям.
     Задание 15.4. Реализуйте на ЭВМ пример 15.5, изъяв команды
SET UDFPARMS. Вам придется добавить в функцию F описание массива A
(копии фактического) - после команды PARAMETERS. Убедитесь, что
в этом варианте контрольный вывод показывает неизменность исходной
матрицы.

                    15.5. Работаем с массивами

     В FOXPRO допустимы лишь одномерные и двумерные массивы.
Исходные сведения о массивах даны в пп. 1.7, 1.12. Здесь мы
рассмотрим их особенности и примеры. Начнем с того, что при появлении
описания массива все его элементы получают значение .F.. В дальнейшем
они могут приобретать значения другого, не обязательно одинакового типа.
Вместо квадратных скобок в описании массива и обозначении элементов
можно использовать круглые. Массив может иметь до 3600 элементов.
Максимальное число массивов - также 3600.
     Повторение описания массива не является ошибкой. Это делают,
например, если после заполнения одномерного массива остались
незанятые элементы в конце, для "усечения" массива. При повторном
описании данные сохраняются в одномерном массиве и, если изменяется
лишь число строк, в двумерном.
     Обозначение элемента двумерного массива может быть дано в
форме с одним индексным выражением (так называемый приведенный индекс
- это номер места элемента в памяти). Например, при описании
DECLARE A[3,3] элемент A[2,3] может быть записан как A[6], так как
стоит в памяти на 6-м месте от начала массива.
     Функция AELEMENT(<Мас>, <Ном1>, <Ном2>) возвращает приведенный
индекс элемента, находящегося в строке <Ном1>, столбце <Ном2>
массива <Мас>. Обратная функция ASUBSCRIPT(<Мас>,<Ном>,<ВырN>) для
элемента массива <Мас> с приведенным индексом <Ном> возвращает номер
строки, если <ВырN> = 1, и номер столбца, если <ВырN> = 2.
     Пример 15.6. Перепишем заново цикл в примере 15.5:
     FOR I = 1 TO N*N
      T = ABS(A[I])
      S = S + T
      A[I] = T
     ENDFOR
     Вывод массива на дисплей. При упражнениях с описываемыми ниже
функциями изменения содержания массива можно наблюдать, используя
команду    DISPLAY MEMORY LIKE <Имя массива> .
     Функция AINS (<Мас>,<Ном> ,<ВырN>) вставляет в массив <Мас>
заданный номером <Ном> элемент (<Мас> одномерный) или строку
(столбец). Вставляемые элементы получают значение .F.. Имеющие
больший номер соседние элементы или строки (столбцы) вытесняются
со своих мест (сдвигаются), причем последний элемент или строка
(столбец) утрачивается, поскольку размеры массива неизменны. <ВырN>
(значение 2) задают только при вставке столбца.
  Функция ADEL (<Мас>,<Ном> ,<ВырN>) удаляет заданные номером <Ном>
элемент одномерного массива или строку (столбец) двумерного.
Удаляемая строка (столбец) вытесняется строками (столбцами) с
большими номерами, а элементы "лишней" последней строки (столбца)
получают значение .F. (размеры массива не изменяются).  <ВырN>
(значение 2) задают только при удалении столбца.
  Функция ACOPY (<Мас1>, <Мас2> ,<Ном1>, <Кол>, <Ном2>) копирует
в массив <Мас2> <Кол> элементов массива <Мас1>, начиная с элемента,
имеющего номер <Ном1>. Если массива <Мас2> нет, он создается.
<Ном2> используют для задания номера первого принимающего элемента
в <Мас2>. Обязательны лишь первые 2 параметра.
  Пример: ACOPY(X,Y); массив Y не был описан. По "образу" массива X
создается массив Y и в него копируются значения всех элементов X.
  Функция ACOPY применима и к двумерным массивам. В этом случае
<Ном1> и <Ном2> являются приведенными индексами, а копируемые части
массивов содержат элементы, последовательно размещенные в памяти.
  Функция ASCAN (<Мас>, <Выр> ,<Ном1>, <Ном2>) ищет элемент массива
<Мас> со значением <Выр> и возвращает его номер или 0 - при
безуспешном поиске. Если аргумент поиска <Выр> - символьное выражение,
то поиск - приближенный (см. п. 3.5). Например, по аргументу "ИВАН"
может быть найден элемент "ИВАНОВ". При поиске в двумерном массиве
возвращается приведенный индекс. Элементы массива, тип которых не
совпадает с типом <Выр>, пропускаются. Если поиск ведется в части
массива, задают номер <Ном1> начального и <Ном2> конечного элементов
этой части (для двумерного массива - приведенные индексы).
  Теперь мы видим одно полезное использование функций AELEMENT,
ASUBSCRIPT: преобразования на входе и выходе функций ACOPY и ASCAN,
используемых с двумерными массивами.
     Функция ASORT (<Мас> ,<Ном1>, <Ном2>, <ВырN>) либо сортирует
одномерный массив <Мас> (его часть от элемента с номером <Ном1> до
<Ном2>), либо упорядочивает <Ном2> строк двумерного массива по значению
элементов столбца с номером <Ном1>. Все элементы столбца должны быть
однотипны: числа, строки или даты. <ВырN> задают как 0 (1) для
сортировки по возрастанию (убыванию); по умолчанию используется 0.
При 2 параметрах сортируется часть (конец) одномерного массива или
все строки двумерного. Для сортировки по возрастанию всего
одномерного массива достаточно одного параметра.
     В п. 3.1 рассмотрены также функции ADIR и AFIELDS, использующие
массивы. В задачах, где содержание одной или ряда записей БД используют
при обработке или анализе содержания других записей, оказываются удобными
команды обмена данными между массивами и БД.  Команда
         SCATTER FIELDS <Список полей> TO <Приемник> MEMO,
где <Приемник> - это имя массива или слово MEMVAR, последовательно
переносит значения полей текущей записи в одномерный массив или,
если указали MEMVAR, в переменные, одноименные с копируемыми полями
записи. Для наглядности и во избежание ошибок в программе имена
переменных следует снабдить квалификатором M, например M->X или M.X.
Имя массива может обозначать несуществующий массив (он будет создан).
Размер существующего массива автоматически "подгоняется", если он мал.
     Необязательный атрибут MEMO необходим, если копируются и
Memo-поля. Если опущен атрибут FIELDS, поля записи копируются по
порядку их описания в структуре. Если же в конце команды добавлен
атрибут BLANK, создается множество незаполненных переменных или
элементов массива, размеры и типы которых определяются соответствующими
полями БД.
     Команда GATHER по своему действию является обратной SCATTER:
         GATHER FROM <Источник> FIELDS <Список полей> MEMO,
где <Источник> - это имя массива или слово MEMVAR, обозначающее
множество переменных со значениями полей. Когда атрибут FIELDS
<Список полей> опущен, поля текущей записи заполняются по порядку их
описания в структуре, включая и Memo-поля (если присутствует атрибут
MEMO). Нужно следить за тем, чтобы тип значений соответствовал типу
полей. При несовпадении числа элементов массива и числа полей, лишние
игнорируются.
     Пример 15.7. Копирование полей записи, включая Memo-поля, в
одноименные переменные, редактирование и возврат значений в запись.
   USE Student
    SCAN                          && Начало цикла обработки записей
    SCATTER MEMVAR MEMO       && Копируются все поля текущей записи
    @ 1, 5 SAY "Фамилия " GET M.Famil
    @ 3, 5  . . .            && Редактирование следующего значения
    .  .  .
    READ
    GATHER MEMVAR MEMO                 && Возврат значений в запись
    ENDSCAN                        && Конец цикла обработки записей
     При участии в обработке сразу нескольких записей, сложной или
неизвестной последовательности их выборки рекомендуется другая пара
команд.  Команда
  COPY TO ARRAY<Имя> FIELDS<Список полей> <Границы> <Условия>
представляет таблицу БД двумерным массивом, выбирая из нее колонки,
соответствующие указанным полям, и строки тех записей, которые
соответствуют <Условиям> и взяты из области действия (<Границы>).
Массив <Имя> должен быть предварительно описан и обязательно как
двумерный, даже если копируется одно лишь поле. В отсутствие
атрибута FIELDS копируются все поля. Если число полей БД и колонок
массива не совпадает, лишние игнорируются. Команда заканчивает
работу после заполнения всех строк массива или достижения конца БД.
     Команда APPEND FROM ARRAY<Имя> FOR<ВырL> FIELDS<Список полей>
дополняет активную БД записями, каждая из которых получает значения
элементов очередной строки массива <Имя>. Если в массиве больше
колонок, чем полей в БД, лишние игнорируются. Если задано условие
<ВырL>, записи порождаются только теми строками массива, которые ему
удовлетворяют. Хотя проверяются элементы массива, в условии указывают
соответствующие им поля записи. Если БД была пуста, она просто
наполняется.
     Пример 15.8. В БД Otryad сведены записи о студентах разных
факультетов, объединившихся в строительный отряд, причем факультет
(символьное поле Fak) обозначается номером. Имеется БД-словарь Faki,
записи которой ставят в соответствие эти номера и названия (поле
Nazv) факультетов. Выводится список фамилий (поле Fam в БД Otryad)
студентов-мужчин с названиями факультетов, на которых они обучаются.
  DECLARE A[10,2]  && 1-й элемент строки - номер факультета
  USE Faki
  COPY TO ARRAY A
 ? 'СПИСОК МУЖЧИН ОТРЯДА "ГРОМ И МОЛНИЯ" '
    USE Otryad
    SCAN FOR Pol = "М"           && Именем Pol обозначено поле в БД
    ? Fam, A[ Ascan(A,Fak) + 1]   && Ascan ищет факультет по номеру
    ENDSCAN
     Избегая "хаотических" обращений к записям БД Faki, расходующих
время, быстро извлекаем необходимые названия из массива A. При
этом преобразования приведенного индекса в номера строки и столбца
не нужны, ибо в памяти элемент-название является следующим за
элементом-номером факультета.
     Задание 15.5. Составьте программу, которая, используя в БД
Teacher  поля Name (фамилия, инициалы преподавателя) и Kafedr (условный 
номер кафедры), а также аналогичное поле Kafedr, поле Nazv (название
кафедры), Tel(телефон кафедры) во вспомогательной БД Kaf, выводит список
преподавателей с фамилиями от A до Г включительно. В списке, кроме
фамилии и инициалов преподавателя, должны быть название и телефон кафедры
- места его работы. Используйте массив - копию БД Kaf.

            15.6. Выполняем макроподстановки и подстановки
                            при выводе текстов

     Начальное представление о макроподстановках дано в п. 1.9.
В FOXPRO макроподстановки применяются для формирования команд шире,
чем в CLIPPER. Элемент массива может быть макропеременной.
     Пример 15.9. В переменные A,B,C,D,E записаны тексты FOR-условий
(вместе со словом FOR), а в переменные U,V,W,X - начала команд,
например, "LIST","DELETE" и т.п. Для образования команд программы
можно следующим образом комбинировать эти начала и условия:
&U &A, &U &B и т.д. Обратите внимание на пробел внутри. Если его
не будет, возникнет неопределенное ключевое слово: LISTFOR и т.п.
     Функция EVALUATE (см. п. 1.9) заменяет макроподстановку в
выражениях и выполняется быстрее. Она рекомендуется для
использования в явных и неявных циклах (сравните с EVAL, пример 4.18).
     Пример 15.10. Выведем список студентов (см. пример 15.8),
используя произвольное условие выбора Usl; вместо явного цикла
воспользуемся неявням в команде LIST.
  ACCEPT "Введите условие  " TO Usl  && Вводится условие в виде строки
  USE Otryad
  LIST FOR Evaluate(Usl)     && "Быстрая" подстановка в неявном цикле
     Макроподстановку используют для вставок в текст стандартных
документов: приглашений, извещений, поздравлений и т.п. (см. п. 4.7).
В FOXPRO имеются более удобные средства. Команда \ (или \\), имеющая
вид                    \ <Фрагмент текста> ,
выводит заданный фрагмент (не символьную строку, ибо кавычек-
ограничителей нет). После вывода команда \ выполняет переход в начало 
следующей строки, а \\ - нет. Если предварительно выполнена команда  
SET TEXTMERGE ON, в выводимый текст могут включаться значения 
выражений, выделенных во фрагменте двойными кавычками <<, >>.
     Пример 15.11. Система контроля поручений использует данные,
хранимые в БД Conduit: номер поручения (поле Number), срок исполнения
(DatIsp), фамилию исполнителя с инициалами (Ispoln), его пол (Pol).
Следующая программа выявляет поручения, срок которых истек, и выводит
напоминание исполнителю:
SET TEXTMERGE ON
USE Conduit
SCAN FOR Datisp < Date() && Цикл выбора из БД просроченных поручений
\
\               Уважаемый <<Ispoln>> !
\
\    Поручение N <<Number>> Вами должно быть выполнено к <<Datisp>>.
\Сегодня <<Date()>>.    Будьте любезны представить результаты или
\объяснительную записку.
\    Буду весьма признателен.
\    <<Date()>>.               Ваш шеф               И.В.Грозный
\
ENDSCAN                  && Конец цикла выбора

     Чтобы не получалось, например, "Уважаемый СИДОРОВА А.А.",
первую строку текста надо задать по-иному:
 \           Уважаем<<Iif(Pol="М", "ый", "ая")>> <<Ispoln>> !  .
     Аналогичные возможности используются в конструкции
TEXT  . . .  ENDTEXT (см. пример 16.5).
     В общем случае команда SET TEXTMERGE имеет вид
 SET TEXTMERGE <Ключ> TO <Файл> ADDITIVE  WINDOW<Окно> <Видимость>,
где <Ключ> - это ON или OFF, <Файл> обозначает текстовый файл, куда
можно направить выводимый текст в режиме дополнения файла (если
ADDITIVE присутствует) или перезаписи (ADDITIVE нет). Если файл с
этим именем не найден, он создается. Запись в файл будет скрытой,
если атрибут <Видимость> записан как NOSHOW, а при атрибуте SHOW
(значение по умолчанию) текст наблюдается на экране, причем в
указанном окне, если присутствует атрибут WINDOW. Закрытие <Файла>
выполняет команда SET TEXTMERGE TO.
     Задание 15.6. Используя TEXT ... ENDTEXT, составьте программу,
печатающую поздравления с днем рождения сотрудников, отмечающих его
в данном месяце (см. пример 4.12). В конце поздравления должна стоять
дата дня рождения и слова "Коллектив сотрудников".

            15.7. Назначаем цветовые установки

    Вспомните стандартное и дополнительные цветовые сочетания (п. 9.5).
    Для совместимости с предыдущими версиями в FOXPRO включена команда
SET COLOR TO <Станд.сочетание>,<Дополн.сочетание>,<Цвет обрамления>,
причем в отличие от CLIPPER (см. п.9.5, там же - цветовая таблица) 
дополнительное сочетание цветов одно: оно используется для GET-полей, 
как выбранных, так и невыбранных, для выбранных пунктов меню и т.п. 
Команда без параметров восстанавливает цветовые установки, действующие 
по умолчанию.
    Пример 15.12.
 SET COLOR TO W+/R*, GR+/B, R  && Для сообщения SAY - станд.сочетание
 @ 4,2 SAY "НЕМЕДЛЕННО ВВЕДИТЕ STERZNI !" GET Sterzni DEFAULT 0
   READ
   WAIT  && Сообщение WAIT также выводится белыми буквами на красном фоне 
 SET COLOR TO && Восстановление цветовых установок, действующих по умолчанию
Значение Sterzni изображается желтыми буквами на синем фоне. Сообщения
мерцают (это задано знаком * в конце стандартного сочетания).

    Богатые возможности цветового оформления предлагает команда
       SET COLOR OF SCHEME<ВырN> TO <Список цветовых пар>,
которая соотносит цветовой схеме, заданной номером <ВырN> ,10 цветовых
пар, каждая из которых будет "красить" определенные элементы. Список 
цветовых пар может быть задан явно или в виде SCHEME<ВырN>. Последнее 
означает, что список заимствуется из цветовой схемы с другим номером. 
Явный список может быть неполным. При этом пропуски обозначены
запятыми, как в CLIPPER. Пропуски автоматически восполняются парами 
из текущего цветового набора. Используют цветовую схему путем ссылки 
вида COLOR SCHEME <ВырN> в командах определения меню, окон, в командах
@ ... SAY ... GET и т.д.
    Рассмотрим применение цветовых пар схемы 10 (ниже указаны их номера
в схеме), используемой для раскраски элементов окна редактирования BROWSE:
 1 - невыделенные записи в редактируемой таблице;
 2 - обозначенное маркером поле текущей записи;
 3 - бордюр, включая имеющиеся на нем знаки;
 4 - заголовок текущего BROWSE-окна (окна переднего плана);
 5 - заголовок BROWSE-окна, не являющегося текущим окном;
 6 - блок текста (см. п. 15.1), выделенный в текущем поле;
 7 - текущая запись; 2-й элемент 7-й цветовой пары окрашивает
также точку - пометку на удаление записи, поэтому он должен быть
контрастным по отношению к цвету фона в 1-й цветовой паре;
 8 - тень возле рамки окна BROWSE. 9 и 10 цветовые пары не используются.
    Цветовая схема может иметь номер от 1 до 24, причем первые 12
схем имеются в готовом виде (см. приложение 6), а рекомендуется
занимать номера с 17 по 24. Этого вполне достаточно для творчества.
Изначально схемы 13-24 совпадают со схемой 1.
    Установку цветовых пар можно сделать и в интерактивном режиме.
Для этого надо воспользоваться пунктом  COLOR подменю WINDOW для
вызова окна установки цветов. В правом верхнем углу окна в виде кнопки
показано имя объекта раскраски, например WINDOW ("окно"). Через эту
кнопку можно вызвать список объектов, если нам нужен другой объект
или мы хотим создать совершенно экзотическую схему с новым номером:
свободные номера также обозначены в списке. В окне также даны
фрагменты, показывающие использование каждой цветовой пары. Их
окраска будет изменяться в ходе экспериментов. Итак, вы можете
изменить существующие и создать новые цветовые схемы. Чтобы не
делать эту работу каждый раз, можно кнопкой <Save> сохранить
получившийся набор схем в файле FOXUSER.DBF под заданным именем.
В следующем сеансе работы вы загрузите этот набор кнопкой <Load>.
Для загрузки цветового набора, хранимого в FOXUSER.DBF, можно
также использовать команду
          SET COLOR SET TO <Имя цветового набора>
    Есть еще одна интересная команда, очищающая прямоугольную
область, заданную координатами Y1,X1 (Y2,X2) левого верхнего
(правого нижнего) угла, и выполняющая "окраску" области:
      @ Y1,X1 FILL TO Y2,X2   COLOR <Список цветовых пар> .
В сокращенном виде (без атрибута COLOR) команда использует
текущие цветовые установки.
     Задание 15.7. Сравните варианты цветового оформления в
программе примера 15.12: имеющийся в ее тексте и созданные вами
с использованием готовых цветовых схем (без команды SET COLOR TO,
но со ссылкой на схемы в команде @ ... SAY ... GET).


                    ЗАКЛЮЧЕНИЕ К ГЛАВЕ 15

      Если вы сочетали изучение материала данной главы с практикой
на ЭВМ, вы подготовились к использованию FOXPRO в серьезных задачах,
требующих хороших навыков работы через системный интерфейс и в окне
команд, умелого использования системы помощи. Темп вашего дальнейшего
продвижения зависит от этих навыков. Обращаясь к системе помощи, 
изучая примеры, вы освоите и те детали, которые опущены в руководствах
из-за ограниченного объема или на которые вы не обратили внимания
при их чтении.
