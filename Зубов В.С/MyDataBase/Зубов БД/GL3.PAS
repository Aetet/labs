


                   3. РАБОТАЕМ С БАЗАМИ ДАННЫХ

     В данной главе вы получите детальную информацию, необходимую
для использования в БД сложных индексных выражений и фильтров,
для серьезной практики поиска в БД, нахождения числовых характеристик,
сортировки, узнаете команды обработки БД. Вы научитесь создавать поля
примечаний, размеры которых в отличие от обычных символьных полей
могут изменяться, узнаете, как переименовывать, стирать, копировать,
уплотнять БД, осуществлять их взаимодействие.
     Это последняя глава, где изучается общий материал для языков
CLIPPER и FOXPRO. Ваши знания в области использования БД будут
расширены в последующих главах.

        3.1. Получаем справочную информацию о базах данных

     Справочную информацию можно разделить на 3 категории: информация
о множестве файлов и их состоянии - такая, как в каталогах;
информация о конкретной базе данных (БД); информация об элементах
БД. Начнем с функции Adir(), возвращающей число файлов в текущем
каталоге  и  5 векторов (через параметры):   вектор имен файлов,
вектор размеров файлов, вектор дат создания, вектор времен создания,
вектор атрибутов файлов. Для получения информации о подмножестве
файлов задают аргумент - символьную маску <Шаблон имен>. Например,
шаблон "*.dbf" позволяет получить сведения о базах данных.
      В языке CLIPPER указанные векторы представлены отдельными
массивами <Мас1> - <Мас5>:
    Adir(<Шаблон имен>,<Мас1>,<Мас2>,<Мас3>,<Мас4>,<Мас5>).
Ни один аргумент не является обязательным. При пропуске аргумента
оставляйте запятую. Массивы надо предварительно описать.
    Пример 3.1. Выведем имена и даты создания БД текущего каталога:
  PRIVATE n:= Adir("*.dbf")
  PRIVATE Name[n], Dat[n], k:=0, i
  Adir("*.dbf", Name, ,Dat)   && Заполняем массивы информацией о БД
   FOR i = 1 TO n
 ? Name[i], Dat[i]                && Вывод имени и даты создания БД
   ENDFOR
     В FOXPRO вышеуказанные 5 векторов представлены столбцами
двумерного массива <Мас>, который порождается функцией Adir():
 Adir (<Мас>,<Шаблон имен>); ниже дан вариант для FOXPRO, не
требующий описания массива.
   n = Adir (BD, "*.dbf")     && Шаблон - параметр необязательный и
   FOR i = 1 TO n        && пишется на 2 месте в отличие от CLIPPER
 ? BD[i,1], BD[i,3]     && 1-й столбец - имена, 3-й - даты создания
   ENDFOR
     Функция Afields() возвращает число полей активной БД и 4
вектора (через параметры): вектор имен полей, вектор их типов, вектор
размеров полей и вектор количеств десятичных знаков (для полей типа
"N"). В языке CLIPPER указанные векторы представлены массивами
<Мас1> - <Мас4>, два первых - символьные, последние - числовые:
            Afields (<Мас1>,<Мас2>,<Мас3>,<Мас4>).
Ни один аргумент обязательным не является, массивы надо описывать.
     Пример 3.2. Выведем названия и типы полей БД  DETI (п. 2.2):
    USE Deti
    PRIVATE n:=Afields(), i
    PRIVATE Name[n], Tip[n]
    Afields (Name, Tip)      && Если опущен конец списка, запятые
     FOR i = 1 TO n          &&  в конце   можно не оставлять
    ? Name[i], Tip[i]
     ENDFOR
     В FOXPRO вышеуказанные векторы представлены столбцами двумерного
массива <Мас>, порождаемого функцией Afields. Это ее единственный
аргумент. Массив <Мас> описывать не надо. Ниже приведен вариант для
FOXPRO:
   n = Afields(Struc)                  && Порождается массив Struc
   FOR i = 1 TO n
  ? Struc[i,1], Struc[i,2]      && 1-й столбец - имена, 2-й - типы
   ENDFOR
     Функция File ("<ИмяF>"), где <ИмяF> - имя файла (обязательно с
расширением и, возможно, с указанием пути к файлу) проверяет
существование файла любого типа. Допускается аргумент в виде символьной
переменной или выражения, например, символьной маски (см. п. 1.4).
Функция возвращает .T., если указанный файл или файл, имя которого
удовлетворяет маске, существует в текущем каталоге или на указанном
пути, иначе возвращает .F.. Во избежание недоразумений предваряйте
создание файла проверкой существования одноименного файла с помощью
функции File().
     Функция DBF() для активной БД возвращает в виде символьной
строки имя (в языке FOXPRO) или алиас (в языке CLIPPER; в отсутствие
алиаса - имя) активной базы данных. Если открытой БД нет,
возвращается пустая строка. В языке FOXPRO функция может иметь вид
DBF(<Область>), тогда она применима к любой из открытых БД.
Аналогичное применение в языке CLIPPER имеет функция Alias (<Область>).
     Число записей в БД с учетом записей, помеченных на удаление,
возвращает функция Reccount(), размер записи в байтах - Recsize(),
размер заголовка БД в байтах - Header(), число полей в структуре
БД - Fcount(), номер текущей записи - Recno(). Запомните, что Recno()
возвращает 0, если в текущей области нет открытой БД, и  -1, если
открытая в ней БД не содержит записей. Все эти функции в FOXPRO могут
иметь аргумент <Область>, тогда их можно применять не только к
активной, но и к любой открытой БД. В CLIPPER, чтобы получить тот
же эффект, надо уточнять функцию алиасом (именем БД, если нет алиаса):
          <Алиас или имя БД> -> ( <Функция> ).
Это правило языка CLIPPER применимо и к сложным выражениям,
содержащим указанные функции, выражение также заключают в скобки.
Допускается замена алиаса заключенным в скобки выражением, дающим
номер рабочей области.
     Функции Key(<ВырN>) (FOXPRO) и IndexKey(<ВырN>) (CLIPPER)
возвращают в виде строки индексное выражение, где <ВырN> - номер
индекса.
     Функция Found() возвращает значение .T., если предыдущий акт
поиска (см. п. 3.4) завершился успешно. Мы говорим необязательно о
команде поиска, в некоторых случаях поиск выполняется неявно.
Функция Deleted() возвращает .T., если текущая запись помечена на
удаление. В FOXPRO эти функции могут иметь аргумент <Область>, в
языке CLIPPER их можно уточнять алиасом, как и следующие ниже функции.
     С полями записи можно работать, как с элементами массива, по
номеру <Ном> поля в структуре БД. Эту возможность в языке CLIPPER
обеспечивают функции FieldName(<Ном>) - возвращает имя поля БД,
FieldGet(<Ном>) - возвращает значение поля текущей записи,
FieldPut(<Ном>,<Выр>) - помещает значение <Выр> в указанное поле БД.
Напротив, функция FieldPos(<ВырC>) возвращает порядковый номер поля,
имя <ВырC> которого задано, например: FieldPos("Pol").
    В FOXPRO функция Field(<Ном>,<Область>) возвращает имя поля БД,
необязательный второй параметр позволяет работать с любой из открытых
БД. Если поля с таким номером нет, функция возвращает пустую строку.
     Функция Diskspace() возвращает размер свободного пространства
(в байтах) на текущем диске. В языке CLIPPER возможен аргумент: 1
для диска "A", 2 - для диска "B" и т.д. (диск не обязательно
текущий).
     Существуют и другие справочные функции (см. приложения 1,  ). В
частности, в FOXPRO имеется большое число функций вида SYS(<Номер>
...), возвращающих разнообразную информацию в символьном виде.
     Задание 3.1. Получите двумя разными способами размер
существующей БД: по информации Adir() и через функции, дающие
размеры составных ее элементов.

           3.2. Применяем сложные индексные выражения

      Функции в ключах индекса. В индексных выражениях часто
используются функции Upper и Trim. Функция Upper приводит
представление букв в символьном ключе к "стандарту" - верхнему
регистру (не забывайте, что коды строчных и прописных букв
различаются). Тем самым мы избавляемся от влияния небрежности в
заполнении этих полей и иных факторов. Например, фамилии DeVilliers,
O'Connor и Адельсон-Вельский займут в индексе положение согласно
алфавиту.
     Функция Trim, исключая концевые пробелы в ключе или
составляющей ключа, позволяет экономить память, отводимую для
индекса. В ключах индекса применяют и пользовательские функции. В
[1] приведен пример функции, показывающей процент проиндексированных
записей в процессе индексирования больших БД. После индексирования
эта функция исключается из состава ключа.
     Составные ключи. Если использование одного поля БД в индексе
не создает достаточной упорядоченности, применяют ключи, содержащие
больше полей. Здесь требования исходят от задач. Например, БД
"Студент" может быть проиндексирована по полю "Факультет". Для
некоторой задачи этого достаточно, тогда как для другой - надо внести
упорядоченность по полю "Курс" в подмножество записей каждого
отдельного факультета. Поле "Курс" при этом имеет подчиненную роль,
а поле факультет - главную. Если поменять их роли в индексе, то
напротив, подмножества всех записей для каждого отдельного курса
вуза будут рассортированы по факультетам. Главное поле должно
указываться в начале индексного выражения, а подчиненные за ним,
в порядке убывания старшинства.
     Пример 3.3. Пусть в БД  Kadr  поле Famil содержит фамилии
и инициалы сотрудников, Pol - указывает его пол ("МУЖ","ЖЕН"), а
поле Otdel - отдел, где он работает. Все три поля - символьные.
Dtr (дата рождения) - поле типа "Дата", поле Stag (стаж работы) -
числовое. Необходимо упорядочить БД по отделам, в рамках каждого
отдела - по полу сотрудников, а в рамках полученных групп записей -
по стажу работы и вывести список сотрудников.
  USE Kadr
  INDEX ON Otdel + Upper(Pol) + Str(Stag,2) TO OPStag
  LIST Famil, Dtr, Stag
     Для получения составного индексного выражения значения полей
приводят к одному типу (обычно - к символьному, изредка - числовому).
В нашем примере преобразуется значение поля Stag. Наряду со
знаком "+" может использоваться знак "-", обозначающий разновидность
конкатенации символьных строк.
     Созданный нами индекс OPStag может использоваться в задачах,
где требуется упорядоченность лишь по отделам, а по стажу или полу
и стажу не нужна. Иначе говоря, индекс, основанный на левом
подвыражении уже существующего ключа индекса, является излишним.
     Неполные индексы. Индекс, созданный с атрибутом UNIQUE,
является частным случаем неполного индекса. В языке FOXPRO и в версии
CLIPPER 5.02 имеется возможность создания неполных индексов путем
включения FOR-условия в команду построения индекса. В нем будут
учтены лишь записи, удовлетворяющие указанному условию.
     Пример 3.4. Откроем БД Kadr и создадим неполный индекс Otd
по полю Otdel, включив в индекс только женщин. Выведем список.

* Программа показывает возможность неполных индексов в CLIPPER 5.01
   USE Kadr
   INDEX ON Iif(Upper(Pol)="ЖЕН", Otdel + Str(Recno(),5),;
                    Replicate(" ",Len(Otdel)+5))   TO Otd  UNIQUE
   IF Upper(Pol) = "МУЖ"   && Проверка начальной (в индексе) записи
   SKIP && Пропуск единственной возможной в индексе "мужской"записи
   ENDIF
   LIST Famil, Otdel REST              && Атрибут REST препятствует
                      &&переустановке указателя на начальную запись
     Итак, мы установили соответствие между каждой "мужской" записью
и искусственным ключом, состоящим из одних пробелов. Поскольку
индекс имеет атрибут UNIQUE, лишь одна такая запись будет включена
в него (или ни одной, если на предприятии собрались одни "амазонки"),
причем она окажется начальной в индексе. В данной задаче мы не должны
так поступать с женщинами, даже если они из одного отдела. Именно
поэтому добавлен в ключ номер записи:  Otdel + Str(Recno(),5).
Значение ключа в каждой "женской" записи теперь уникально,  т.е.
атрибут UNIQUE "обезврежен".
     Использование неполных индексов, ограничивая множество
доступных записей, экономит время и поэтому является хорошей
альтернативой использованию фильтров (см. ниже).
    Задание 3.2. Создайте для БД Kadr неполный индекс по 2 полям:
Otdel (старшее поле) и Famil, включив в него только сотрудников-
мужчин. В варианте для FOXPRO включите FOR-условие в команду INDEX.

        3.3. Фильтры. Структура команд. Область действия

     При разъяснении элементов языка часто используют термин "по
умолчанию". Он означает, что если выбор того или иного режима не
сделан в программе, режим назначается автоматически, а если какие-
либо атрибуты команд или аргументы функций опущены, выбирается
некоторый вариант соответствующих им действий - действия по умолчанию.
     Фильтры. Часто для решения задач в базах данных (БД) требуется
выделение и обработка некоторого подмножества записей. Вы можете
сделать "невидимыми" прочие записи, назначив фильтр. Фильтр
назначается, когда БД активна, и действует до ее закрытия или до
выключения фильтра.  Команда      SET  FILTER  TO  <ВырL>  задает
условие фильтрации <ВырL>, которое должно быть истинно лишь для
записей обрабатываемого подмножества. При переключении рабочих
областей фильтр сохраняется; на другую БД его действие не
распространяется, но каждая открытая БД может иметь свой фильтр.
     Фильтр начинает действовать  п о с л е  любого перемещения
указателя в БД. Обычно это осуществляют командой  GO TOP, которая
ставит указатель на первую запись, удовлетворяющую условию
фильтрации (GO BOTTOM ставит его на последнюю такую запись).
Команда SET FILTER TO (без аргумента) прекращает действие фильтра
активной БД.
     В FOXPRO функция  FILTER (<Область>) возвращает в виде строки
условие фильтрации для указанной рабочей области. Ее аргументом может
быть номер области <ВырN> или ее алиас <ВырC>. В языке CLIPPER тот
же результат возвращает функция DBFilter(), уточняемая при
необходимости алиасом рабочей области:
                  <Алиас> -> ( DBfilter() ).
     Пример 3.5. Вновь обратимся к БД  Kadr   (см. пример 3.3).
 а) Необходимо вывести список мужчин-сотрудников с указанием отдела,
используя команду вывода LIST.  Выведем и условие фильтрации.
  USE Kadr
  SET FILTER TO  Upper(Pol) =="МУЖ"
  LIST Famil, Otdel    && Команда LIST обеспечивает движение по БД
  S = DBFilter()           && В FOXPRO надо записать  S = Filter()
  SET FILTER TO                        && Выключение фильтра
  ? "Условие фильтра: ", S             && Вывод условия фильтрации
 б) Выведем список сотрудников, дети которых (БД Deti, см. пример 2.6)
имеют дату рождения после 31 декабря 1985 г. Чтобы старший ребенок
сотрудника оказался первым, проиндексируем БД Deti по составному
ключу TabNum + DTOS(Dtr): дата рождения Dtr приведена к символьному
типу, а поле TabNum - символьное. Поле, по которому осуществляется
связь БД, является старшим в ключе индекса (обязательное требование).
  USE Deti
  INDEX ON TabNum + DTOS(Dtr) TO TbDtr
  SELECT 0
  USE Kadr
  SET FILTER TO Deti->Dtr > CTOD("12/31/85")
  SET RELATION TO TabNum INTO Deti
  LIST TabNum, Famil
   В фильтре материнской БД можно указывать поля дочерних БД (к
 моменту его использования связь БД должна быть установлена).
     Программа задания "б" усложняется, если надо выявлять не более
поздние, а предшествующие дате  дни рождения. Нужно обратить порядок
следования детей одного сотрудника (младший ребенок - первый) и при
этом предотвратить вывод фамилий бездетных сотрудников. Дело в том, что
при неуспешном поиске в БД Deti указатель устанавливается на фиктивную
запись с пустым значением поля Dtr (наименьшим). Используйте в фильтре
функцию Empty().
     Мы не позаботились о начальном перемещении указателя, так как
команда LIST делает это сама, как и другие команды с неявным циклом.
Запоминание условия фильтрации имеет смысл, если оно сложное и вновь
может потребоваться, хотя бы и в другой БД (его назначают после открытия
БД командой  SET FILTER TO  &S,   где & - знак макроподстановки).
     Команда SET DELETED ON реализует частный случай фильтрации
записей - записи, помеченные на удаление, становятся невидимыми.
Доступ к ним восстанавливается, если нужно, командой SET DELETED OFF.
О фильтрах в языке FOXPRO см. дополнительно  п. !!!!!.
     Структура команд БД. Многие команды, работающие с БД, содержат
неявный цикл, обрабатывая в нем некоторое множество записей.
Для определения рамок множества задают  область действия ("границы"
по терминологии FOXPRO; этого термина мы и будем, как правило,
придерживаться), определяя ее одним из следующих атрибутов команды:
  RECORD <Номер> - обрабатывается единственная запись, перед этим
неявно выполняется команда  GO <Номер> ;
  NEXT <Кол> - обрабатывается <Кол> записей, начиная с текущей;
  REST  -  обрабатываются записи, начиная с текущей и до конца;
  ALL - обрабатывается весь файл. Применение фильтра вносит коррективы
в смысл этого и двух предыдущих атрибутов. В частности, атрибутом
NEXT задается количество очередных записей, удовлетворяющих условию
фильтрации. На действие атрибута RECORD фильтр не оказывает никакого
влияния. Например, команда LIST Famil RECORD 2 всегда реализует
вывод поля Famil второй записи независимо от того, удовлетворяет ли
запись фильтру.
     Если "границы" не заданы, команды DELETE, DISPLAY, RECALL и
REPLACE обрабатывают только текущую запись, в других командах БД
по умолчанию предполагается атрибут ALL (обработка всех записей).
     Уточнение множества обрабатываемых записей помимо фильтра и в
рамках отдельной команды реализует FOR-условие:    FOR <ВырL> .
Из области действия для обработки выбираются те записи, для которых
<ВырL> истинно. Заметим, что FOR-условие не изменяет смысл атрибута
NEXT.
     Кроме FOR-условия, возможно WHILE-условие:   WHILE <ВырL> .
Оно обеспечивает усечение области действия: записи из нее
обрабатываются, пока <ВырL> истинно. Так поступают, когда граница
фактической области обработки точно не известна; область действия
назначают "с запасом". Если команда содержит WHILE-условие, обработка
всегда начинается с текущей записи, даже если задан атрибут ALL.
     Итак, все указанные выше атрибуты обязательными не являются.
Условимся в определениях выделять жирным шрифтом обязательные
элементы.   Если FOR- и WHILE-условия обозначить термином <Условия>,
общая часть структуры команд БД приобретает вид
          <Имя команды> <Список> <Границы> <Условия> .
Порядок следования элементов команды после ее имени произволен.
Примеры имени команды: LIST, DISPLAY. В этих командах <Список>
определяет выводимую информацию, они удобны при отладке
программы и по умолчанию делают вывод на дисплей. Атрибут TO PRINT
переключает вывод на принтер, атрибут TO FILE <Имя файла> - в
текстовый файл. Записи выводятся с их номерами. Атрибут OFF
исключает вывод номеров.
     Пример 3.6. Усложним задачу примера 3.5: проиндексируем БД
Kadr по полю Otdel и выведем на принтер список мужчин того отдела,
который в индексе идет первым, подавляя вывод номеров записей.

  USE Kadr
  INDEX ON Otdel TO Tdl
  Otd = Otdel                                && Запоминание отдела
  LIST OFF Famil FOR Upper(Pol) =="МУЖ" WHILE Otdel == Otd TO PRINT
  EJECT          && Заключительный перевод строки и протяжка бумаги
     В заключение рассмотрим еще одну команду БД.  Команда
  REPLACE  <Список замен значений полей>  <Границы>  <Условия>
реализует присваивание значений одному или нескольким полям записи.
Если не указаны ни <Границы>, ни <Условия>, обрабатывается только
текущая запись. Одна замена поля   в <Списке замен значений полей>
представлена элементом списка         <Поле> WITH <Выражение>.
<Выражение> дает присваиваемое полю значение.
Пример:         REPLACE  Famil  WITH  "Подпилихвост М.Ю.".
     Пример 3.7. Создадим БД Primer с единственным числовым полем
Num, сделаем в ней 6 пустых записей и заполним их:
  USE Primer
    FOR i = 1 TO 6                && Цикл создания 6 пустых записей
     APPEND BLANK                 && Добавление одной пустой записи
    ENDFOR                         && Команда SKIP в цикле не нужна
  REPLACE Num WITH 3*Recno() ALL    && Обрабатываются все 6 записей
  LIST Num                     && В этой команде "ALL" по умолчанию

     Задание 3.3. Измените программу примера 3.6 так, чтобы она
выводила список мужчин-сотрудников по каждому из отделов. Примените
команду DO WHILE.  Перед списком каждого отдела выводите его
обозначение:       О Т Д Е Л  <Обозначение>.

              3.4. Осуществляем поиск в базе данных

     Поиск перебором записей. В предыдущих примерах поиск
автоматически осуществлялся в процессе вывода. Рассмотрим средства
поиска записей для их обработки. Поиск перебором выполняет команда
        LOCATE <FOR-условие> <Границы> <WHILE-условие> .
Поиск останавливается либо при обнаружении первой записи,
удовлетворяющей FOR-условию, либо при выходе за границу области
действия. Соответственно функция Found() приобретает значение .T.
или .F.. Найденная запись становится текущей и ее можно обрабатывать.
Чтобы найти следующую запись, зачастую используют команду CONTINUE,
но эта команда не контролирует выход из области действия и в ней
не действует WHILE-условие. Используйте SKIP совместно с LOCATE
так, как это сделано в следующем примере.
    Пример 3.8. Файл Kadr (пример 3.3) ранее проиндексирован по
полю Otdel. Требуется подсчитать число мужчин в каждом отделе,
применяя LOCATE для перехода от одной искомой записи к другой.

    USE Kadr
    DO WHILE .NOT.Eof()                      && Проходим весь файл
    K = 0                           && Переменная - счетчик мужчин
    Otd = Otdel
    LOCATE FOR Upper(Pol) =="МУЖ"  WHILE Otdel == Otd
      DO WHILE  Found()
      K = K+1
      SKIP         && Смещаем границу действия команды LOCATE REST
      LOCATE REST FOR Upper(Pol) =="МУЖ"  WHILE Otdel == Otd
      ENDDO
    ? "В отделе", Otd, K, " мужчин"             && Вывод результата
    ENDDO
     Атрибут REST можно опустить, ибо WHILE-условие инициирует
работу, начиная с текущей записи. В дальнейшем вы увидите, что
задача решается проще другими средствами. Здесь нашей целью была
демонстрация возможностей команды LOCATE.
     Быстрый поиск. Команда LOCATE нужна для обеспечения гибкости
программы, однако в больших базах данных перебор записей при поиске
может существенно замедлять работу.   Команда   SEEK <Выр> ,  не
будучи универсальной, обеспечивает быстрый поиск в соответствующим
образом упорядоченной (проиндексированной) БД. Мы не будем
рассматривать аналогичную команду FIND, возможности которой полностью
перекрываются возможностями команды SEEK.
    Аргумент поиска <Выр> дает значение того же типа, что и индексное
    выражение, по которому нужно заранее проиндексировать БД. Этот
индекс при поиске должен быть ведущим. При обращении к записям БД
значение <Выр> сравнивается со значением индексного выражения
(ключа), причем требуется лишь несколько сравнений для того, чтобы
локализовать искомую запись или установить факт ее отсутствия.
Например, указав в команде SEEK конкретный отдел, мы с ее помощью
практически мгновенно получаем доступ к первой записи, относящейся
к этому отделу, конечно, при условии, что БД Kadr проиндексирована
по полю Otdel. Найденная командой SEEK запись становится текущей.
Областью поиска является множество записей, учтенных в индексе.
     Пример 3.9. Осуществим быстрый поиск в БД Kadr сотрудницы с
девичьей фамилией (указанной в БД) Беднякова для замены этой
фамилии на новую - Скоробогатова.

   USE Kadr      && Индексируя БД, мы обеспечиваем применение SEEK
   INDEX ON Upper(Famil+Imya+Otch) TO Fml
   SEEK "БЕДНЯКОВА"                 && Или  SEEK Upper("Беднякова")
    IF Found()
    REPLACE Famil WITH "Скоробогатова"
    ELSE
    ? "Нет такой сотрудницы !"
    ENDIF

     Если в индексном выражении имеются преобразования полей, то и
в аргументе поиска либо точно учитывают эффект преобразования, либо
записывают само преобразование (оба варианта показаны нами в примере).
     Вероятно, вы заметили, что аргумент поиска логически неполный:
имя и отчество мы не указали. Так поступать можно, если мы знаем,
что однофамильцев нет. Команда SEEK работает в режиме SET EXACT OFF
(см. п. 1.4) независимо от того, действует ли этот режим в программе.
Другими словами, если аргумент поиска является начальной подстрокой
ключа записи, первая из таких записей принимается за результат.
     В принципе, может совпадать и полный аргумент. В реальных
программах как аргумент поиска используют не фамилию, а так
называемый табельный номер - уникальное значение в каждой записи
"кадровой" БД.
     Жесткий и нежесткий поиск командой SEEK. Жесткий поиск
(используется по умолчанию) дает однозначный исход: либо искомого
результата нет, либо он есть. Нежесткий поиск обычно предлагает
некоторое значение, вопрос о пригодности которого решается отдельно.
     Функция Found() в любом случае возвращает значение .T., только
если искомое значение найдено. Положение указателя записи (значение
функции Recno()) после неуспешного поиска неодинаково. При жестком
поиске указывается позиция Reccount()+1 за конечной записью файла.
При нежестком поиске функция Recno() указывает позицию, в которой
запись с искомым значением должна была располагаться. Тем самым
обозначается запись с ближайшим следующим значением ключа, если
только аргумент поиска не превосходит все имеющиеся значения ключа.
     Если, установив режим нежесткого поиска и открыв базу Primer
(см. пример 3.7) со значениями 3, 6, 9, 12, 15, 18, проиндексировать
ее и выполнить SEEK 7, функция Recno() примет значение 3, указывая
запись, содержащую "9", а значением функции Found() будет .F.
     В некоторых задачах и такой результат поиска имеет смысл.
Представьте, что в БД Employ разыскивается сотрудник по фамилии,
причем инициалы, а может быть, и окончание фамилии неточны -
неточен аргумент поиска. Нежесткий поиск выводит нас в ту область
файла,  где искомый результат определяется визуально  -  на дисплее.
Подобная ситуация возможна и при числовых ключах. Например, мы ищем
сотрудника с заданным стажем, а точно такого стажа нет, есть
близкое его значение.
     Режим нежесткого поиска в CLIPPER назначается командой  SET
SOFTSEEK ON, в FOXPRO - командой SET NEAR ON. Для возврата к
жесткому поиску надо, применяя эти команды, заменить в них "ON" на
"OFF".
     Задание 3.4. Вновь обратимся к БД Kadr. Составьте программу,
которая используя команду SEEK, находит всех сотрудников со стажем
от 10 до 20 лет включительно и выводит их фамилии и стаж командой
LIST. Команду SEEK используйте дважды - для нахождения нижней и
верхней границы искомой группы записей.

           3.5. Становимся "профессионалами" поиска

     Точный поиск по символьному ключу. Усеченный аргумент поиска
используется часто, но не всегда он приемлем. Представьте, к примеру,
что некоторые изделия обозначены шифрами  "XPR01", "XPR02","XPR022"
и т.п., но не все шифры присутствуют в БД. Пытаясь установить факт
присутствия изделия "XPR02", мы можем получить значение .T. функции
Found() ("успех") при обнаружении шифра "XPR022", ибо аргумент поиска
является подстрокой этого шифра.
     Чтобы команда SEEK выполняла точный поиск, нужно дополнять
аргумент поиска пробелами до размера ключа, в нашем случае - до
размера символьного поля Shifr, используемого в БД  Postavki.
     Пример 3.10. Найдем все записи c заданным значением  поля
Shifr (допустим, каждая запись соответствует одному поставщику
изделия). База данных предварительно проиндексирована по индексному
выражению Upper(Shifr).
    USE  Postavki               &&  Открываем базу данных "Поставки"
    z = Padr("XPR02", Len(Shifr)) && Дополняем аргумент поиска пробелами
    SEEK z
    DO WHILE Upper(Shifr) == z
    ? Recno(), Shifr    && Вместо обработки мы выводим номер и шифр
    SKIP                        && Переход к следующей записи файла
    ENDDO
     Пример 3.11. Рассмотрим случай составного ключа. БД Kadr
проиндексирована по составному ключу командой
      INDEX ON Upper (Famil + Imya + Otch) TO Fio.
     Если мы запишем команду SEEK "Скоробогатова Марина Сергеевна",
то не получим искомой записи из-за "лишних" внутренних пробелов в
составном ключе (каждое поле заканчивается пробелами, если не
занято по максимуму). Есть два пути устранения несоответствия.
 1. Вводить составляющие аргумента поиска в отдельные переменные
F, I, O  и перед конкатенацией дополнять каждую переменную
пробелами до длины соответствующего поля. Получаем аргумент поиска
Upper(Padr(F,Len(Famil)) + Padr(I,Len(Imya)) + Padr(O,Len(Otch))).
 2. Как при индексировании БД, так и в команде SEEK, использовать
вариант конкатенации с удалением "хвостовых" пробелов начальных
слагаемых;  как и выше, используем в аргументе переменные F,I,O:
  INDEX ON Upper (Famil - Imya - Otch)   && "-" знак конкатенации
  SEEK  Upper (F - I - Padr(O, Len(Otch)).
Переменную O мы дополнили пробелами, ибо в индексном выражении
пробелы в конце поля Otch не удаляются. Если бы мы вывели аргумент
поиска, получилось бы следующее:"СкоробогатоваМаринаСергеевна         ".
     В языке CLIPPER точный поиск по аргументу Y, дополненному
пробелами, выполняет универсальный блок Poisk:
FUNCTION  Poisk (Y)  && Объяснение макроподстановки "&" см. в гл. 4
  SEEK Padr(Y, Len (&(Indexkey(0))))
RETURN Found()        && Возвращается .T., если запись найдена в БД

     При составном ключе пользователь должен внимательно соединять
части аргумента Y, не допуская "перекосов" по отношению к ключу.
    Теперь покажем, как обеспечить пользователю интерактивный выбор
между точным и приближенным поиском. Пусть ключом, по которому
проиндексирована БД, будет поле Shifr.

***  Б л о к   п о и с к а   п о   с и м в о л ь н о м у  к л ю ч у
   FUNCTION Vibor
   Arg = Space (Len(Shifr))    && Заполняем пробелами аргумент  Arg
   @ 5, 10  SAY  "Введите значение аргумента поиска"  GET  Arg
   READ
   Otvet = "*"          //Значение, позволяющее циклу начать работу
   DO WHILE  .NOT. Upper(Otvet) $ "YES NO "      && См. $ в п. 1.4)
   Otvet = Space(3)     //Инициализация, необходимая для работы GET
   @ 6, 10 SAY "Выполнять точный поиск [YES, NO] ?   "  GET Otvet
   READ
   ENDDO
   Arg = Iif(Upper(Otvet)="YES", Arg, Trim(Arg) )
   SEEK Arg   //или SEEK Upper(Arg), если Upper - в индексном выражении
   RETURN Found()      //Возвращается .T. в случае успешного поиска

     Здесь переменная Arg независимо от числа введенных в нее
символов сохраняет первоначальный размер строки пробелов - размер
поля (условие точного поиска). В случае приближенного поиска должны
быть отброшены пробелы справа, что и выполняет функция Trim (Arg).
     Как в языке CLIPPER вводить аргумент поиска в случае, если он
является выражением, выбираемым пользователем в процессе решения,
мы рассмотрим в п. 4.9.
     Поиск по близости и по интервалу. Обратимся теперь к числовым
ключам и ключам типа "дата". Для определенности положим возрастающей
последовательность ключей в индексе. Поиск по близости сверху (снизу)
предполагает отыскание в БД ключа, значение которого является
ближайшим не меньшим (не большим) по отношению к аргументу поиска.
Такого ключа в БД нет только в случае, если аргумент больше
(меньше) всех ключей, содержащихся в индексе.
     Очевидно, должен применяться нежесткий поиск с последующей
проверкой указателя записи. Следующий блок реализует поиск по близости.
Y - числовой или типа "дата" аргумент поиска, P задают как .T. (.F.)
для поиска по близости сверху (снизу). Если блок возвращает значение
.T., нужную нам запись указывает функция Recno().

***  Б л о к   п о и с к а   п о   б л и з о с т и   ( CLIPPER )
  FUNCTION Bliz(Y,P)
  LOCAL B,W
  W = Set(_SET_SOFTSEEK, .T.)      && Назначается режим нежесткого поиска
   SEEK Y                          && и запоминается в W исходный режим
   B = Iif (P .AND. Recno() > Reccount(), .F., .T.)
   IF .NOT.P .AND. &(IndexKey(0)) # Y
    SKIP -1
    B = Iif (Bof(), .F., .T.)
   ENDIF
   Set(_SET_SOFTSEEK, W)        && Восстановление исходного режима
  RETURN B   && В программе должна быть директива #include "Set.ch"

***  Б л о к   п о и с к а   п о   б л и з о с т и    ( FOXPRO )
  FUNCTION Bliz
  PARAM Y,P
  PRIVATE B, W, C
  W = Set ("NEAR")            && Запоминается исходный режим поиска
  SET NEAR ON                && Назначается режим нежесткого поиска
  SEEK Y
  B = Iif (P .AND. Recno() > Reccount(), .F., .T.)
  C = Key(Val(Sys(21))) &&Получение выражения ключа ведущего индекса
  IF .NOT. P .AND. &C # Y   && Макроподстановка &C дает ключ текущей
  SKIP -1                                                  && записи
  B = Iif (Bof(), .F., .T.)
  ENDIF
  SET NEAR &W             && Восстановление исходного режима поиска
  RETURN B
     Поиск по интервалу предполагает отыскание всех записей,
наименьшее A и наибольшее B значения ключа которых задано. Определяются
позиции N2, N1 записей, являющихся соответственно верхней внешней
и нижней границей искомых записей в индексной последовательности.
Если разность N1 - N2 равна 0, значит нет ни одной искомой записи.
     Блок Interv поиска по интервалу мы применим для вывода фамилий
всех сотрудников, стаж работы Stag которых  от 10 до 20 лет:

***  CLIPPER-программа поиска по заданному интервалу стажа работы
#include "Set.ch"
  LOCAL N1, N2, A, B
  USE Employ
   INDEX ON Stag TO Stg
   INPUT "Введите нижнюю границу стажа  "  TO A
   INPUT "Введите верхнюю границу стажа  " TO B
   Interv (A, B, @N1, @N2) && Параметры N1, N2 передаются по ссылке
   GO N1                       && Выход на 1-ю из найденных записей
   LIST Famil WHILE Recno() # N2
***  Б л о к   п о и с к а   п о   и н т е р в а л у   ( CLIPPER)
  FUNCTION Interv(A,B,N1,N2)
   LOCAL W
   W = Set(_SET_SOFTSEEK, .T.)
   SEEK A
   N1 = Recno()
   SEEK B
    DO WHILE  &(IndexKey(0)) = B     && Все записи с ключом, равным
     SKIP                    && верхней границе, включаются в ответ
    ENDDO                    && (через соответствующее значение N2)
   N2 = Recno()
   Set(_SET_SOFTSEEK, W)
  RETURN N1 # N2  &&Возвращаемое значение равно .T. лишь при N1 # N2

      Блок Interv можно применять и к символьным полям. Например,
если БД Employ проиндексирована по полю Famil (ведущий индекс),
обращение Interv("А","Ж", @N1, @N2) возвратит номера записей N1, N2
такие, что в группе записей с фамилиями от "А" до "Ж" первая будет
иметь номер N1, а последняя - будет предшествовать (по индексу)
записи с номером N2. Если же таких фамилий нет, N1 = N2. Если вы
замените в команде  DO WHILE знак "=" на "==", фамилии, начинающиеся
с буквы "Ж", включены в ответ не будут. Объясните данный эффект.
      Задание 3.5. Составить и испытать блок поиска записей по
интервалу для языка FOXPRO, используя детали блока поиска по близости
и основные идеи приведенного выше блока поиска по интервалу.

         3.6. Находим числовые характеристики. Команда SCAN

     Для типичных задач нахождения числовых характеристик  поиск и
обработка записей соединены в командах, имеющих неявный цикл.
     Подсчет записей. Обработку заданного подмножества записей с
занесением счетчика в <Переменную> выполняет команда
           COUNT <Границы> <Условия> TO <Переменная> .
     Пример.  COUNT FOR Deleted() TO N    && Счетчик записей,
                                          &&помеченных на удаление
     В команде FOXPRO может отсутствовать даже <Переменная>: команда
COUNT имеет тот же результат, что и Reccount(), но в отличие от
функции выводит число записей БД на дисплей.
     Пример 3.12. Откроем БД Kadr и подсчитаем число сотрудников по
отделам:
   USE Kadr              && Индекс Tdl либо создаем, либо указываем
   INDEX ON Otdel TO Tdl     && в команде USE, если он создан ранее
   Otd = Otdel   && Запоминание отдела, указанного первым в индексе
    DO WHILE .NOT. EOF()
    COUNT WHILE Otdel = Otd TO N
    ? "В отделе ", Otd, N, " сотрудников"
    Otd = Otdel                    && Запоминание следующего отдела
    ENDDO
     Нам не потребовалась команда SKIP, ибо в COUNT - свой неявный
цикл с перемещением по БД. Пояснений требует завершение работы.
Команда COUNT фиксирует конец БД и последний раз передает счетчик в N,
происходит вывод; состояние EOF() = .T. сохраняется и улавливается
командой DO WHILE, завершающей цикл.
     Нахождение суммы и среднего арифметического.   Команда
   SUM <Список вырN> <Границы> <Условия> TO <Список переменных>
заносит значение суммы для каждого <вырN>, полученной на некотором
множестве записей активной БД, в соответствующую (по положению в
списке) переменную, а команда AVERAGE с той же самой структурой и
действием отличается от SUM лишь результатом - средним арифметическим.
В FOXPRO <Список переменных> можно не предусматривать (при
автоматическом выводе результатов на дисплей), его можно также
заменять атрибутом ARRAY <Массив>.  <Массив> должен быть заранее
описан, в 1-й его элемент заносится 1-й результат  и т.д.
     Пример 3.13. Откроем БД Kadr и найдем средний стаж SS и
среднюю заработную плату SZ (поле Zarp используется для значений
заработной платы) для непомеченных на удаление записей (для не
уволившихся сотрудников):
        AVERAGE Stag, Zarp  FOR .NOT.Deleted()  TO SS, SZ .
     Применяемая к активной БД, проиндексированной или
отсортированной по ключу <Выр>, команда с неявным циклом
TOTAL ON <Выр> TO<Имя БД> FIELDS <Список полей> <Границы> <Условия>
создает новую БД (ее обозначает <Имя БД>), в которую заносятся суммы
числовых полей, указанных в команде. Суммируются поля последовательно
идущих записей, для которых значение <Выр> одинаково. Таким
образом, для каждой имеющейся в активной БД группы записей с общим
значением ключа <Выр> создается  о д н а  новая запись, содержащая
указанные суммы. Если активная БД не упорядочена, вы получите
бесполезную новую БД. В отсутствие <Списка полей> вырабатываются
итоги для всех числовых полей.
     Структура создаваемой БД идентична структуре исходной активной
БД, поэтому надо следить за тем, чтобы размеры подытоживаемых полей
в исходной БД были достаточными для размещения сумм (в новой БД).
     Пример 3.14. БД Kadr проиндексирована по полю Otdel.
    TOTAL ON Otdel TO Itog FIELDS Zarp  FOR .NOT.Deleted() .
По каждому отделу будет найдена сумма заработной платы; естественно,
уволившиеся не учитываются. В новой БД Itog будет столько записей,
сколько значений поля Otdel в БД Kadr. В них поле Zarp будет
содержать сумму заработной платы по отделу, прочие поля "наследуют"
значения от первой записи в соответствующей группе исходных записей:
фамилию, стаж и т.п. Конечно, при выводе, кроме полей сумм нас
интересуют лишь ключевые поля, входящие в <Выр>. В нашем примере это
поле Otdel. Если исходная БД не сортировалась по ключу <Выр>, а
была упорядочена путем индексирования по этому ключу, команда TOTAL
нормально функционирует, только если индекс - без атрибута UNIQUE.
     В языке FOXPRO имеется команда универсального действия
CALCULATE с такой же структурой, как у команд SUM, AVERAGE, допускающая
в своем списке выражений следующие функции (вне ее не используйте!):
  AVG(<ВырN>) - среднее арифметическое значений <ВырN>;
  CNT()       - счетчик записей в некотором множестве записей;
  MAX(<Выр>)  - максимальное значение выражения <Выр>;
  MIN(<Выр>)  - минимальное значение выражения <Выр>;
  STD(<ВырN>) - среднеквадратическое отклонение для <ВырN>;
  SUM(<ВырN>) - сумма значений <ВырN> на множестве записей;
  VAR(<ВырN>) - дисперсия значений <ВырN>;
  NPV(<ВырN1>,<ВырN2>,<ВырN3>) - финансовая функция (см. [3] ).
Выражения <Выр>,<ВырN> содержат имя поля активной БД (или имена
нескольких полей активной БД).
     Пример 3.15. Пусть имена P1 - P4 обозначают поля активной БД.
  CALCULATE MAX(P2/P1), MIN(P3+P4), AVG(P1**2-SQRT(P3)) TO ARRAY Z
будет иметь итогом своего выполнения следующие значения в массиве:
  Z[1] - максимум отношения значений полей P2 и P1;
  Z[2] - минимум суммы значений полей P3 и P4;
  Z[3] - среднее арифметическое выражения  AVG(P1**2-SQRT(P3)).
К сожалению, записи, в которых найдены максимум и минимум, не
указываются. Конечно, значения Z[1], Z[2] можно использовать для их
поиска.
     Структура  SCAN  ... ENDSCAN, имеющаяся в языке FOXPRO,
облегчает обработку БД. Ее начальная команда имеет вид
                 SCAN <Границы>, <Условия>
     Пример 3.16. Найдем в БД Prim среди записей, не помеченных на
удаление, запись с максимальным отношением P2/P1 и запись с
минимальной суммой P3+P4, где P1 - P4 - поля БД Prim.
  DECLARE Z[2]
  USE Prim
  SET FILTER .NOT.Deleted()
  GO TOP
   Z[1] = P2/P1
   Z[2] = P3+P4
   STORE Recno() TO N1, N2
    SCAN REST       && Определили область действия атрибутом REST
     IF P2/P1 > Z[1]
     Z[1] = P2/P1
     N1 = Recno()
     ENDIF
     IF P3+P4 < Z[2]
     Z[2] = P3+P4
     N2 = Recno()
     ENDIF
    ENDSCAN
     Вместо FOR-условия в команде SCAN мы использовали фильтр, ибо
нужно еще до цикла SCAN выйти на первую запись, удовлетворяющую
условию, и используя ее поля, получить отправные значения Z[1],Z[2].
В языке CLIPPER вместо структуры SCAN мы воспользуемся функцией
DBEval(), описанной в п. 4.2.
     Задание 3.6. Взяв за основу программу примера 3.12, запишите
программу, выводящую для каждого отдела процент женщин-сотрудников.
Для подсчета используйте только команду COUNT. Предварительно
проиндексируйте БД по полям Otdel (главное поле) и Pol.

             3.7. Начинаем работать с MEMO-полями

     Прекрасная вещь - фиксированный размер записи в  .DBF-файле
базы данных! Именно это обеспечивает быстрый (прямой) доступ к
любой записи: система по номеру записи вычисляет ее адрес в памяти.
Но во многих реальных задачах есть надобность вносить в запись
информацию переменной длины. В БД Kadr (пример 3.3) ею может быть
"досье", касающееся служебных перемещений сотрудника, замечаний и
благодарностей по выполненным работам и т.п. Некоторые записи БД
могут не иметь (хотя бы временно) такой информации.
     Для хранения информации переменной длины используют либо
символьное поле, назначенное с максимальной длиной, либо MEMO-поле.
В первом случае недостатком может быть низкий (вплоть до 0 в
отдельных записях) процент использования поля для хранения данных.
Кроме того, в FOXPRO максимальная длина символьного поля - 254 байта
(в CLIPPER - 64 K), данные MEMO-поля имеют предельную длину 64 K.
     MEMO-поля используют память динамически: они увеличиваются по
мере надобности. В каждой записи .DBF-файла БД имеется поле,
занимающее 10 байт, для ссылки на MEMO-данные, а сами эти данные
размещаются в отдельном файле с таким же именем, как у .DBF-файла,
и расширением .DBT (CLIPPER) или .FPT (FOXPRO). Будем называть его
Memo-файлом.
     Память в Memo-файле выделяется блоками, стандартный размер Rb
которых в языке CLIPPER равен 512 байтам, в FOXPRO - 64 байтам.
Если хотя бы приблизительно известна средняя длина Rcp MEMO-данных,
общее число N записей и средний процент Pr записей с MEMO-данными,
можно найти предполагаемые затраты памяти по формуле
         N*10 + (N*Pr/100) * Rb * Int((Rcp + Rb -1)/Rb)
и сравнить их с потенциальными затратами на символьное поле
максимальной длины Rmax: N*Rmax. Cлагаемое N*10 учитывает размещение
ссылок в .DBF-файле. Понятно, что при низком проценте Pr, а также
если  Rmax > Rb, Rcp > Rb  и  Rmax >> Rcp, MEMO-поля окажутся
предпочтительнее. Memo-файл - один при любом числе MEMO-полей в
структуре БД. Под его заголовок расходуется 512 байт.
     В FOXPRO вы можете назначить размер блока Rb командой   SET
BLOCKSIZE. Память экономнее используется при малых Rb, но при этом
снижается скорость доступа к MEMO-данным при увеличении их длины.
     В СУБД имеется мощный набор команд и функций для работы с
MEMO-полями, но для первого знакомства можно ограничиться командой
REPLACE, которая позволяет их наполнять, и командами DISPLAY, LIST,
позволяющими MEMO-поля выводить.
     Пример 3.17. Расширим с помощью утилиты DBU (CLIPPER) или
команды MODIFY STRUCTURE (FOXPRO) структуру БД Kadr, добавив в нее
MEMO-поле Dosje, а затем программным путем внесем в MEMO-поля
некоторых записей какую-либо информацию (если оставляете поле
пустым, нажимайте сразу Enter в ответ на приглашение ACCEPT):

  USE Kadr
  DO WHILE .Not. EOF()
   ACCEPT "Введите Dosje. Сотрудник " + Famil  TO  S
   REPLACE Dosje WITH S    && "WITH Dosje + S", если надо дополнять
   SKIP
  ENDDO
  LIST Famil, Dosje           && Просмотр введенной MEMO-информации

     В языке  CLIPPER для первоначального занесения или замены MEMO-
данных можно использовать команду  REPLACE Dosje WITH MemoEdit() ,
для дополнения MEMO-полей новыми данными - оператор  REPLACE Dosje
WITH MemoEdit(Dosje); команда ACCEPT не нужна. Завершая набор
(дополнение) текста в режиме MemoEdit(), нужно нажимать клавиши
CTRL-W. Подробно средства работы с MEMO-данными рассмотрены в гл. 8.
     При увеличении размера MEMO-данных могут возникать неиспользуемые
блоки, как и при удалении записей. Уплотнение Memo-файлов рассмотрено
в п. 3.8.
     Задание 3.7. Измените программу примера 3.17 с тем, чтобы она
дополняла MEMO-данные, и опробуйте ее на БД Kadr.

         3.8. Переименовываем, стираем, копируем, уплотняем
                               базы данных

    Ниже мы воспользуемся командой переименования файла, имеющей
вид            RENAME <Старое имя> TO <Новое имя>.
Расширения имен обязательны, если они есть. Если <Новое имя> содержит
путь к файлу или устройство, файл переместится согласно этим указаниям.
     Попытка переименовать активную БД ведет к непредсказуемым
последствиям. Если <Новое имя> дублирует имя существующего файла,
команда игнорируется. Если переименовывается БД с MEMO-полями, надо
переименовать и MEMO-файл, иначе при обработке MEMO-полей возникнут
ошибки.
     Стирание любого неоткрытого (закрытого) файла реализует
команда  ERASE <Имя файла с расширением>   или эквивалентная ей
команда DELETE FILE <Имя файла с расширением>. Аргумент команд может
включать и путь к файлу.
    В языках FOXPRO и CLIPPER есть 2 команды копирования файлов:
одна копирует активную БД и будет рассмотрена позднее, другая
применима к неоткрытым (закрытым) файлам любого типа:
  COPY <Имя исходного файла с расширением> TO <Имя файла-копии с
расширением>. Данная команда непригодна для копирования БД с
MEMO-полями. Если перед применением любой из 2 команд копирования
существовал файл с именем файла-копии, он аннулируется без
предупреждения.
     Другая, "специализирующаяся" на файлах БД команда копирования
COPY TO <Имя файла-копии> FIELDS<Список полей> <Границы> <Условия>
<Представление>,   копирует не только .DBF-файл, но и Memo-файл
(если в БД имеются MEMO-поля). Файл-копия может быть базой данных
или ASCII-файлом, форма записи данных в который определяется
необязательным атрибутом <Представление>. Копируются поля, указанные
в списке полей. Если атрибут  FIELDS <Список полей>  отсутствует,
копируются все поля. Если копирование происходило при включенном
индексе, записи в копии размещаются в порядке, заданном индексом.
     При работе с БД следует избегать необратимых, потенциально
опасных действий. Поэтому не рекомендуется применять команду PACK,
уплотняющую .DBF-файл путем изъятия записей, помеченных на удаление.
Неполадки с электропитанием, случайное отключение ЭВМ могут привести
к утрате данных при ее выполнении. Другая причина - команда PACK
языка CLIPPER не уплотняет Memo-файл. Предлагается использовать
команду COPY TO.
     Пример 3.18. Блок уплотнения базы данных, включая Memo-файл.

* Блок написан для CLIPPER, для FOXPRO надо в 4 строках заменить
* ".DBT" на ".FPT";   строки, где нужны замены, сдвинуты вправо
* Блок Allpack н е  с л е д у е т  применять к  о т к р ы т о й  БД

 FUNCTION AllPack
 PARAM DBName                && Имя БД в виде строки без расширения
 PRIVATE A, R
 R = Select()                && Запоминание текущей рабочей области
 A = DBName + ".DBF"
 RENAME &A TO _Vrem.DBF      && Переименование исходного .DBF-файла
      A = DBNAME + ".DBT"
 IF File(A)                     && Проверка наличия MEMO-полей в БД
      RENAME &A TO _Vrem.DBT && Переименование исходного MEMO-файла
 ENDIF
 SELECT 0               && Переключение на первую свободную область
 USE _Vrem                         && Открытие исходной базы данных
 COPY TO &DBName FOR .NOT.Deleted()       && Копирование со сжатием
 USE                               && Закрытие исходной базы данных
 ERASE _Vrem.DBF                   && Удаление исходного .DBF-файла
      IF File("_Vrem.DBT")
       ERASE _Vrem.DBT             && Удаление исходного MEMO-файла
   ENDIF
  SELECT (R)                   && Возврат к прежней рабочей области
 RETURN
     Если аварийное отключение ЭВМ произойдет при работе блока, то
исходная БД сохранится либо под первоначальным именем, либо под
именем _Vrem. После уплотнения БД нужно воссоздать индексы (если они
существовали) командой REINDEX, открыв БД со списком индексов.
    Близка по назначению к командам копирования команда APPEND FROM:
APPEND FROM <БД> <Область действия> FIELDS<Список полей> <Условия>.
Она открывает файл-источник <БД> (если эта <БД> была открыта до команды
APPEND, следует предварительно закрыть ее) и использует его записи
для создания соответствующего числа новых, добавляемых в конец
активной БД. Если список полей не задан, то записи копируются одна к
одной, иначе копируются значения только указанных полей файла-источника,
иные поля (если они есть) в новой записи не заполняются. При заданном
FOR-условии записи из области действия (по умолчанию - весь файл-источник)
отбираются по этому условию. Аргумент <БД> может быть задан в виде
литерала (имени БД или имени ASCII-файла) либо в виде ( <ВырC> ).
Если активная БД была пустой, имеет место обыычное копирование.
     Команды копирования нередко применяют для создания рабочей БД
под конкретную задачу (подзадачу), отбирая в БД лишь нужные данные
и сокращая время обработки данных за счет уменьшения размеров БД.
     Задание 3.8. Создайте пустую БД  Rab1 с полями Famil (фамилия
и инициалы личности), Dtr (дата рождения), NumD (число детей). С
помощью команды APPEND FROM перенесите в Rab1 данные из БД  Kadr
(пример 3.3) и убедитесь в правильности переноса, выполнив LIST
(поле NumD остается пустым).

           3.9. Выполняем сортировку записей базы данных

     Сортировка БД выполняется путем создания новой БД, в которой
физическое размещение записей соответствует заданному принципу. По
умолчанию числовые поля упорядочиваются по возрастанию, даты -  в
хронологическом порядке, строки получают "словарную"
последовательность, а порядок логических значений таков: сначала .F.,
затем .T..
     Сортировка - времяемкий процесс, уже поэтому рекомендуют
применять ее реже, а чаще - индексирование. Включение новых записей
в ранее отсортированную БД также проигрывает по времени их включению
в индекс, причем лишь последнюю работу система берет на себя.
Поэтому в больших БД сортировка оправдана, лишь когда данные
относительно статичны, а создаваемая упорядоченность записей
используется во многих задачах или длительное время. При этом
другие варианты их упорядоченности обеспечиваются индексированием БД.
Нужно также иметь в виду, что сортировке требуется резерв памяти
на диске, вдвое больший, чем память, занятая исходной БД.
     Сортировку записей активной БД выполняет команда
  SORT ON <Список полей> TO <Имя новой БД> <Границы> <Условия> .
Элемент списка полей может сопровождать атрибут /A (сортировка по
возрастанию чисел, дат и т.п.), /D (сортировка по убыванию) или /С
(сортировка символьного поля, не учитывающая регистр букв). Атрибут
/A можно не писать, атрибут /DC соединяет смысл двух атрибутов.
Порядок полей в <Списке полей> имеет значение: первое
поле считается главным, приоритет следующих - убывает.
Упорядоченность по главному полю - глобальная, по остальным -
локальная, в пределах подмножеств записей.
     Пример 3.19. Нужно в БД Kadr (см. пример 3.3) разместить
записи группами, отдел за отделом (глобальный порядок), а в каждой
группе - раздельно "мужские" и "женские" записи (локальный порядок).
"Мужские" записи будем размещать до "женских", а поскольку значение
"МУЖ" поля Pol по алфавиту идет после "ЖЕН", требуется атрибут /D;
чтобы исключить влияние регистра букв, укажем и атрибут /C (если
вместо значений "МУЖ","ЖЕН" записаны "муж","жен", это не повлияет).

***   При сортировке программа заодно уплотняет  .DBF-файл
 USE Kadr
 SET DELETED ON  && Делаем невидимыми записи,помеченные на удаление
  SORT ON Otdel/C, Pol/DC TO _Temp      && _Temp - имя временной БД
 USE                                    &&  Закрываем  БД  Kadr
 COPY FILE _Temp.dbf TO Kadr.dbf   && Заменяем прежнее содержание БД
 ERASE _Temp.dbf                        && Стираем рабочую БД  _Temp

     Заметим, что имевшиеся прежде индексы БД Kadr надо воссоздать,
выполнив команды   USE Kadr INDEX <Список индексов>,  REINDEX.
     Итак, сортировка по списку полей, равно как и индексирование
по составному ключу, позволяет получить последовательность записей
БД с иерархической (не явной) структурой. Сортировка может быть
выполнена без команды SORT, копированием проиндексированной
соответствующим образом БД при условии, что этот индекс - ведущий.
     Для увеличения "привлекательности" команды SORT язык FOXPRO
предусматривает дополнительный ее атрибут: FIELDS  <Список полей новой
БД>. Получается, что при сортировке мы можем сокращать таблицу (БД)
по любому измерению. Могут быть указаны поля из дочерних БД по
отношению к активной БД, естественно, уточненные алиасом или именем
БД. Для вставки в ранее отсортированную БД новых записей в FOXPRO
используют команду INSERT, но место вставки определяет пользователь.
     Задание 3.9. Составить новый вариант программы примера 3.19.
В ней  а) проиндексировать БД Kadr по составному ключу (поля Otdel,
Pol);  б) скопировать БД Kadr; в) удалить БД Kadr; г) переименовать
копию, указав Kadr как новое имя.

           3.10. Обеспечиваем взаимодействие баз данных

     Из гл. 2 вы знаете, как устанавливать соответствие записей
материнской и дочерних БД. Кроме того, вам известно, что поля
открытых БД, уточненные алиасами или именами БД, могут использоваться
совместно. Здесь же мы рассмотрим две команды с неявным циклом,
реализующие массовую обработку записей.
     Команда JOIN осуществляет взаимодействие активной БД (БД1) и
другой открытой БД (БД2), формируя на их основе новую БД путем
построения записи из каждой пары (запись БД1, запись БД2),
удовлетворяющей FOR-условию, указанному в команде JOIN:
JOIN WITH <Область> TO<Новая БД> <FOR-условие> FIELDS<Список полей>
Атрибут <Область> (рабочая область базы БД2) может быть задан
номером области, а также алиасом или именем БД2. В <Списке полей>
могут указываться поля БД1 и БД2 (поля БД2 - с уточнением имени).
     Если атрибут FIELDS<Список полей> не задан, в новую БД
включаются все поля двух исходных БД.
     Пример 3.20. В БД Student имеются поля Famil, Pol, Fak
(факультет), Spec (специальность) и др., причем специальность задана
шифром. В БД SpecBD имеются поля Shifr (шифр специальности, как и
в поле Spec БД Student), Name (название специальности). Для вывода
формы, в которой фамилия студента сопровождается названием
специальности, мы могли бы установить связь двух БД   (SET RELATION).
Альтернативой является создание рабочей БД _Temp  с полями Famil,
Pol, Fak, Name:
  USE SpecBD           && Открываем БД с расшифровкой специальности
  SELECT 2              && Назначаем рабочую область для БД Student
  USE Student
   JOIN WITH SpecBD   TO _Temp   FOR Spec = SpecBD->Shifr ;
                             FIELDS Famil, Pol, Fak, SpecBD->Name
     Команда JOIN выполняет двукратный перебор записей, рассматривая
в ходе перебора  N*M записей, где N, M - количества записей
исходных БД. В зависимости от характера FOR-условия число записей
новой БД может оказаться любым, в частности, близким к пределу N*M.
Если, например, N = M =1000, то может быть создано до миллиона
записей. Неумелое применение JOIN в больших БД часто ведет к
перерасходу времени и дисковой памяти. В языке FOXPRO рекомендуется
использовать не JOIN, а более эффективную и гибкую команду SELECT.
     Команда  UPDATE использует встроенную команду REPLACE (см.
п.3.3) для обновления данных активной БД (БД1) данными другой
открытой БД (БД2), причем в обновлении записи с ключом K участвует
группа записей БД2, ключ которых имеет значение K. Активная
(обновляемая) БД должна быть проиндексирована или отсортирована
по этому ключу, что желательно и для БД2 (ускоряется обработка).
Если же БД2 не упорядочена, это обозначают атрибутом RANDOM;
для отбора записей с одинаковым ключом выполняется простой перебор.
     Команда UPDATE имеет следующую структуру:
   UPDATE ON <Ключ> FROM <Область> <Команда REPLACE>  RANDOM .
Параметр <Область> - это имя или алиас БД.
     При обновлении всех записей БД1 они должны иметь уникальные
значения ключа, иначе обновляется лишь одна запись (первая) для
каждого значения ключа. Требование уникальности ключа на БД2 не
распространяется. Ситуация, когда для записи БД1 нет подходящей
записи в БД2, считается нормальной (запись БД1 не обновляется).
     Пример 3.21. Обновляемой БД является база Account с уникальным
полем Num (номер счета клиента) и полем Sum (денежная сумма на этом
счете). Обновление состоит в снятии со счетов расходов на те или
иные покупки, сведения о которых представлены полями Ras (расход) и
Num (номер счета) в БД Trati. В этой БД поле Num не уникально, ибо
клиент может сделать несколько покупок.

 USE Trati &&БД не проиндексирована и не отсортирована по ключу Num
  SELECT 2              && Назначаем рабочую область для БД Account
 USE Account
 INDEX ON Num TO NumAc
 UPDATE ON Num FROM Trati RANDOM;      && Команда продолжается ниже
               REPLACE Sum WITH Sum - Trati->Ras
    Одна команда REPLACE может обновлять и несколько полей записи.
Типичным применением команды UPDATE является перенос в исходную БД
результатов обработки некоторого ее подмножества - рабочей БД.
     Задание 3.10. На основе БД Kadr (см. пример 3.3) создайте
рабочую БД, включив в нее усеченные "мужские" записи, содержащие
лишь поля Famil и Stag (стаж). Командой LIST осуществите их вывод.
Затем в каждой записи рабочей БД увеличьте значение поля Stag на 1.
Командой UPDATE перенесите значения поля Stag в исходную БД и
выведите на дисплей поля Famil, Stag для "мужских" записей, чтобы
убедиться в правильной работе программы.

                 3.11. Программно создаем и изменяем
                          структуру баз данных

     Копирование структур БД - распространенный случай. Если,
допустим, разделы картотеки книжного фонда представлены отдельными БД,
структура их идентична. При образовании нового раздела можно
применить команду    COPY STRUCTURE TO <Имя БД> FIELDS <Список полей>,
создающую пустую БД с указанным именем, которая будет иметь структуру
активной БД - БД существующего раздела. В нашем примере атрибут FIELDS
не нужен. Он используется, когда структура новой БД является
подмножеством исходной, и указывает необходимые поля.
     Если данная операция производится часто, имеет смысл хранить
"эталонную" структуру в виде пустой БД.
     Пример 3.22. USE Etalon            && Открываем "эталонную" БД
             COPY STRUCTURE TO NewBD    && Создаем новую пустую БД
             < Наполнение NewBD >
     Если структура заимствуется частично и дополняется (при этом,
возможно, модифицируется, например, изменяется размер полей), то
сначала заимствованная часть запоминается в виде "файла-макета",
затем, если нужно, производят ее изменение, усечение, дополнение,
а далее - создают по файлу-макету новую БД (пустую). В файле-макете,
который также является базой данных, каждая запись описывает
поле БД и включает в себя следующие 4 поля:
 Field_name (тип C, длина 10),  содержит имя описываемого поля,
 Field_type (тип C, длина 1),   содержит тип описываемого поля,
 Field_len (тип N, длина 3),    содержит размер описываемого поля,
 Field_dec (тип N, длина 4), содержит длину дробной части или ноль.
     Команда  COPY STRUCTURE EXTENDED TO <Имя файла-макета>
копирует (без изменения) структуру активной БД в создаваемый
автоматически файл-макет. Вы можете дополнить его пустыми записями
(команда APPEND BLANK) а затем командой REPLACE внести в них описания
добавляемых в структуру полей.
     Пустой файл-макет с именем <ВырC> создает команда CREATE <ВырC>,
используемая, когда структура БД создается "от нуля". Пустой файл-
макет автоматически открывается в текущей рабочей области, закрывая
активную БД (если она была). Во избежание закрытия выполняйте
предварительно команду SELECT 0.
     Создание новой (пустой) БД по файлу-макету выполняет команда
           CREATE <Имя новой БД> FROM <Имя файла-макета> .
Создаваемая БД автоматически открывается в текущей рабочей области.
     Пример 3.23. На основе структуры БД Student создается пустая
БД Aspirant, причем 5 и 7 поля исходной структуры не нужны, но надо
добавить поле Proc (процент готовности диссертации).
   USE Student
   COPY STRUCTURE EXTENDED TO Maket         && Создается файл-макет
   USE Maket
   GO 5
   DELETE                   && Помечаем описание 5 поля на удаление
   GO 7
   DELETE                   && Помечаем описание 7 поля на удаление
   PACK                  && Физически исключаем описания 5 и 7 поля
   APPEND BLANK          && Добавляем в конец макета пустую запись
   REPLACE Field_name WITH "Proc", Field_type WITH "N", ;
           Field_len  WITH 2,  Field_dec WITH 0
   CREATE Aspirant FROM Maket  && Создается и становится активной БД
   < Наполнение БД Aspirant >
    Воспользуемся этим примером для разбора характерной ошибки.
Сделаем внешне безобидное изменение программы, вставим команду
SELECT 0 перед CREATE ... FROM. Теперь БД Aspirant будет открыта в
первой свободной области. Но в этом случае БД Maket оказывается
незакрытой, изменения структуры не находят отражения в файле БД
Maket и создается БД Aspirant с неверной структурой. Закройте БД
Maket перед ее использованием для создания БД, например, дайте
команду USE. В языке CLIPPER5.01 альтернативой является использование
функции DBCommit().
     Изменение структуры действующей БД. Команда COPY STRUCTURE
EXTENDED дает возможность изменения структуры БД без утраты данных БД.
Допустим, в БД Student 5 и 7 поля перестали быть нужными, но требуется
поле Proc - процент выполнения учебного графика. Необходимую
нам рабочую БД назовем Aspirant. Остается дополнить программу примера
3.23 командой APPEND FROM Student (перенос данных в рабочую БД;
это и будет "Наполнением БД Aspirant"), командой удаления исходной
БД  ERASE Student.dbf  и переименования - RENAME Aspirant.dbf TO
Student.dbf. Memo-файл, если он имеется, изменениям не подвергался.
     Кроме показанных в программе усечения и дополнения структуры,
вы можете изменить длину символьных полей в любую сторону. В новой
БД поле Proc, естественно, будет незаполненным. Изменение типа поля
производят редко; этот сложный случай модификации БД здесь не
рассматривается. В п. 5.9  мы продолжим тему создания и изменения
структур БД.
     Задание 3.11. Проверьте ваше понимание темы следующим упражнением:
используя команду CREATE или с помощью утилиты DBU, создайте
структуры двух БД A и B, затем наполните БД A, а далее, используя
команду COPY STRUCTURE EXTENDED, сведите структуры в одну с помощью
команды APPEND FROM и откройте БД, имеющую "сводную" структуру.
Затем перенесите в нее данные БД  A.

                        ЗАКЛЮЧЕНИЕ К 3-Й ГЛАВЕ

     Если вы выполнили задания данной главы на ЭВМ и проанализировали
примеры, ответы к заданиям, вы поднялись на 2 ступень в овладении
базами данных. "Повышение квалификации" произойдет в разделах по
языкам CLIPPER и FOXPRO. Изучив универсальные блоки (пп. 3.5, 3.8,
ответ к заданию 3.5), начните создание "библиотеки" таких блоков,
пополняя ее новыми блоками по ходу изучения следующих глав. Файл с
этими блоками облегчит вам реализацию сложных примеров задач.
